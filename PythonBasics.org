# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+title: Python Basics
#+author: Dr. E.P. Blair

* Notebook Setup

The following is helpful if we want to have =org-mode= sessions linking
multiple code blocks /and/ we are using =direnv=.

#+begin_src emacs-lisp
(setq-local org-babel-python-command (expand-file-name "./.direnv/python-3.11/bin/python3"))
#+end_src

#+RESULTS:
: /Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/bin/python3

#+begin_src python :results output
import sys

print(sys.executable)
#+end_src

#+RESULTS:
: /Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/bin/python3

* Variables

** Creating Variables

Values are stored in memory and accessed using variable names. This
is done using the assignment operator, ===, using the syntax
=<variable_name> = <value>=. Here are some basic examples:
#+begin_src python :exports both :session py-vars :results output
a = 3 # assign the value 3 to variable a
b = 5 # assign 5 to variable b
print('a+b = {0}'.format(a+b))

c = a - b # evaluate a-b, store in c
d = a/b # evaluate a/b, store in d
#+end_src

#+RESULTS:
: a+b = 8

Generally, in Python, you won't see variable values unless:
1. You are working in a Jupyter Lab notebook.
   1. In Jupyter, code is entered and evaluated in groups called
      /cells/. A cell may contain multiple lines of code.
   2. In this case, Jupyter will not display any values or graphics,
      except for the result of the last command in the cell.
2. You instruct Python to do so using the =print()= command.

Note from the author/instructor: the above code block behaves /like/
a Jupyter cell in the sense that its variables persist and are
accessible in other code blocks, so long as those code blocks participate
in the same Python session. Code blocks need not be attached to a Python
session, in which case they are stand-alone code blocks.

** Displaying Variables

In the follwoing code block, we print variables from the previous
code block. To do this, we use the =print()= command, which prints
strings. To do this, we either convert variables to strings, or we
form strings with variable values embedded in them.
#+begin_src python :session py-vars :results output :exports both
print('hello world') # print a basic string

print(a) # print the value of a variable

# Make an f-string (fstr) named myFirstfstr
#    This has variable values embedded within it
myFirstfstr = f'c = {c}; d = {d:5.3f}' 
print(myFirstfstr) # print the f-string

myStr = 'cat' # store a string
# embed myStr in another string
mySecondFStr = f'some word: {myStr}'
print(mySecondFStr)
#+end_src

#+RESULTS:
: hello world

** Complex Numbers
Here is an example of how Python handles complex numbers. In
Python, we can use =1j= for the imaginary unit, \(i\), and, say,
=5j= for \(5i\).
#+begin_src python :results output :exports both
# Example: complex numbers
X = 3 + 2j # complex number
absX = abs(X)

# print the complex X using an f-string
#   form the f-string inside of print()
print(f'X = {X}; |X| = {absX:06.3f}')
#+end_src

#+RESULTS:
: X = (3+2j); |X| = 03.606

We also used =abs(X)= to obtain the modulus of $X$.

** Assign Multiple Variables in a Single Line
One neat trick in Python is that we can define several
variables using only one assignment statement.
#+begin_src python :results output :exports both
x, y, z = 1+2, 2*3, 4/5
print(f'x = {x}; y = {y}; z = {z:5.3f}')
#+end_src

#+RESULTS:
: x = 3; y = 6; z = 0.800

** Variable Types
- Variables come in different types.
  - Each variable type–or more generally, class
    (more on this later)–has a different syntax and behaviors
    governing what we can do with variables of that type
- We've encountered some different variable types by now:
  - strings - store lists of characters, as in text
  - integers - (self explanatory)
  - floating point numbers (self explanatory)
  - complex numbers - (self explanatory)
- We can interrogate the type of a variable, say, =x=, using the
  command =type(x)=
#+caption: We use the =type()= command to return the type of a variable.
#+begin_src python :results output :exports both
a, b, c, d = 1, 3.14, 2+3j, False

print('type of a: {0}'.format(type(a)))
print('type of b: {0}'.format(type(b)))
print('type of c: {0}'.format(type(c)))
print('type of d: {0}'.format(type(d)))
#+end_src

#+RESULTS:
: type of a: <class 'int'>
: type of b: <class 'float'>
: type of c: <class 'complex'>
: type of d: <class 'bool'>

** Boolean Variables
- We introdcued another data type: =bool=, short for /Boolean/
  - Boolean variables have one of two values: =True=, or =False=
  - These may be used to control whether sections of code get
    executed or skipped, using logical control statements
    (a.k.a. logical controls)
- Boolean variables are typically the result of a comparison
  - Comparisons may be performed between pairs of variables or values
    - Here, we must use comparison operators such as =<= (less than),
      =>= (greater than), ==== (equal to), =>== (grater than or equal to),
      =<== (grater than or equal to), =!== (not equal to), etc.
  - Comparison operators are used to form logical expressions, which
    are evaluated as either True or False. Some examples:
    - The logical expression =3<5= will evaluate to =True=, but
      =3>5= will evaluate to =False=
      - =a==b= may evaluate either to =True= or =False=, depending
        on the values stored in =a= and =b=.
        - If the two values are equal, then this statement
           evaluates to =True=
        - otherwise, it evaluates to =False=
  - The value resulting from a logical expression may be:
    - stored in a variable, which will be of the type =bool=
    - used in a logical control structure, which determines whether
      or not a block of code gets executed
#+begin_src python :results output
a = 3 < 5
b = 5 < 3
c, d, f = 3 > 5, 3 < 5, 3==5

print('type of a: {0}; a = {1}'.format(type(a), a))
print('type of b: {0}; b = {1}'.format(type(b), b))
print(f'c = {c}; d = {d}; f = {f}')
#+end_src

* =if= Statements
- if statements allow you to execute blocks
   of code depending on the value of a logical expression
- The basic if statement:
  - begins with the keyword =if=
  - identifies a condition for evaluation, and
  - ends with a colon (=:=)
- An example of an =if= statement is given below
#+begin_src python :results output :exports both
x = True # define a boolean (bool) variable

if x:
   # This doesn't print if x is set to False
   print('The condition x evaluates as True.')
   # We could include other commands in the IF block
   # We only use one command here
   # Additional commands must have the same indentation
   #   as the print() command

print('This is independent of the IF statement.')
#+end_src

#+RESULTS:
: The condition x evaluates as True.
: This is independent of the IF statement.

- We now repeat the =if= statement, but this time with a
  =False= condition:
#+begin_src python :results output :exports both
x = False # define a boolean (bool) variable

if x:
   # This doesn't print if x is set to False
   print('The condition x evaluates as True.')

print('This is independent of the IF statement.')
#+end_src

#+RESULTS:
: This is independent of the IF statement.
- Here, since =if= condition, =x=, is evaluated as =False=
  (we set it to False in line 1), the =print()= command conditioned
  upon the value of =x= is never executed
- Commands subordinate to an =if= statement follow it and have a deeper
  indentation than the =if= statement itself
  - The first line of code with the same indentation as the =if= statement
    is conisdered by Python to be outside of the =if= statement.
  - Unlike other languages, the Python =if= statement is not terminated
    using an end statement or a closing deliminter, but rather by returning
    to the level of indentation of the =if= statement itself.
** =if=-=else= Statements

