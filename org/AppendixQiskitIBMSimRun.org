# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+startup: overview indent auto-fill
#+export_file_name: ./html/AppendixQiskitIBMSimRun.html
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-bigblow.setup

#+title: Qiskit + IBM: Simulation and Calculation
#+author: Dr. E.P. Blair


* Notebook Setup                                                   :noexport:

The following is helpful if we want to have =org-mode= sessions linking
multiple code blocks /and/ we are using =direnv=.

#+begin_src emacs-lisp :eval never-export
(setq-local org-babel-python-command (expand-file-name "../.direnv/python-3.11/bin/python3"))
#+end_src

#+RESULTS:
: /Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/bin/python3


#+begin_src python :results output :eval never-export
import sys

print(sys.executable)
#+end_src

#+RESULTS:
: /Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/bin/python3




* Overview
:PROPERTIES:
:CUSTOM_ID: qinfoOverview
:END:
#+include: "./back-to-index.org"

- This page focuses on quantum computing simulations or job submissions on IBM
  hardware
  - There are several ways to simulate quantum computations
    - Statevector simulations
    - Using SamplerV2 or EstimatorV2

The general work-flow is to:
1. Create a quantum circuit 
2. Decide whether to simulate it or run it on quantum hardware
   1. Typically, we simulate it first
   2. We want our simulation syntax to match as closely as possible to the
      syntax of job submission.

* The =quantum_info= Module
:PROPERTIES:
:CUSTOM_ID: qinfoModule
:END:
#+include: "./back-to-index.org"

** Overview
- The =quantum_info= module is built into =qiskit= and provides some basic
  simulations
  - This is useful when we want to understand the quantum properties of the
    output of a circuit
  - It provides:
    - =Statevector= simulations
** Make a Quantum Circuit

In a Jupyter notebook we could make a cell like this:
#+name: qinfoCircuit
#+begin_src python :results output :session qinfo :exports code
  from qiskit import QuantumCircuit
  import qiskit.quantum_info as qi

  qc = QuantumCircuit(2)
  qc.x(0) # add a NOT gate to qubit 0
  qc.h([0,1]) # add a H to both qubits

  # In a Jupyter notebook, you can uncomment "qc.draw()"
  # to see your circuit
  # qc.draw()
#+end_src

#+RESULTS: qinfoCircuit

#+begin_src python :results output :session qinfo :exports none
  import os
  from pathlib import Path

  imgdir = os.path.join('html', 'img')
  Path(imgdir).mkdir( exist_ok=True, parents=True )
  fname = os.path.join(imgdir, 'xh2.png')
  qc.draw('mpl', filename=fname)

  print( f'[[./{fname[5:]}]]' )
#+end_src

#+RESULTS:
: [[./img/xh2.png]]

In Jupyter Lab, your result may be displayed automatically and look like Figure
[[fig:basicQuantumCircuit]].
#+name: fig:basicQuantumCircuit
#+attr_html: :width 300px
#+caption: A simple =qiskit= quantum circuit.
[[./img/xh2.png]]
** Get an Output =Statevector()= Object
We can then obtain the circuit output in =Statevector= form:

#+begin_src python :results output :session qinfo :exports both
  ψ = qi.Statevector( qc )

  print( ψ )

  # In a Jupyter Lab notebook, you can see the result using this:
  # ψ.draw()
#+end_src

#+RESULTS:
: Statevector([ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],
:             dims=(2, 2))

In a Jupyter notebook, you can comment ~print( ψ )~ and uncomment ~ψ.draw()~
to  see a result that's nicer than the one shown here. It may look like this:

#+name: eq:psiOutput
\begin{equation}
\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle-
\frac{1}{2} |11\rangle
\end{equation}

#+begin_src python :results output :session qinfo :exports none
  print( ψ.draw( output='latex_source' ) )
#+end_src

#+RESULTS:
: \frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle- \frac{1}{2} |11\rangle
: test

** Measurement Probabilities

Once we have a ~Statevector~ object, we can use it to see the probabilities of
measurement, which are the modulii squared of the coefficients:

#+begin_src python :results output :session qinfo :exports both
  print( psi.probabilities() )
#+end_src

#+RESULTS:
: [0.25 0.25 0.25 0.25]

In this case, there are four outcomes, each with a 1/4 probability of
occurring.

** Simulated Experiments

Generally, a quantum computing experiment requires establishing a circuit and
performing measurements many times. Each repetition is a *shot* or a *trial*,
and a collection of shots is an *ensemble* of measurements.

*** Measurement Outcomes for Each Shot
We can use ~ψ~ to simulate circuit measurements using the ~sample_memory()~
method. We specify a number of shots (trials), and we get a histogram of
samples, that is, the number of times each outcome was measured.

#+begin_src python :results output :session qinfo :exports both
  samples = ψ.sample_memory( shots = 10 )

  # This lists the outcomes measured for each of the 10 shots
  print(samples)
#+end_src

#+RESULTS:
: ['11' '01' '10' '10' '01' '11' '01' '11' '01' '11']

*** Cumulative Results over an Ensemble
- If we don't care about each shot, but rather, we care more about aggregate
  data, we can use ~sample_counts()~
  - For a given number of shots, it simulates the set of measurements, returning
    a frequency (number of occurrences) for each outcome measured.
#+begin_src python :results output :session qinfo :exports both
  counts = ψ.sample_counts( shots = 1024 )
  print(counts)
#+end_src

#+RESULTS:
: {np.str_('00'): np.int64(266), np.str_('01'): np.int64(256), np.str_('10'): np.int64(244), np.str_('11'): np.int64(258)}

The counts can be visualized in a histogram. In a Jupyter notebook, use the
following, but uncomment the ~plot_histogram()~ command:
#+begin_src python :results output :session qinfo :exports both
  from qiskit.visualization import plot_histogram
  # Uncomment in Jupyter to see histogram
  # plot_histogram( counts )
#+end_src

#+RESULTS:

#+begin_src python :results output :session qinfo :exports none
  fname = os.path.join( 'html', 'img', 'basic_hist.png')
  plot_histogram( counts, filename=fname )

  print(f'[[./{fname[5:]}]]')
#+end_src

#+RESULTS:
: [[./img/basic_hist.png]]

#+name: fig:basicStatevectorCountsHist
#+attr_html: :width 480px
#+caption: This is a histogram of simulated measurents based on a =Statevector= output from a quantum circuit.
[[./img/basic_hist.png]]

State vector simulations get us a state vector, and we are using that state
vector object to simulate measurements.

*** Expectation Values

State vector simulations also allow us to get expectation values, as defined in
Equation [[eq:ExpectationValue]]
#+name: eq:ExpectationValue
\begin{equation}
\left\langle \mathbf{O} \right\rangle = \left\langle \psi \left| \mathbf{O} \right| \psi  \right\rangle 
\end{equation}

First, we form an operator:
#+begin_src python :results output :session qinfo :exports both
  O = qi.SparsePauliOp(['ZZ', 'XX', 'II'], [0.2, -0.3, 0.4])

  # Uncomment this in Jupyter
  # display(O.to_operator())

  # Comment/omit this in Jupyter
  print(O.to_operator())

#+end_src

#+RESULTS:
: Operator([[ 0.6+0.j,  0. +0.j,  0. +0.j, -0.3+0.j],
:           [ 0. +0.j,  0.2+0.j, -0.3+0.j,  0. +0.j],
:           [ 0. +0.j, -0.3+0.j,  0.2+0.j,  0. +0.j],
:           [-0.3+0.j,  0. +0.j,  0. +0.j,  0.6+0.j]],
:          input_dims=(2, 2), output_dims=(2, 2))

Next, we supply $\mathbf{O}$ to the ~ψ~ (a =Statevector= object) in its
=expectation_value()= method:
#+begin_src python :results output :session qinfo :exports both
  O_exp = ψ.expectation_value( O )

  print(O_exp)
#+end_src

#+RESULTS:
: (0.6999999999999997+0j)

*** Bloch Vectors

We can ask Python to draw the Bloch vector for ψ:
#+begin_src python :results output :session qinfo :exports both
  # Use this in Jupyter:
  # ψ.draw('bloch')

  # Comment this out or omit the following in Jupyter
  p
  fname = os.join('html', 'img', 'basicBlochVect.png')
  ψ.draw('bloch', filename=fname)
  import matplotlib.pyplot as plt
  plt.savefig( fname )
  print(f'[[./{fname[5:]}]]')
#+end_src

#+RESULTS:


#+begin_src python :results output :session qinfo :exports none
  from qiskit.visualization import plot_bloch_multivector
  import matplotlib.pyplot as plt

  fname = os.path.join('html', 'img', 'basicBlochVect.png')

  # print(fname)
  # Plot the Bloch vector of the state
  fig = plot_bloch_multivector(ψ)

  fig.set_size_inches(5,6)

  plt.tight_layout()
  # Save the plot to a file
  fig.savefig( fname )

  # plt.savefig( fname )
  print(f'[[./{fname[5:]}]]')

#+end_src

#+RESULTS:
: [[./img/basicBlochVect.png]]
: test

#+begin_src shell
  ls *.png
#+end_src

#+RESULTS:

#+attr_html: :width 480px
#+name: fig:BlochVectEx
#+caption: Bloch vectors for the two qubits in ψ.
[[./img/basicBlochVect.png]]


*** Density Matrices

Similar to a =Statevector=, we can also get a =DensityMarix= from a
circuit. Recall that a density matrix \(\rho\) may be obtained from a state
vector:
\begin{equation}
\rho = \ket{\psi} \bra{\psi}
\end{equation}

**** Matrix Output
#+begin_src python :results output :session qinfo :exports both
  ρ = qi.DensityMatrix( qc )
  print(ρ)

  # In Jupyter Lab, you may use
  #display( ρ )
#+end_src

#+RESULTS:
: DensityMatrix([[ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
:                [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j],
:                [ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
:                [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j]],
:               dims=(2, 2))


#+begin_src python :results output :session qinfo :exports none
  print(ρ.draw( output='latex_source'))

  # In Jupyter Lab, you may use
  #display( ρ )
#+end_src

#+RESULTS:
: 
: 
: \begin{bmatrix}
: \frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
:  - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
:  \frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
:  - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
:  \end{bmatrix}

In Jupyter, you may see output like this from the =display()= command:
\begin{equation}
\begin{bmatrix}
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\end{bmatrix}
\end{equation}


In Jupyter, we can plot the elements of the density matrix:
#+begin_src python :results output :session qinfo :exports none :eval never
  # Draw the "cityscape" plot
  ρ.draw('city')
#+end_src

**** The City Plot

#+begin_src python :results output :session qinfo :exports none
  # Draw the "cityscape" plot
  fig = ρ.draw('city')

  fname = os.path.join( 'html', 'img', 'dmCityScape.png')
  # Save the plot as an image file
  fig.savefig(fname, dpi=300)

  print(f'[[./{fname[5:]}]]')
#+end_src

#+RESULTS:
: [[./img/dmCityScape.png]]

#+attr_html: :width 600px
[[./img/dmCityScape.png]]

**** Partial Trace

Given a multi-qubit density matrix, we can get a reduced density matrix for any
subset of qubits.

#+begin_src python :results output :session qinfo :exports both
  ρ1 = qi.partial_trace( ρ, [0] )

  print(ρ1)
#+end_src

#+RESULTS:
: DensityMatrix([[0.5+0.j, 0.5+0.j],
:                [0.5+0.j, 0.5+0.j]],
:               dims=(2,))

** Conclusion
- The =quantum_info= module is useful for:
  - very basic simulations
  - exploring the quantum output of a circuit
- The =quantum_info= module does not handle circuit simulations that:
  - are too large
  - involve any measurement gates

* The =BasicSimulator= Class
:PROPERTIES:
:CUSTOM_ID: sec:BasicSimulator
:END:
#+include: "./back-to-index.org"

- We need the =BasicSimulator= class to perform simulations for circuits that
  include measurement gates
** Build a Circuit
- Following Diego Serrano's tutorial, I build a circuit which includes
  measurement gates
  - Start by importing required code
    #+begin_src python :results output :session basicsim :exports both
      from qiskit import QuantumCircuit
      from qiskit.providers.basic_provider import BasicSimulator

      simulator_basic = BasicSimulator()
    #+end_src

    #+RESULTS:

    - The main things we've accomplished in this code are:
      - We have imported the =BasicSimulator= class
      - We have created =simulator_basic= as a =BasicSimulator= object.
  - Build the circuit with two quantum bits and two classical bits
    #+begin_src  python :results output :session basicsim :exports both
      qc = QuantumCircuit(2,2) # two qubits, and two classical bits

      qc.h(1) # apply a H gate to qubit 1
      qc.measure(1, 1) # measure qubit 1, record its bit to classical bit 1
      qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1 
      qc.measure(0, 0) # measure qubit 0, record its result to classical bit 0
      qc.draw(reverse_bits=True)
    #+end_src
    
    #+RESULTS:
    : /var/folders/88/d26ncvp97zg50164_cmmlyf511m8tn/T/babel-bmQJhU/python-AGP0D6:5: DeprecationWarning: The method ``qiskit.circuit.instructionset.InstructionSet.c_if()`` is deprecated as of qiskit 1.3.0. It will be removed in 2.0.0.
    :   qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1


    #+begin_src  python :results output :session basicsim :exports none
      import os
      from pathlib import Path

      fname = os.path.join('html', 'img', 'QCwithMeas.png')
      qc.draw(reverse_bits=True, filename = fname)

      print(f"[[./{fname[5:]}]]")
    #+end_src

    #+RESULTS:
    : [[./img/QCwithMeas.png]]

    #+name: fig:cktWithMeas
    #+attr_html: :width 525px
    #+caption: This circuit has two qubits and two classical bits. The classical bits are required for measuremnt.
    [[./img/QCwithMeas.png]]

    In a Jupyter notebook, the output of =qc.draw()= will resemble Figure
    [[fig:cktWithMeas]].
** Helper Function: =orgfig=                                      :noexport:
#+begin_src  python :results output :session basicsim :exports both
  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')
#+end_src

#+RESULTS:

** Simulating the Circuit
- To run the circuit, we use the BasicSimulator.run() method, and we supply the
  desired circuit, and we can specify the number of shots for our simulation:
  #+begin_src  python :results output :session basicsim :exports both
    # The .run() method performs the simulation, and and the run is
    # saved as job
    job = simulator_basic.run( qc, shots=1024 )

    print(type(job))
  #+end_src

  #+RESULTS:
  : <class 'qiskit.providers.basic_provider.basic_provider_job.BasicProviderJob'>
  - This =run()= method returns a =BasicProviderJob= object
    - This has a =result()= method that returns a =Result()= object contains our
      simulation results

** Getting the Results
- We save the results as =results=:
  #+begin_src  python :results output :session basicsim :exports both
    results = job.result()

    print(type(results))

    print(results)
  #+end_src  

  #+RESULTS:
  : <class 'qiskit.result.result.Result'>
  : Result(backend_name='basic_simulator', backend_version='0.1', qobj_id='5fa46fbe-251b-4733-b29c-6cd05bb52024', job_id='5abb07aa-3a06-4ff7-94e5-a27a9e678d07', success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 519, '0x3': 505}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['c', 0], ['c', 1]], memory_slots=2, creg_sizes=[['c', 2]], name='circuit-160', global_phase=0.0, metadata={}), status=DONE, name='circuit-160', seed_simulator=np.int32(1719395928), time_taken=0.07600593566894531)], date=None, status=COMPLETED, header=QobjHeader(backend_name='basic_simulator', backend_version='0.1'), time_taken=0.0760350227355957)

- The results object has lots of information about our quantum experiment
  simulation

*** Simulation Counts 
- A =get_counts()= method helps us retrieve the outcomes and their frequencies.
  #+begin_src  python :results output :session basicsim :exports both
    counts = results.get_counts()

    print(counts)
  #+end_src  

  #+RESULTS:
  : {'00': 519, '11': 505}
  
*** Visualizing the Results
- We can plot the measurement results in two ways:
  - as a histogram (counts) using =plot_histogram()=, or
  - as a probability distribution using =plot_distribution()=.
#+begin_src  python :results output :session basicsim :exports both
  from qiskit.visualization import plot_histogram, plot_distribution

  display( plot_distribution( counts ) )

  display( plot_histogram( counts ) )
#+end_src  

#+RESULTS:

#+begin_src  python :results output :session basicsim :exports none
  fname = os.path.join('html', 'img', 'basicSimHist.png')
  plot_histogram( counts, filename=fname )
  print(f'\n[[./{fname[5:]}]]')

  fname = os.path.join('html', 'img', 'basicSimPD.png')
  plot_distribution( counts, filename=fname )
  print(f'\n[[./{fname[5:]}]]')
#+end_src  

#+RESULTS:
: 
: [[./img/basicSimHist.png]]
: 
: [[./img/basicSimPD.png]]

#+name: fig:BasicSimHist
#+attr_html: :width 600px
#+caption: A histogram from the results of a =BasicSimulator.run()= simulation.
[[./img/basicSimHist.png]]

#+name: fig:BasicSimHist
#+attr_html: :width 600px
#+caption: A quasi-probability distribution from the results of a =BasicSimulator.run()= simulation. Quasiprobabilities are not actual probabilities, but rather estimates of probabilites obtained by dividing the number of occurrences of an event by the total number of experiments (shots).
[[./img/basicSimPD.png]]

*** Inspecting Results from Individual Measurements
- We can see the results of individual measurements if we use the =get_memory()= method for a =Results= object
  - This requires using the ~memory~ keyword with a value of ~True~ in the
    ~run()~ method for our basic simulator
- Here, we do this with a fewer number of shots so that we can avoid
  overwhelming ourselves with numerous results
#+begin_src  python :results output :session basicsim :exports both
  small_job = simulator_basic.run( qc, shots=8, memory=True)
  small_result = small_job.result()
  samples = small_result.get_memory()

  print(samples)
#+end_src    

#+RESULTS:
: ['00', '00', '00', '00', '11', '11', '11', '00']

** Handling Complex Circuits
- The basic simulator cannot handle more complex circuits readily, such as the QFT circuit
- To handle complex circuits, we must first transpile our circuit.
#+begin_src  python :results output :session basicsim :exports both
  from qiskit.circuit.library import QFT

  qc = QuantumCircuit(3, 3) # 3 qubits, 3 classical bits
  qc.append( QFT(3), range(3) )
  qc.measure( range(3), range(3) )

  qc.draw()
#+end_src    

#+RESULTS:

#+begin_src  python :results output :session basicsim :exports none
  fname = os.path.join('html', 'img', 'BasicSimQFT.png')
  qc.draw( filename = fname )

  orgfig( fname[5:] )

#+end_src    

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/BasicSimQFT.png]]

#+name: fig:BasicQFTCircuit
#+attr_html: :width 480px
#+caption: This is a more complex circuit including a QFT. =BasicSimulator= cannot handle this unless we first transpile it.
[[./img/BasicSimQFT.png]]

*** Transpilation

- Circuits may be composed of gates of various types
- Some gates may not exist natively on a particular quantum processing unit
  (QPU), but may be implemented using the available gates on the QPU
  - The set of available gates is often called the instruction set architecture
    (ISA)
- To transpile a circuit is to represent it in the ISA of a particular machine
- In this case, we transpile the QFT into gates available within the
  =BasicSimulator= class.

#+name: lst:transpileQFT
#+caption: This code transpiles the circuit of Figure [[fig:BasicQFTCircuit]]
#+begin_src python :results output :session basicsim :exports both
  from qiskit import transpile

  qc_trans = transpile( qc, backend=simulator_basic)

  qc_trans.draw()

#+end_src

#+RESULTS:

#+begin_src  python :results output :session basicsim :exports none
  fname = os.path.join('html', 'img', 'BasicSimQFTtrans.png')
  qc_trans.draw( filename = fname )

  orgfig( fname[5:] )
#+end_src    

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/BasicSimQFTtrans.png]]

Jupyter output for Listing will resemble Figure [[fig:QFTtranspiled]]
#+name: fig:QFTtranspiled
#+attr_html: :width 640px
#+caption: This is a transpiled version of the circuit from Figure [[fig:BasicQFTCircuit]]
[[./img/BasicSimQFTtrans.png]]

** Conclusion
- The =BasicSimulator()= class is useful when we simulate a job where we need to
  find counts or samples of a circuit with mid-circuit measurements
- The =BasicSimulator()= class should not be used for:
  - large circuits with many qubits or many gates
  - circuits where a coherent state is desired (state vector or density matrix)
  - noisy simulations
* The Qiskit =AerSimulator=
:PROPERTIES:
:CUSTOM_ID: sec:QiskitAerSimulator
:END:
#+include: "./back-to-index.org"

** Overview

- The Qiskit Aer AerSimulator class can be used to simulate complex circuits with mid-circuit measurements
- We can obtain unitary results from these simulations.
** Helper Function: =orgfig=                                      :noexport:
#+begin_src  python :results output :session aersim :exports both
  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')
#+end_src

#+RESULTS:

** Imports

- We begin by importing the required packages
  - This introduces the =qiskit_aer= package and the =AerSimulator= class
#+begin_src  python :results output :session aersim :exports both
  from qiskit import QuantumCircuit, transpile
  from qiskit.quantum_info import Statevector
  from qiskit.providers.basic_provider import BasicSimulator
  from qiskit_aer import AerSimulator

  simulator_basic = BasicSimulator()
  simulator_aer = AerSimulator()
#+end_src

#+RESULTS:


** Build a Circuit

- We define a circuit in Listing [[lst:AerSimCkt]]
  #+name: lst:AerSimCkt
  #+begin_src python :results output :session aersim :exports both
    qc = QuantumCircuit(2,2) # two qubits, and two classical bits

    qc.h(1) # apply a H gate to qubit 1
    qc.measure(1, 0) # measure qubit 1, record its bit to classical bit 0
    qc.h(0).c_if(0,1) # apply a X gate to qubit 0 if classical bit 1 is 1
    qc.save_statevector()

    qc.draw(reverse_bits=True)
  #+end_src

  #+RESULTS: lst:AerSimCkt
    
  #+name: lst:AerSimCktOrgExport
  #+begin_src python :results output :session aersim :exports none
    import os
    fname = os.path.join('html', 'img', 'CktAerSim.png')
    qc.draw(reverse_bits=True, filename=fname)

    orgfig( fname[5:] )
  #+end_src

  #+RESULTS: lst:AerSimCktOrgExport
  : 
  : #+name: fig:defaultName
  : #+attr_html: :width 480px
  : #+caption: Default caption.
  : [[./img/CktAerSim.png]]

  #+name: fig:defaultName
  #+attr_html: :width 480px
  #+caption: This is a two-qubit circuit with a measurement in the middle of the circuit.
  [[./img/CktAerSim.png]]

  - Here, the =save_statevector()= method defines a point in the circuit at
    which we wish to knkow the state vector
** Run the =AerSimulator()=

- We first transpile the circuit so it is suitable for our simulator, and then we run it:
  #+begin_src python :results output :session aersim :exports both
    qc_aer = transpile(qc, backend=simulator_aer)
 
    result = simulator_aer.run(qc_aer).result()
 
    ψ = result.get_statevector()
    ψ # show the state vector in Jupyter Lab
  #+end_src

  #+RESULTS:

  #+begin_src python :results output :session aersim :exports none
    print( ψ.draw(output='latex_source') ) # show the state vector in Jupyter Lab
  #+end_src

  #+RESULTS:
  : \frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle

  \begin{equation}
  \frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle
  \end{equation}
** Example 2: Circuit with Statevector in Middle of Circuit
- Now, we provide an example where the state vector is saved from a point prior to the end of the circuit.
  #+begin_src python :results output :session aersim :exports both
    qc = QuantumCircuit(4)
    qc.h(3)
    qc.cx(3,2)
    qc.save_statevector()
    qc.cx(3,1)
    qc.cx(3,0)
    qc.measure_all()

    qc.draw(reverse_bits=True)
  #+end_src

  #+begin_src python :results output :session aersim :exports none
    fname = os.path.join( 'html', 'img', 'AerSimMultiStatevectCkt.png')
    qc.draw(reverse_bits=True, filename=fname)

    orgfig( fname[5:] )
  #+end_src

  #+RESULTS:
  : 
  : #+name: fig:defaultName
  : #+attr_html: :width 480px
  : #+caption: Default caption.
  : [[./img/AerSimMultiStatevectCkt.png]]

  #+name: fig:defaultName
  #+attr_html: :width 640px
  #+caption: This circuit saves a =Statevector= in the middle of the calculation and just prior to measurement.
  [[./img/AerSimMultiStatevectCkt.png]]

*** Transpile and Run the Circuit
- Next, we transpile and run the circuit:
  #+begin_src python :results output :session aersim :exports both
    qc_aer = transpile(qc, backend=simulator_aer)

    result = simulator_aer.run(qc_aer).result()
 
    ψ = result.get_statevector()
    ψ
  #+end_src

  #+RESULTS:

  #+begin_src python :results output :session aersim :exports none
    print(ψ.draw(output='latex_source'))
  #+end_src

  #+RESULTS:
  : \frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle

  \begin{equation}
  \frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle
  \end{equation}

** Efficient Simulation
- Portions of the =AerSimulator= code are compiled to =C=
  - This allows faster and more efficient simulations, which enables simulations
    of larger and more complex circuits. 

*** Build a Circuit
#+begin_src python :results output :session aersim :exports both
  n = 24
  qc = QuantumCircuit(n)
  qc.h(n-1)

  for i in range(n-1, 0, -1):
      qc.cx(i,i-1)

  qc.measure_all()

  if n < 16:
      display(qc.draw(reverse_bits=True))
  else:
      print('Suppressed display of large circuit.')
#+end_src

#+RESULTS:
: Suppressed display of large circuit.

*** Run and Time the Circuit: =BasicSimulator= vs =AerSimulator=

**** BasicSimulator
- In the following code, I simulate and time the circuit
- In Jupyter Lab, the time to run a cell can be obtained by adding ~%%time~ at
  the top of the cell.
- These notes are not written in Jupyter Lab, so I use the =time= module
  - Key instructions:
    - =import time= to access the module
    - Use =time.time()= to get the current time
    - The difference between two =time= objects can be used to calculate a time
      interval in seconds
      
#+begin_src python :results output :session aersim :exports both
  # In Jupyter Lab, uncomment the '%%time'
  # %%time

  # timing for non-Jupyter-Lab work
  import time
  start = time.time() # log start time - not required for Jupyter
  result = simulator_basic.run( qc, shots=1024 ).result()
  end = time.time() # log end time - not required for Jupyter
  time_basic_sim = end - start # not needed in Jupyter

  counts = result.get_counts()
  print(counts)

  # print() not needed if using %%time in Jupyter Lab
  print('Time elapsed: {0:6.3f} s'.format( time_basic_sim ))
#+end_src

#+RESULTS:
: {'000000000000000000000000': 531, '111111111111111111111111': 493}
: Time elapsed: 17.700 s

**** =AerSimulator=
- We now run and time the same circuit using the =AerSimulator=, and we see it
  is much faster for larger circuits
#+begin_src python :results output :session aersim :exports both
  # In Jupyter Lab, uncomment the '%%time'
  # %%time

  # timing for non-Jupyter-Lab work
  start = time.time() # log start time - not required for Jupyter
  result = simulator_aer.run( qc, shots=1024 ).result()
  end = time.time() # log end time - not required for Jupyter
  time_aer_sim = end - start # not needed in Jupyter

  counts = result.get_counts()
  print(counts)

  # print() not needed if using %%time in Jupyter Lab
  print('Time elapsed: {0:6.3f} s'.format( time_aer_sim ))
#+end_src

#+RESULTS:
: {'111111111111111111111111': 537, '000000000000000000000000': 487}
: Time elapsed:  0.025 s

** Simulation Methods
- Qiskit Aer supports different types of simulation, accessible through the
  =method= keyword argument to the =run()= command.
  - The default is =method='statevector'=
    - The limit here is 24 qubits
  - Other methods include ='matrix_product_state'=
*** Build a Large Circuit

#+begin_src python :results output :session aersim :exports both
  n = 50
  qc = QuantumCircuit(n)
  qc.h(n-1)

  for i in range(n-1, 0, -1):
      qc.cx(i,i-1)

  qc.measure_all()

  if n < 16:
      display(qc.draw(reverse_bits=True))
  else:
      print('Suppressed display of large circuit.')
#+end_src

#+RESULTS:
: Suppressed display of large circuit.

*** Run and Time the Simulation

#+begin_src python :results output :session aersim :exports both
  # In Jupyter Lab, uncomment the '%%time'
  # %%time

  # timing for non-Jupyter-Lab work
  start = time.time() # log start time - not required for Jupyter
  result = simulator_aer.run( qc, shots=1024, method='matrix_product_state' ).result()
  end = time.time() # log end time - not required for Jupyter
  time_aer_sim = end - start # not needed in Jupyter

  counts = result.get_counts()
  print(counts)

  # print() not needed if using %%time in Jupyter Lab
  print('Time elapsed: {0:6.3f} s'.format( time_aer_sim ))
#+end_src

#+RESULTS:
: {'11111111111111111111111111111111111111111111111111': 492, '00000000000000000000000000000000000000000000000000': 532}
: Time elapsed:  0.081 s

** Noisy Simulation

*** Build a Circuit
#+begin_src python :results output :session aersim :exports both
  qc = QuantumCircuit(2,2)
  qc.h(1)
  qc.cx(1,0)
  qc.measure([1,0],[1,0])

  qc.draw()
#+end_src

#+RESULTS:

#+begin_src python :results output :session aersim :exports none
  fname = os.path.join( 'html', 'img', 'noisyCktExample.png')

  qc.draw(filename=fname)

  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/noisyCktExample.png]]

#+name: fig:cktAerSimNoisy
#+attr_html: :width 480px
#+caption: This is a small circuit for noisy simulation using the =AerSimulator=.
[[./img/noisyCktExample.png]]

*** Ideal Result

#+begin_src python :results output :session aersim :exports both
  # This will throw an error for n > 25 using method='statevector'
  qc_aer = transpile( qc, backend=simulator_aer )
  result_ideal = simulator_aer.run( qc_aer, shots=1024 ).result()
  counts_ideal = result_ideal.get_counts()
  print(counts_ideal)
#+end_src

#+RESULTS:
: {'11': 520, '00': 504}

*** Noisy Result

#+begin_src python :results output :session aersim :exports both
  from qiskit_aer import noise

  prob = 0.1
  error = noise.depolarizing_error( prob, 2 )

  noise_model = noise.NoiseModel()
  noise_model.add_all_qubit_quantum_error( error, ['cx'])
  basis_gates = noise_model.basis_gates

  result_noisy = simulator_aer.run(qc,
                                  shots=1024,
                                  noise_model=noise_model,
                                  basis_gates=basis_gates).result()

  counts_noisy = result_noisy.get_counts()
#+end_src

#+RESULTS:

*** Compare Ideal Result and Noisy Result

#+begin_src python :results output :session aersim :exports both
  from qiskit.visualization import plot_histogram, plot_distribution

  # In Jupyter Lab, uncomment this to see the compared distributions
  # plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )
#+end_src

#+RESULTS:

#+begin_src python :results output :session aersim :exports none
  fig = plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )

  fname = os.path.join('html', 'img', 'AerSimIdealvsNoisy.png')

  fig.savefig( fname )

  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/AerSimIdealvsNoisy.png]]

#+name: fig:IdealvNoisyAerSim
#+attr_html: :width 640px
#+caption: An ideal =AerSimulator= result is compared to a noisy result.
[[./img/AerSimIdealvsNoisy.png]]

** Summary
The ~AerSimulator()~ is useful when we want to:
1. Find counts/samples of large circuits (simulators are efficient)
2. Find state vector/density matrix of circuits with measurements
3. Simulate circuits with noise
   
The AerSimulator() results do not match the output format of Qiskit IBM runtime
(the quantum hardware).

Qiskit Aer has its own sampler/estimator, which provide a closer match to the
inputs and outputs of the hardware, but these are being deprecated.

In the next section, we explore [[https://docs.quantum.ibm.com/api/qiskit/primitives][primitives]], which are used
in Qiskit IBM runtime.

* Qiskit Primitives

** Overview

- The interface for the various simulators (BasicSimulator, AerSimulator) were
  identical to the Qiskit IBM Provider interface to the quantum hardware
- The backend was an abstraction for something that was either simulator or an
  actual quantum processor.
- Primitives abstract the interface between users and backends
- There are two available primitives:
  - Sampler - this samples the output state of a circuit
  - Estimator - this stimates expectation values of a state with respect to
    observables
- Qiskit, Qiskit Aer, and Qiskit IBM Runtime each provide different primitives.
- Diego recommends starting with the version 2 primitives, which are compatible
  with the current hardware:

- Qiskit
  - StatevectorSampler
  - StatevectorEstimator
- Qiskit Aer (none or being deprecated)
- Qiskit IBM Runtime
  - SamplerV2
  - EstimatorV2

** Primitives
Qiskit primitives are computational building blocks used in larger applications that require quantum resources to efficiently produce outputs. The inputs to a primitive consists of primitive unified blocs (PUBs).

There are two types of primitives:
1. ~EstimatorV2~
2. ~SamplerV2~

The workflow is as before: build a circuit, and then simulate it (or run it on
hardware).

*** Helper Function: =orgfig=                                    :noexport:
#+begin_src  python :results output :session qisprim :exports both
  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')
#+end_src

#+RESULTS:

*** Imports
#+begin_src python :results output :session qisprim :exports both
  from qiskit import QuantumCircuit
  from qiskit.primitives import StatevectorSampler, StatevectorEstimator
  from qiskit.providers.basic_provider import BasicSimulator
#+end_src

#+RESULTS:

*** Build a Circuit

#+begin_src python :results output :session qisprim :exports both
  qc = QuantumCircuit(2, 2)
  qc.h(1)
  qc.cx(1,0)
  qc.measure([1,0],[1,0]) # measurement register: c
  qc.draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session qisprim :exports none
  import os
  fname = os.path.join('html', 'img', 'qisprimckt01.png')
  qc.draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/qisprimckt01.png]]

#+name: fig:qisprimckt01
#+attr_html: :width 480px
#+caption: This is a circuit for use with the =qiskit= primitives.
[[./img/qisprimckt01.png]]

*** Run Simulations

#+begin_src python :results output :session qisprim :exports both
  simulator = BasicSimulator()
  sampler = StatevectorSampler()
#+end_src

#+RESULTS:

**** Basic Simulation

#+begin_src python :results output :session qisprim :exports both
  # No transpilation is needed for this simple circuit
  job_simulator = simulator.run( qc, shots=1024)
#+end_src

#+RESULTS:

**** Simulation using a Sampler

- The syntax for a sampler simulation is somewhat different than that of the
  =BasicSimulator= class.
  - Here, inputs are in the form of primitive-unified blocs (PUBS)
#+begin_src python :results output :session qisprim :exports both
  job_sampler = sampler.run( [qc], shots=1024)
#+end_src

#+RESULTS:

*** Extracting Results

- We extract results in the same way from both the simulator and the sampler:

#+begin_src python :results output :session qisprim :exports both
  result_simulator = job_simulator.result()
  result_sampler = job_sampler.result()
#+end_src

#+RESULTS:

***** Simulator Counts

- We can retrieve counts from the simulator result as before, using the
  ~get_counts()~ method:
  #+begin_src python :results output :session qisprim :exports both
    counts_simulator = result_simulator.get_counts()
    print( counts_simulator )
  #+end_src

  #+RESULTS:
  : {'00': 517, '11': 507}


***** Sampler Counts
- Getting counts from the sampler is a bit more involved. Let's eamine the
  results we obtained:
  #+begin_src python :results output :session qisprim :exports both
    print(type(result_sampler))
    print(result_sampler)
  #+end_src

  #+RESULTS:
  : <class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'>
  : PrimitiveResult([SamplerPubResult(data=DataBin(c=BitArray(<shape=(), num_shots=1024, num_bits=2>)), metadata={'shots': 1024, 'circuit_metadata': {}})], metadata={'version': 2})

  - The results from the sampler come as an object of class ~PubResult~
    object.
    - This class has a ~get_counts()~ method.
    - Since the input PUB for the sampler is a list, we must similarly index the
      result to get the result(s)  for a specific PUB item.
    - If we don't provide an index, get_counts() will
      aggregate the results, which may not be what we want.
- To get counts, we do the following:
- index the PUB result. Here, we call for the zeroth element.
- reference the data member data element, and reference the classical register name.
- use the ~get_counts()~ method.
  #+begin_src python :results output :session qisprim :exports both
    counts_sampler = result_sampler[0].data.c.get_counts()
    print(counts_sampler)
  #+end_src

  #+RESULTS:
  : {'00': 498, '11': 526}
** Example: A Parametrized Circuit

#+begin_src python :results output :session qisprim :exports both
  from qiskit import transpile
  from qiskit.circuit import Parameter
  from math import pi

  θ = Parameter('θ')

  qc2 = QuantumCircuit(2)
  qc2.rx(θ, 1) # assign a parameter for this rotation
  qc2.cx(1, 0)
  qc2.measure_all()
  qc2.draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session qisprim :exports none
  fname = os.path.join( 'html', 'img', 'prametrizedckt.png')
  qc2.draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/prametrizedckt.png]]

#+name: fig:parametrizedCkt
#+attr_html: :width 480px
#+caption: This circuit has a parameter θ.
[[./img/prametrizedckt.png]]


*** =BasicSimulator= Usage
Here, we make a list of circuits, each with a specific value of the parameter θ.
#+begin_src python :results output :session qisprim :exports both
  angles = [[pi/4], [pi/3], [pi/2]]

  circuits = []
  for angle in angles:
      qc_temp = qc2.assign_parameters({θ:angle[0]})
      circuits.append(qc_temp)
#+end_src

#+RESULTS:

We can draw the different circuits by indexing the list:
#+begin_src python :results output :session qisprim :exports both
  circuits[1].draw(reverse_bits=True)
#+end_src

#+begin_src python :results output :session qisprim :exports none
  fname = os.path.join( 'html', 'img', 'prametrizedckt_ex.png')
  circuits[1].draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/prametrizedckt_ex.png]]

#+name: fig:paramCktPrintFromList
#+attr_html: :width 480px
#+caption: We print a circuit from a list of circuits. Unlike the circuit of Fig. [[fig:parametrizedCkt]], this circuit has a specific value for θ.
[[./img/prametrizedckt_ex.png]]


**** Transpiling and Running

- The entire list of circuits can be transpiled in a single call to ~transpile()~
- The transpiled list can be called using one call to the =BasicSimulator.run()=
  method.

  #+begin_src python :results output :session qisprim :exports both
    # transpile the circuit list
    circuits_t = transpile( circuits, backend=simulator )

    result_simulator = simulator.run( circuits_t, shots=1024 ).result()
  #+end_src

  #+RESULTS:
- Let us inspect the results:
  #+begin_src python :results output :session qisprim :exports both
    print(result_simulator)
    print(type(result_simulator))
  #+end_src  

  #+RESULTS:
  : Result(backend_name='basic_simulator', backend_version='0.1', qobj_id='9c17273c-af8f-4d2b-a7e3-7d90eb58d151', job_id='606e8e8d-6bdf-4003-b99f-8686b7802c88', success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 875, '0x3': 149}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['meas', 0], ['meas', 1]], memory_slots=2, creg_sizes=[['meas', 2]], name='circuit-181', global_phase=0.0, metadata={}), status=DONE, name='circuit-181', seed_simulator=np.int32(784228274), time_taken=0.0013642311096191406), ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 780, '0x3': 244}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['meas', 0], ['meas', 1]], memory_slots=2, creg_sizes=[['meas', 2]], name='circuit-182', global_phase=0.0, metadata={}), status=DONE, name='circuit-182', seed_simulator=np.int32(282119695), time_taken=0.0021491050720214844), ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x3': 465, '0x0': 559}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['meas', 0], ['meas', 1]], memory_slots=2, creg_sizes=[['meas', 2]], name='circuit-183', global_phase=0.0, metadata={}), status=DONE, name='circuit-183', seed_simulator=np.int32(1213856026), time_taken=0.001672983169555664)], date=None, status=COMPLETED, header=QobjHeader(backend_name='basic_simulator', backend_version='0.1'), time_taken=0.0052187442779541016)
  : <class 'qiskit.result.result.Result'>
  - The result_simulator is a Result object with a method =get_counts()=.
- We provide an index to =get_counts()= for the corresponding circuit in
  =circuits_t=.
  #+begin_src python :results output :session qisprim :exports both
    counts_simulator = []

    for i, _ in enumerate(angles):
        result_temp = result_simulator.get_counts(i)
        counts_simulator.append(result_temp)

    print(counts_simulator)
  #+end_src  

  #+RESULTS:
  : [{'00': 875, '11': 149}, {'00': 780, '11': 244}, {'11': 465, '00': 559}]
*** =StatevectorSampler= Usage
- For a sampler, we pass a list of PUBs. This contains
  - the generic parametrized circuit, along with
  - the list of parameters
- This makes the =run()= command very simple.
#+begin_src python :results output :session qisprim :exports none
  result_sampler = sampler.run([(qc2, angles)], shots=1024).result()
#+end_src

#+RESULTS:
