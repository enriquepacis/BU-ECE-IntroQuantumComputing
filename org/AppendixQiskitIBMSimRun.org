# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+startup: overview indent auto-fill
#+export_file_name: ./html/AppendixQiskitIBMSimRun.html
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-bigblow.setup
#+PROPERTY: header-args :eval never-export

#+title: Qiskit + IBM: Simulation and Calculation
#+author: Dr. E.P. Blair


* Notebook Setup                                                   :noexport:

** Python Sessions

*** Set Python Environment
The following is helpful if we want to have =org-mode= sessions linking
multiple code blocks /and/ we are using =direnv=.

#+begin_src emacs-lisp :eval never-export
(setq-local org-babel-python-command (expand-file-name "~/anaconda3/envs/QC2025env/bin/python3"))
#+end_src

#+RESULTS:
: /Users/enrique_blair/anaconda3/envs/QC2025env/bin/python3


#+begin_src python :results output :eval never-export
  import sys, qiskit

  print(sys.executable)
  print(f'Python version: {sys.version}')


  print(f'Qiskit version: {qiskit.__version__}')
#+end_src

#+RESULTS:
: /Users/enrique_blair/anaconda3/envs/QC2025env/bin/python3
: Python version: 3.11.11 (main, Dec 11 2024, 10:25:04) [Clang 14.0.6 ]
: Qiskit version: 1.3.1


*** Show Session Errors(?)

#+begin_src emacs-lisp
  (advice-add #'org-babel-python-send-string 
              :override
              #'my/org-babel-python-send-string)

  (defun my/org-babel-python-send-string (session body)
    "Pass BODY to the Python process in SESSION.
  Return output."
    (with-current-buffer session
      (let* ((string-buffer "")
         (comint-output-filter-functions
          (cons (lambda (text) (setq string-buffer
                         (concat string-buffer text)))
            comint-output-filter-functions))
         (body (format "\
  try:
  %s
  except Exception as e:
      # These are the relevant lines to change. 
      print(e)
  finally:
      print('%s')"
               (org-babel-python--shift-right body 4)
               org-babel-python-eoe-indicator)))
        (let ((python-shell-buffer-name
           (org-babel-python-without-earmuffs session)))
      (python-shell-send-string body))
        ;; same as `python-shell-comint-end-of-output-p' in emacs-25.1+
        (while (not (and (python-shell-comint-end-of-output-p string-buffer)
                         (string-match
                  org-babel-python-eoe-indicator
                  string-buffer)))
      (accept-process-output (get-buffer-process (current-buffer))))
        (org-babel-chomp (substring string-buffer 0 (match-beginning 0))))))
#+end_src

#+RESULTS:
: my/org-babel-python-send-string

* Overview
:PROPERTIES:
:CUSTOM_ID: qinfoOverview
:END:
#+include: "./back-to-index.org"

- This page focuses on quantum computing simulations or job submissions on IBM
  hardware
  - There are several ways to simulate quantum computations
    - Statevector simulations
    - Using SamplerV2 or EstimatorV2

The general work-flow is to:
1. Create a quantum circuit 
2. Decide whether to simulate it or run it on quantum hardware
   1. Typically, we simulate it first
   2. We want our simulation syntax to match as closely as possible to the
      syntax of job submission.

* The =quantum_info= Module
:PROPERTIES:
:CUSTOM_ID: qinfoModule
:END:
#+include: "./back-to-index.org"

** Overview
- The =quantum_info= module is built into =qiskit= and provides some basic
  simulations
  - This is useful when we want to understand the quantum properties of the
    output of a circuit
  - It provides:
    - =Statevector= simulations
** Make a Quantum Circuit

In a Jupyter notebook we could make a cell like this:
#+name: qinfoCircuit
#+begin_src python :results output :session qinfo :exports code
  from qiskit import QuantumCircuit
  import qiskit.quantum_info as qi

  qc = QuantumCircuit(2)
  qc.x(0) # add a NOT gate to qubit 0
  qc.h([0,1]) # add a H to both qubits

  # In a Jupyter notebook, you can uncomment "qc.draw()"
  # to see your circuit
  # qc.draw()
  from datetime import datetime
  print(f'Calculation complete at {datetime.now()}')
#+end_src

#+RESULTS: qinfoCircuit
: Calculation complete at 2025-02-26 13:32:20.618530

#+begin_src python :results output :session qinfo :exports none
  import os
  from pathlib import Path

  imgdir = os.path.join('html', 'img')
  Path(imgdir).mkdir( exist_ok=True, parents=True )
  fname = os.path.join(imgdir, 'xh2.png')
  qc.draw('mpl', filename=fname)

  print( f'[[./{fname[5:]}]]' )

  print(f'Calculation complete at {datetime.now()}')
#+end_src

#+RESULTS:
: [[./img/xh2.png]]
: Calculation complete at 2025-02-26 13:32:26.009727

In Jupyter Lab, your result may be displayed automatically and look like Figure
[[fig:basicQuantumCircuit]].
#+name: fig:basicQuantumCircuit
#+attr_html: :width 300px
#+caption: A simple =qiskit= quantum circuit.
[[./img/xh2.png]]
** Get an Output =Statevector()= Object
We can then obtain the circuit output in =Statevector= form:

#+begin_src python :results output :session qinfo :exports both
  ψ = qi.Statevector( qc )

  print( ψ )

  # In a Jupyter Lab notebook, you can see the result using this:
  # ψ.draw()
#+end_src

#+RESULTS:
: Statevector([ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],
:             dims=(2, 2))

In a Jupyter notebook, you can comment ~print( ψ )~ and uncomment ~ψ.draw()~
to  see a result that's nicer than the one shown here. It may look like this:

#+name: eq:psiOutput
\begin{equation}
\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle-
\frac{1}{2} |11\rangle
\end{equation}

#+begin_src python :results output :session qinfo :exports none
  print( ψ.draw( output='latex_source' ) )

  print(f'\nCalculation complete at {datetime.now()}')
#+end_src

#+RESULTS:
: \frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle- \frac{1}{2} |11\rangle
: 
: Calculation complete at 2025-02-26 13:39:31.445217

** Measurement Probabilities

Once we have a ~Statevector~ object, we can use it to see the probabilities of
measurement, which are the modulii squared of the coefficients:

#+begin_src python :results output :session qinfo :exports both
  print( ψ.probabilities() )
#+end_src

#+RESULTS:
: [0.25 0.25 0.25 0.25]

In this case, there are four outcomes, each with a 1/4 probability of
occurring.

** Simulated Experiments

Generally, a quantum computing experiment requires establishing a circuit and
performing measurements many times. Each repetition is a *shot* or a *trial*,
and a collection of shots is an *ensemble* of measurements.

*** Measurement Outcomes for Each Shot
We can use ~ψ~ to simulate circuit measurements using the ~sample_memory()~
method. We specify a number of shots (trials), and we get a histogram of
samples, that is, the number of times each outcome was measured.

#+begin_src python :results output :session qinfo :exports both
  samples = ψ.sample_memory( shots = 10 )

  # This lists the outcomes measured for each of the 10 shots
  print(samples)

  print(f'\nCalculation complete at {datetime.now()}')
#+end_src

#+RESULTS:
: ['01' '01' '11' '01' '00' '00' '11' '01' '01' '00']
: 
: Calculation complete at 2025-02-26 13:41:02.891472

*** Cumulative Results over an Ensemble
- If we don't care about each shot, but rather, we care more about aggregate
  data, we can use ~sample_counts()~
  - For a given number of shots, it simulates the set of measurements, returning
    a frequency (number of occurrences) for each outcome measured.
#+begin_src python :results output :session qinfo :exports both
  counts = ψ.sample_counts( shots = 1024 )
  print(counts)

  print(f'\nCalculation complete at {datetime.now()}')
#+end_src

#+RESULTS:
: {np.str_('00'): np.int64(247), np.str_('01'): np.int64(253), np.str_('10'): np.int64(261), np.str_('11'): np.int64(263)}
: 
: Calculation complete at 2025-02-26 13:41:11.727536

The counts can be visualized in a histogram. In a Jupyter notebook, use the
following, but uncomment the ~plot_histogram()~ command:
#+begin_src python :results output :session qinfo :exports both
  from qiskit.visualization import plot_histogram
  # Uncomment in Jupyter to see histogram
  # plot_histogram( counts )
#+end_src

#+RESULTS:

#+begin_src python :results output :session qinfo :exports none
  fname = os.path.join( 'html', 'img', 'basic_hist.png')
  plot_histogram( counts, filename=fname )

  print(f'[[./{fname[5:]}]]')

  print(f'\nCalculation complete at {datetime.now()}')
#+end_src

#+RESULTS
: [[./img/basic_hist.png]]
: 
: Calculation complete at 2025-02-26 13:41:38.404511

#+name: fig:basicStatevectorCountsHist
#+attr_html: :width 480px
#+caption: This is a histogram of simulated measurents based on a =Statevector= output from a quantum circuit.
[[./img/basic_hist.png]]

State vector simulations get us a state vector, and we are using that state
vector object to simulate measurements.

*** Expectation Values

State vector simulations also allow us to get expectation values, as defined in
Equation [[eq:ExpectationValue]]
#+name: eq:ExpectationValue
\begin{equation}
\left\langle \mathbf{O} \right\rangle = \left\langle \psi \left| \mathbf{O} \right| \psi  \right\rangle 
\end{equation}

First, we form an operator:
#+begin_src python :results output :session qinfo :exports both
  O = qi.SparsePauliOp(['ZZ', 'XX', 'II'], [0.2, -0.3, 0.4])

  # Uncomment this in Jupyter
  # display(O.to_operator())

  # Comment/omit this in Jupyter
  print(O.to_operator())

#+end_src

#+RESULTS:
: Operator([[ 0.6+0.j,  0. +0.j,  0. +0.j, -0.3+0.j],
:           [ 0. +0.j,  0.2+0.j, -0.3+0.j,  0. +0.j],
:           [ 0. +0.j, -0.3+0.j,  0.2+0.j,  0. +0.j],
:           [-0.3+0.j,  0. +0.j,  0. +0.j,  0.6+0.j]],
:          input_dims=(2, 2), output_dims=(2, 2))

Next, we supply $\mathbf{O}$ to the ~ψ~ (a =Statevector= object) in its
=expectation_value()= method:
#+begin_src python :results output :session qinfo :exports both
  O_exp = ψ.expectation_value( O )

  print(O_exp)
#+end_src

#+RESULTS:
: (0.6999999999999997+0j)

*** Bloch Vectors

We can ask Python to draw the Bloch vector for ψ:
#+begin_src python :results output :session qinfo :exports both
  # Use this in Jupyter:
  # ψ.draw('bloch')

  # Comment this out or omit the following in Jupyter
  p
  fname = os.join('html', 'img', 'basicBlochVect.png')
  ψ.draw('bloch', filename=fname)
  import matplotlib.pyplot as plt
  plt.savefig( fname )
  print(f'[[./{fname[5:]}]]')
#+end_src

#+RESULTS:


#+begin_src python :results output :session qinfo :exports none
  from qiskit.visualization import plot_bloch_multivector
  import matplotlib.pyplot as plt

  fname = os.path.join('html', 'img', 'basicBlochVect.png')

  # print(fname)
  # Plot the Bloch vector of the state
  fig = plot_bloch_multivector(ψ)

  fig.set_size_inches(5,6)

  plt.tight_layout()
  # Save the plot to a file
  fig.savefig( fname )

  # plt.savefig( fname )
  print(f'[[./{fname[5:]}]]')

#+end_src

#+RESULTS:
: [[./img/basicBlochVect.png]]
: test

#+begin_src shell
  ls *.png
#+end_src

#+RESULTS:

#+attr_html: :width 480px
#+name: fig:BlochVectEx
#+caption: Bloch vectors for the two qubits in ψ.
[[./img/basicBlochVect.png]]


*** Density Matrices

Similar to a =Statevector=, we can also get a =DensityMarix= from a
circuit. Recall that a density matrix \(\rho\) may be obtained from a state
vector:
\begin{equation}
\rho = \ket{\psi} \bra{\psi}
\end{equation}

**** Matrix Output
#+begin_src python :results output :session qinfo :exports both
  ρ = qi.DensityMatrix( qc )
  print(ρ)

  # In Jupyter Lab, you may use
  #display( ρ )
#+end_src

#+RESULTS:
: DensityMatrix([[ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
:                [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j],
:                [ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
:                [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j]],
:               dims=(2, 2))


#+begin_src python :results output :session qinfo :exports none
  print(ρ.draw( output='latex_source'))

  # In Jupyter Lab, you may use
  #display( ρ )
#+end_src

#+RESULTS:
: 
: 
: \begin{bmatrix}
: \frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
:  - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
:  \frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
:  - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
:  \end{bmatrix}

In Jupyter, you may see output like this from the =display()= command:
\begin{equation}
\begin{bmatrix}
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\end{bmatrix}
\end{equation}



#+begin_src python :results output :session qinfo :exports none :eval never
  # Draw the "cityscape" plot
  ρ.draw('city')
#+end_src

**** The City Plot

In Jupyter, we can plot the elements of the density matrix:
#+begin_src python :results output :session qinfo :exports none
  # Draw the "cityscape" plot
  fig = ρ.draw('city')

  fname = os.path.join( 'html', 'img', 'dmCityScape.png')
  # Save the plot as an image file
  fig.savefig(fname, dpi=300)

  print(f'[[./{fname[5:]}]]')
#+end_src

#+RESULTS:
: [[./img/dmCityScape.png]]

#+attr_html: :width 600px
[[./img/dmCityScape.png]]

**** Partial Trace

Given a multi-qubit density matrix, we can get a reduced density matrix for any
subset of qubits.

#+begin_src python :results output :session qinfo :exports both
  ρ1 = qi.partial_trace( ρ, [0] )

  print(ρ1)
#+end_src

#+RESULTS:
: DensityMatrix([[0.5+0.j, 0.5+0.j],
:                [0.5+0.j, 0.5+0.j]],
:               dims=(2,))

** Conclusion
- The =quantum_info= module is useful for:
  - very basic simulations
  - exploring the quantum output of a circuit
- The =quantum_info= module does not handle circuit simulations that:
  - are too large
  - involve any measurement gates

* The =BasicSimulator= Class
:PROPERTIES:
:CUSTOM_ID: sec:BasicSimulator
:END:
#+include: "./back-to-index.org"

- We need the =BasicSimulator= class to perform simulations for circuits that
  include measurement gates
** Build a Circuit
- Following Diego Serrano's tutorial, I build a circuit which includes
  measurement gates
  - Start by importing required code
    #+begin_src python :results output :session basicsim :exports both
      from qiskit import QuantumCircuit
      from qiskit.providers.basic_provider import BasicSimulator

      simulator_basic = BasicSimulator()
    #+end_src

    #+RESULTS:

    - The main things we've accomplished in this code are:
      - We have imported the =BasicSimulator= class
      - We have created =simulator_basic= as a =BasicSimulator= object.
  - Build the circuit with two quantum bits and two classical bits
    #+begin_src  python :results output :session basicsim :exports both
      qc = QuantumCircuit(2,2) # two qubits, and two classical bits

      qc.h(1) # apply a H gate to qubit 1
      qc.measure(1, 1) # measure qubit 1, record its bit to classical bit 1
      qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1 
      qc.measure(0, 0) # measure qubit 0, record its result to classical bit 0
      qc.draw(reverse_bits=True)
    #+end_src
    
    #+RESULTS:
    : /var/folders/88/d26ncvp97zg50164_cmmlyf511m8tn/T/babel-bmQJhU/python-AGP0D6:5: DeprecationWarning: The method ``qiskit.circuit.instructionset.InstructionSet.c_if()`` is deprecated as of qiskit 1.3.0. It will be removed in 2.0.0.
    :   qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1


    #+begin_src  python :results output :session basicsim :exports none
      import os
      from pathlib import Path

      fname = os.path.join('html', 'img', 'QCwithMeas.png')
      qc.draw(reverse_bits=True, filename = fname)

      print(f"[[./{fname[5:]}]]")
    #+end_src

    #+RESULTS:
    : [[./img/QCwithMeas.png]]

    #+name: fig:cktWithMeas
    #+attr_html: :width 525px
    #+caption: This circuit has two qubits and two classical bits. The classical bits are required for measuremnt.
    [[./img/QCwithMeas.png]]

    In a Jupyter notebook, the output of =qc.draw()= will resemble Figure
    [[fig:cktWithMeas]].
** Helper Function: =orgfig=                                      :noexport:
#+begin_src  python :results output :session basicsim :exports both
  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')
#+end_src

#+RESULTS:

** Simulating the Circuit
- To run the circuit, we use the BasicSimulator.run() method, and we supply the
  desired circuit, and we can specify the number of shots for our simulation:
  #+begin_src  python :results output :session basicsim :exports both
    # The .run() method performs the simulation, and and the run is
    # saved as job
    job = simulator_basic.run( qc, shots=1024 )

    print(type(job))
  #+end_src

  #+RESULTS:
  : <class 'qiskit.providers.basic_provider.basic_provider_job.BasicProviderJob'>
  - This =run()= method returns a =BasicProviderJob= object
    - This has a =result()= method that returns a =Result()= object contains our
      simulation results

** Getting the Results
- We save the results as =results=:
  #+begin_src  python :results output :session basicsim :exports both
    results = job.result()

    print(type(results))

    print(results)
  #+end_src  

  #+RESULTS:
  : <class 'qiskit.result.result.Result'>
  : Result(backend_name='basic_simulator', backend_version='0.1', qobj_id='5fa46fbe-251b-4733-b29c-6cd05bb52024', job_id='5abb07aa-3a06-4ff7-94e5-a27a9e678d07', success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 519, '0x3': 505}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['c', 0], ['c', 1]], memory_slots=2, creg_sizes=[['c', 2]], name='circuit-160', global_phase=0.0, metadata={}), status=DONE, name='circuit-160', seed_simulator=np.int32(1719395928), time_taken=0.07600593566894531)], date=None, status=COMPLETED, header=QobjHeader(backend_name='basic_simulator', backend_version='0.1'), time_taken=0.0760350227355957)

- The results object has lots of information about our quantum experiment
  simulation

*** Simulation Counts 
- A =get_counts()= method helps us retrieve the outcomes and their frequencies.
  #+begin_src  python :results output :session basicsim :exports both
    counts = results.get_counts()

    print(counts)
  #+end_src  

  #+RESULTS:
  : {'00': 519, '11': 505}
  
*** Visualizing the Results
- We can plot the measurement results in two ways:
  - as a histogram (counts) using =plot_histogram()=, or
  - as a probability distribution using =plot_distribution()=.
#+begin_src  python :results output :session basicsim :exports both
  from qiskit.visualization import plot_histogram, plot_distribution

  display( plot_distribution( counts ) )

  display( plot_histogram( counts ) )
#+end_src  

#+RESULTS:

#+begin_src  python :results output :session basicsim :exports none
  fname = os.path.join('html', 'img', 'basicSimHist.png')
  plot_histogram( counts, filename=fname )
  print(f'\n[[./{fname[5:]}]]')

  fname = os.path.join('html', 'img', 'basicSimPD.png')
  plot_distribution( counts, filename=fname )
  print(f'\n[[./{fname[5:]}]]')
#+end_src  

#+RESULTS:
: 
: [[./img/basicSimHist.png]]
: 
: [[./img/basicSimPD.png]]

#+name: fig:BasicSimHist
#+attr_html: :width 600px
#+caption: A histogram from the results of a =BasicSimulator.run()= simulation.
[[./img/basicSimHist.png]]

#+name: fig:BasicSimHist
#+attr_html: :width 600px
#+caption: A quasi-probability distribution from the results of a =BasicSimulator.run()= simulation. Quasiprobabilities are not actual probabilities, but rather estimates of probabilites obtained by dividing the number of occurrences of an event by the total number of experiments (shots).
[[./img/basicSimPD.png]]

*** Inspecting Results from Individual Measurements
- We can see the results of individual measurements if we use the =get_memory()= method for a =Results= object
  - This requires using the ~memory~ keyword with a value of ~True~ in the
    ~run()~ method for our basic simulator
- Here, we do this with a fewer number of shots so that we can avoid
  overwhelming ourselves with numerous results
#+begin_src  python :results output :session basicsim :exports both
  small_job = simulator_basic.run( qc, shots=8, memory=True)
  small_result = small_job.result()
  samples = small_result.get_memory()

  print(samples)
#+end_src    

#+RESULTS:
: ['00', '00', '00', '00', '11', '11', '11', '00']

** Handling Complex Circuits
- The basic simulator cannot handle more complex circuits readily, such as the QFT circuit
- To handle complex circuits, we must first transpile our circuit.
#+begin_src  python :results output :session basicsim :exports both
  from qiskit.circuit.library import QFT

  qc = QuantumCircuit(3, 3) # 3 qubits, 3 classical bits
  qc.append( QFT(3), range(3) )
  qc.measure( range(3), range(3) )

  qc.draw()
#+end_src    

#+RESULTS:

#+begin_src  python :results output :session basicsim :exports none
  fname = os.path.join('html', 'img', 'BasicSimQFT.png')
  qc.draw( filename = fname )

  orgfig( fname[5:] )

#+end_src    

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/BasicSimQFT.png]]

#+name: fig:BasicQFTCircuit
#+attr_html: :width 480px
#+caption: This is a more complex circuit including a QFT. =BasicSimulator= cannot handle this unless we first transpile it.
[[./img/BasicSimQFT.png]]

*** Transpilation

- Circuits may be composed of gates of various types
- Some gates may not exist natively on a particular quantum processing unit
  (QPU), but may be implemented using the available gates on the QPU
  - The set of available gates is often called the instruction set architecture
    (ISA)
- To transpile a circuit is to represent it in the ISA of a particular machine
- In this case, we transpile the QFT into gates available within the
  =BasicSimulator= class.

#+name: lst:transpileQFT
#+caption: This code transpiles the circuit of Figure [[fig:BasicQFTCircuit]]
#+begin_src python :results output :session basicsim :exports both
  from qiskit import transpile

  qc_trans = transpile( qc, backend=simulator_basic)

  qc_trans.draw()

#+end_src

#+RESULTS:

#+begin_src  python :results output :session basicsim :exports none
  fname = os.path.join('html', 'img', 'BasicSimQFTtrans.png')
  qc_trans.draw( filename = fname )

  orgfig( fname[5:] )
#+end_src    

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/BasicSimQFTtrans.png]]

Jupyter output for Listing will resemble Figure [[fig:QFTtranspiled]]
#+name: fig:QFTtranspiled
#+attr_html: :width 640px
#+caption: This is a transpiled version of the circuit from Figure [[fig:BasicQFTCircuit]]
[[./img/BasicSimQFTtrans.png]]

** Conclusion
- The =BasicSimulator()= class is useful when we simulate a job where we need to
  find counts or samples of a circuit with mid-circuit measurements
- The =BasicSimulator()= class should not be used for:
  - large circuits with many qubits or many gates
  - circuits where a coherent state is desired (state vector or density matrix)
  - noisy simulations
* The ~qiskit_aer.AerSimulator~ Class
:PROPERTIES:
:CUSTOM_ID: sec:QiskitAerSimulator
:END:
#+include: "./back-to-index.org"

** Overview

- The Qiskit Aer AerSimulator class can be used to simulate complex circuits with mid-circuit measurements
- We can obtain unitary results from these simulations.
- Qiskit Aer supports both noise-free and noisy simulations
- The Qiskit ~AerSimulator~ class has a ~run()~ method that is simple and
  straightforward to use; however, its syntax is notably different from the
  tools used to launch calculations on actual quantum hardware (quantum
  processing units).
- The ~qiskit_ibm_runtime~ package provides interfaces called *primitives* to
  run jobs on QPUs. These primitives include:
  - ~SamplerV2~ for obtaining counts for an ensemble of measurements on a circuit
  - ~EstimatorV2~ for obtaining expectation values from the output of a circuit
- To simulate circuits in a way as closely as possible to the
  ~qiskit_ibm_runtime~ primitives, ~qiskit_aer~ also provides ~SamplerV2~ and
  ~EstimatorV2~ primitives
  - The ~qiskit_aer~ primitives are designed for similarity with
    the ~qiskit_ibm_runtime~ primitives
- In summary:
  - ~qiskit_aer.AerSimulator~ has a ~run()~ method for simulating quantum circuits
    - This is notably different from primitives used to run jobs on quantum hardware
  - ~qiskit_aer.primitives~ has ~SamplerV2~ and ~EstimatorV2~ classes, which may
    be used to simulate circuits in a way very similar to the primitives used
    for running jobs on QPUs using ~qiskit_ibm_runtime~
    
** Helper Function: =orgfig=                                      :noexport:
#+begin_src  python :results output :session aersim :exports both
  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')
#+end_src

#+RESULTS:

** Imports

- We begin by importing the required packages
  - This introduces the =qiskit_aer= package and the =AerSimulator= class
#+begin_src  python :results output :session aersim :exports both
  from qiskit import QuantumCircuit #, transpile
  # from qiskit.quantum_info import Statevector
  # from qiskit.providers.basic_provider import BasicSimulator
  # from qiskit_aer import AerSimulator

  # simulator_basic = BasicSimulator()
  # simulator_aer = AerSimulator()
  print('test')
#+end_src

#+RESULTS:
: test


** Build a Circuit

- We define a circuit in Listing [[lst:AerSimCkt]]
  #+name: lst:AerSimCkt
  #+begin_src python :results output :session aersim :exports both
    import qiskit
    qc = QuantumCircuit(2,2) # two qubits, and two classical bits

    qc.h(1) # apply a H gate to qubit 1
    qc.measure(1, 0) # measure qubit 1, record its bit to classical bit 0
    qc.h(0).c_if(0,1) # apply a X gate to qubit 0 if classical bit 1 is 1
    qc.save_statevector()

    qc.draw(reverse_bits=True)

    print(qiskit.__version__)
  #+end_src

  #+RESULTS: lst:AerSimCkt
  : 1.3.1



  #+name: lst:AerSimCktOrgExport
  #+begin_src python :results output :session aersim :exports none
    print(qc.save_statevector)
  #+end_src

  #+name: lst:AerSimCktOrgExport
  #+begin_src python :results output :session aersim :exports none
    import os
    fname = os.path.join('html', 'img', 'CktAerSim.png')
    qc.draw(reverse_bits=True, filename=fname)

    orgfig( fname[5:] )
  #+end_src

  #+RESULTS: lst:AerSimCktOrgExport
  : <bound method save_statevector of <qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x132c46dd0>>

  #+name: fig:defaultName
  #+attr_html: :width 480px
  #+caption: This is a two-qubit circuit with a measurement in the middle of the circuit.
  [[./img/CktAerSim.png]]

  - Here, the =save_statevector()= method defines a point in the circuit at
    which we wish to knkow the state vector
** Run the =AerSimulator()=

- We first transpile the circuit so it is suitable for our simulator, and then we run it:
  #+begin_src python :results output :session aersim :exports both
    qc_aer = transpile(qc, backend=simulator_aer)
 
    result = simulator_aer.run(qc_aer).result()
 
    ψ = result.get_statevector()
    ψ # show the state vector in Jupyter Lab
  #+end_src

  #+RESULTS:

  #+begin_src python :results output :session aersim :exports none
    print( ψ.draw(output='latex_source') ) # show the state vector in Jupyter Lab
  #+end_src

  #+RESULTS:
  : \frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle

  \begin{equation}
  \frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle
  \end{equation}
** Example 2: Circuit with Statevector in Middle of Circuit
- Now, we provide an example where the state vector is saved from a point prior to the end of the circuit.
  #+begin_src python :results output :session aersim :exports both
    qc = QuantumCircuit(4)
    qc.h(3)
    qc.cx(3,2)
    qc.save_statevector()
    qc.cx(3,1)
    qc.cx(3,0)
    qc.measure_all()

    qc.draw(reverse_bits=True)
  #+end_src

  #+RESULTS:

  #+begin_src python :results output :session aersim :exports none
    fname = os.path.join( 'html', 'img', 'AerSimMultiStatevectCkt.png')
    qc.draw(reverse_bits=True, filename=fname)

    orgfig( fname[5:] )
  #+end_src

  #+RESULTS:
  : 
  : #+name: fig:defaultName
  : #+attr_html: :width 480px
  : #+caption: Default caption.
  : [[./img/AerSimMultiStatevectCkt.png]]

  #+name: fig:defaultName
  #+attr_html: :width 640px
  #+caption: This circuit saves a =Statevector= in the middle of the calculation and just prior to measurement.
  [[./img/AerSimMultiStatevectCkt.png]]

*** Transpile and Run the Circuit
- Next, we transpile and run the circuit:
  #+begin_src python :results output :session aersim :exports both
    qc_aer = transpile(qc, backend=simulator_aer)

    result = simulator_aer.run(qc_aer).result()
 
    ψ = result.get_statevector()
    ψ
  #+end_src

  #+RESULTS:

  #+begin_src python :results output :session aersim :exports none
    print(ψ.draw(output='latex_source'))
  #+end_src

  #+RESULTS:
  : \frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle

  \begin{equation}
  \frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle
  \end{equation}

** Efficient Simulation
- Portions of the =AerSimulator= code are compiled to =C=
  - This allows faster and more efficient simulations, which enables simulations
    of larger and more complex circuits. 

*** Build a Circuit
#+begin_src python :results output :session aersim :exports both
  n = 24
  qc = QuantumCircuit(n)
  qc.h(n-1)

  for i in range(n-1, 0, -1):
      qc.cx(i,i-1)

  qc.measure_all()

  if n < 16:
      display(qc.draw(reverse_bits=True))
  else:
      print('Suppressed display of large circuit.')
#+end_src

#+RESULTS:
: Suppressed display of large circuit.

*** Run and Time the Circuit: =BasicSimulator= vs =AerSimulator=

**** BasicSimulator
- In the following code, I simulate and time the circuit
- In Jupyter Lab, the time to run a cell can be obtained by adding ~%%time~ at
  the top of the cell.
- These notes are not written in Jupyter Lab, so I use the =time= module
  - Key instructions:
    - =import time= to access the module
    - Use =time.time()= to get the current time
    - The difference between two =time= objects can be used to calculate a time
      interval in seconds
      
#+begin_src python :results output :session aersim :exports both
  # In Jupyter Lab, uncomment the '%%time'
  # %%time

  # timing for non-Jupyter-Lab work
  import time
  start = time.time() # log start time - not required for Jupyter
  result = simulator_basic.run( qc, shots=1024 ).result()
  end = time.time() # log end time - not required for Jupyter
  time_basic_sim = end - start # not needed in Jupyter

  counts = result.get_counts()
  print(counts)

  # print() not needed if using %%time in Jupyter Lab
  print('Time elapsed: {0:6.3f} s'.format( time_basic_sim ))
#+end_src

#+RESULTS:
: {'000000000000000000000000': 531, '111111111111111111111111': 493}
: Time elapsed: 17.700 s

**** =AerSimulator=
- We now run and time the same circuit using the =AerSimulator=, and we see it
  is much faster for larger circuits
#+begin_src python :results output :session aersim :exports both
  # In Jupyter Lab, uncomment the '%%time'
  # %%time

  # timing for non-Jupyter-Lab work
  start = time.time() # log start time - not required for Jupyter
  result = simulator_aer.run( qc, shots=1024 ).result()
  end = time.time() # log end time - not required for Jupyter
  time_aer_sim = end - start # not needed in Jupyter

  counts = result.get_counts()
  print(counts)

  # print() not needed if using %%time in Jupyter Lab
  print('Time elapsed: {0:6.3f} s'.format( time_aer_sim ))
#+end_src

#+RESULTS:
: {'111111111111111111111111': 537, '000000000000000000000000': 487}
: Time elapsed:  0.025 s

** Simulation Methods
- Qiskit Aer supports different types of simulation, accessible through the
  =method= keyword argument to the =run()= command.
  - The default is =method='statevector'=
    - The limit here is 24 qubits
  - Other methods include ='matrix_product_state'=
*** Build a Large Circuit

#+begin_src python :results output :session aersim :exports both
  n = 50
  qc = QuantumCircuit(n)
  qc.h(n-1)

  for i in range(n-1, 0, -1):
      qc.cx(i,i-1)

  qc.measure_all()

  if n < 16:
      display(qc.draw(reverse_bits=True))
  else:
      print('Suppressed display of large circuit.')
#+end_src

#+RESULTS:
: Suppressed display of large circuit.

*** Run and Time the Simulation

#+begin_src python :results output :session aersim :exports both
  # In Jupyter Lab, uncomment the '%%time'
  # %%time

  # timing for non-Jupyter-Lab work
  start = time.time() # log start time - not required for Jupyter
  result = simulator_aer.run( qc, shots=1024, method='matrix_product_state' ).result()
  end = time.time() # log end time - not required for Jupyter
  time_aer_sim = end - start # not needed in Jupyter

  counts = result.get_counts()
  print(counts)

  # print() not needed if using %%time in Jupyter Lab
  print('Time elapsed: {0:6.3f} s'.format( time_aer_sim ))
#+end_src

#+RESULTS:
: {'11111111111111111111111111111111111111111111111111': 492, '00000000000000000000000000000000000000000000000000': 532}
: Time elapsed:  0.081 s

** Noisy Simulation

*** Build a Circuit
#+begin_src python :results output :session aersim :exports both
  qc = QuantumCircuit(2,2)
  qc.h(1)
  qc.cx(1,0)
  qc.measure([1,0],[1,0])

  qc.draw()
#+end_src

#+RESULTS:

#+begin_src python :results output :session aersim :exports none
  fname = os.path.join( 'html', 'img', 'noisyCktExample.png')

  qc.draw(filename=fname)

  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/noisyCktExample.png]]

#+name: fig:cktAerSimNoisy
#+attr_html: :width 480px
#+caption: This is a small circuit for noisy simulation using the =AerSimulator=.
[[./img/noisyCktExample.png]]

*** Ideal Result

#+begin_src python :results output :session aersim :exports both
  # This will throw an error for n > 25 using method='statevector'
  qc_aer = transpile( qc, backend=simulator_aer )
  result_ideal = simulator_aer.run( qc_aer, shots=1024 ).result()
  counts_ideal = result_ideal.get_counts()
  print(counts_ideal)
#+end_src

#+RESULTS:
: {'11': 520, '00': 504}

*** Noisy Result

#+begin_src python :results output :session aersim :exports both
  from qiskit_aer import noise

  prob = 0.1
  error = noise.depolarizing_error( prob, 2 )

  noise_model = noise.NoiseModel()
  noise_model.add_all_qubit_quantum_error( error, ['cx'])
  basis_gates = noise_model.basis_gates

  result_noisy = simulator_aer.run(qc,
                                  shots=1024,
                                  noise_model=noise_model,
                                  basis_gates=basis_gates).result()

  counts_noisy = result_noisy.get_counts()
#+end_src

#+RESULTS:

*** Compare Ideal Result and Noisy Result

#+begin_src python :results output :session aersim :exports both
  from qiskit.visualization import plot_histogram, plot_distribution

  # In Jupyter Lab, uncomment this to see the compared distributions
  # plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )
#+end_src

#+RESULTS:

#+begin_src python :results output :session aersim :exports none
  fig = plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )

  fname = os.path.join('html', 'img', 'AerSimIdealvsNoisy.png')

  fig.savefig( fname )

  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/AerSimIdealvsNoisy.png]]

#+name: fig:IdealvNoisyAerSim
#+attr_html: :width 640px
#+caption: An ideal =AerSimulator= result is compared to a noisy result.
[[./img/AerSimIdealvsNoisy.png]]

** Summary
The ~AerSimulator()~ is useful when we want to:
1. Find counts/samples of large circuits (simulators are efficient)
2. Find state vector/density matrix of circuits with measurements
3. Simulate circuits with noise
   
The AerSimulator() results do not match the output format of Qiskit IBM runtime
(the quantum hardware).

Qiskit Aer has its own sampler/estimator, which provide a closer match to the
inputs and outputs of the hardware, but these are being deprecated.

In the next section, we explore [[https://docs.quantum.ibm.com/api/qiskit/primitives][primitives]], which are used
in Qiskit IBM runtime.

* Qiskit Primitives

** Overview

- The interface for the various simulators (BasicSimulator, AerSimulator) were
  identical to the Qiskit IBM Provider interface to the quantum hardware
- The backend was an abstraction for something that was either simulator or an
  actual quantum processor.
- Primitives abstract the interface between users and backends
- There are two available primitives:
  - Sampler - this samples the output state of a circuit
  - Estimator - this stimates expectation values of a state with respect to
    observables
- Qiskit, Qiskit Aer, and Qiskit IBM Runtime each provide different primitives.
- Diego recommends starting with the version 2 primitives, which are compatible
  with the current hardware:

- Qiskit
  - StatevectorSampler
  - StatevectorEstimator
- ~qiskit_aer~
  - ~primitives.SamplerV2~
  - ~primitives.EstimatorV2~
- ~qiskit_ibm_runtime~
  - ~SamplerV2~
  - ~EstimatorV2~

** Primitives
Qiskit primitives are computational building blocks used in larger applications that require quantum resources to efficiently produce outputs. The inputs to a primitive consists of primitive unified blocs (PUBs).

There are two types of primitives:
1. ~EstimatorV2~
2. ~SamplerV2~

The workflow is as before: build a circuit, and then simulate it (or run it on
hardware).

*** Helper Function: =orgfig=                                    :noexport:
#+begin_src  python :results output :session qisprim :exports both
  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')
#+end_src

#+RESULTS:

*** Imports
#+begin_src python :results output :session qisprim :exports both
  from qiskit import QuantumCircuit
  from qiskit.primitives import StatevectorSampler, StatevectorEstimator
  from qiskit.providers.basic_provider import BasicSimulator

  print('imports complete') # it's sometimes desirable to check job completion
#+end_src

#+RESULTS:
: imports complete

*** Build a Circuit

#+begin_src python :results output :session qisprim :exports both
  qc = QuantumCircuit(2, 2)
  qc.h(1)
  qc.cx(1,0)
  qc.measure([1,0],[1,0]) # measurement register: c
  qc.draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session qisprim :exports none
  import os
  fname = os.path.join('html', 'img', 'qisprimckt01.png')
  qc.draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/qisprimckt01.png]]

#+name: fig:qisprimckt01
#+attr_html: :width 480px
#+caption: This is a circuit for use with the =qiskit= primitives.
[[./img/qisprimckt01.png]]

*** Run Simulations

#+begin_src python :results output :session qisprim :exports both
  simulator = BasicSimulator()
  sampler = StatevectorSampler()
#+end_src

#+RESULTS:

**** Basic Simulation

This simulates the circuit using ~qiskit.
#+begin_src python :results output :session qisprim :exports both
  # No transpilation is needed for this simple circuit
  job_simulator = simulator.run( qc, shots=1024)
#+end_src

#+RESULTS:

**** Simulation using a Sampler

- The syntax for a sampler simulation is somewhat different than that of the
  =BasicSimulator= class.
  - Here, inputs are in the form of primitive-unified blocs (PUBS)
#+begin_src python :results output :session qisprim :exports both
  job_sampler = sampler.run( [qc], shots=1024)
#+end_src

#+RESULTS:

*** Extracting Results

- We extract results in the same way from both the simulator and the sampler:

#+begin_src python :results output :session qisprim :exports both
  result_simulator = job_simulator.result()
  result_sampler = job_sampler.result()
#+end_src

#+RESULTS:

***** Simulator Counts

- We can retrieve counts from the simulator result as before, using the
  ~get_counts()~ method:
  #+begin_src python :results output :session qisprim :exports both
    counts_simulator = result_simulator.get_counts()
    print( counts_simulator )
  #+end_src

  #+RESULTS:
  : {'11': 522, '00': 502}


***** Sampler Counts
- Getting counts from the sampler is a bit more involved. Let's eamine the
  results we obtained:
  #+begin_src python :results output :session qisprim :exports both
    print(type(result_sampler))
    print(result_sampler)
  #+end_src

  #+RESULTS:
  : <class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'>
  : PrimitiveResult([SamplerPubResult(data=DataBin(c=BitArray(<shape=(), num_shots=1024, num_bits=2>)), metadata={'shots': 1024, 'circuit_metadata': {}})], metadata={'version': 2})

  - The results from the sampler come as an object of class ~PubResult~
    object.
    - This class has a ~get_counts()~ method.
    - Since the input PUB for the sampler is a list, we must similarly index the
      result to get the result(s)  for a specific PUB item.
    - If we don't provide an index, get_counts() will
      aggregate the results, which may not be what we want.
- To get counts, we do the following:
- index the PUB result. Here, we call for the zeroth element.
- reference the data member data element, and reference the classical register name.
- use the ~get_counts()~ method.
  #+begin_src python :results output :session qisprim :exports both
    counts_sampler = result_sampler[0].data.c.get_counts()
    print(counts_sampler)
  #+end_src

  #+RESULTS:
  : {'11': 504, '00': 520}
** Example: A Parametrized Circuit

#+begin_src python :results output :session qisprim :exports both
  from qiskit import transpile
  from qiskit.circuit import Parameter
  from math import pi

  θ = Parameter('θ')

  qc2 = QuantumCircuit(2)
  qc2.rx(θ, 1) # assign a parameter for this rotation
  qc2.cx(1, 0)
  qc2.measure_all()
  qc2.draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session qisprim :exports none
  fname = os.path.join( 'html', 'img', 'prametrizedckt.png')
  qc2.draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/prametrizedckt.png]]

#+name: fig:parametrizedCkt
#+attr_html: :width 480px
#+caption: This circuit has a parameter θ.
[[./img/prametrizedckt.png]]


*** =BasicSimulator= Usage
Here, we make a list of circuits, each with a specific value of the parameter θ.
#+begin_src python :results output :session qisprim :exports both
  angles = [[pi/4], [pi/3], [pi/2]]

  circuits = []
  for angle in angles:
      qc_temp = qc2.assign_parameters({θ:angle[0]})
      circuits.append(qc_temp)
#+end_src

#+RESULTS:

We can draw the different circuits by indexing the list:
#+begin_src python :results output :session qisprim :exports both
  circuits[1].draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session qisprim :exports none
  fname = os.path.join( 'html', 'img', 'prametrizedckt_ex.png')
  circuits[1].draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:

#+name: fig:paramCktPrintFromList
#+attr_html: :width 480px
#+caption: We print a circuit from a list of circuits. Unlike the circuit of Fig. [[fig:parametrizedCkt]], this circuit has a specific value for θ.
[[./img/prametrizedckt_ex.png]]


**** Transpiling and Running

- The entire list of circuits can be transpiled in a single call to ~transpile()~
- The transpiled list can be called using one call to the =BasicSimulator.run()=
  method.

  #+begin_src python :results output :session qisprim :exports both
    # transpile the circuit list
    circuits_t = transpile( circuits, backend=simulator )

    result_simulator = simulator.run( circuits_t, shots=1024 ).result()
  #+end_src

  #+RESULTS:
- We provide an index to =get_counts()= for the corresponding circuit in
  =circuits_t=.
  #+begin_src python :results output :session qisprim :exports both
    counts_simulator = []

    for i, _ in enumerate(angles):
        result_temp = result_simulator.get_counts(i)
        counts_simulator.append(result_temp)

    print(counts_simulator)
  #+end_src  

  #+RESULTS:
  : [{'00': 875, '11': 149}, {'00': 780, '11': 244}, {'11': 465, '00': 559}]
*** =StatevectorSampler= Usage
- For a sampler, we pass a list of PUBs. This contains
  - the generic parametrized circuit, along with
  - the list of parameters
- This makes the =run()= command very simple.
#+begin_src python :results output :session qisprim :exports none
  result_sampler = sampler.run([(qc2, angles)], shots=1024).result()
#+end_src

#+RESULTS:

- To get the results, we index the =result_sampler=, i.e., =results_sampler[0]=
  - This indexes the zeroth (and only) PUB, with the flexibility to support multiple PUBs
- We iterate over the angles as before to get results for each angles
#+begin_src python :results output :session qisprim :exports none
  counts_sampler = []

  for i, _ in enumerate( angles ):
      result_temp = result_sampler[0].data.meas.get_counts(i)
      counts_sampler.append(result_temp)

  print(counts_sampler)
#+end_src

#+RESULTS:
: [{'00': 879, '11': 145}, {'00': 768, '11': 256}, {'00': 506, '11': 518}]

#+begin_warning
Caution: if we simply use =result.sampler[0].data.meas.get_counts()=, this aggregates the counts by summing them. Often, this is not what we want. 
#+end_warning


*** =StatevectorSampler= Usage with Multiple PUBs
We now pass two PUBs, each with a different circuit:
#+begin_src python :results output :session qisprim :exports both
  qc = QuantumCircuit(2,2)
  qc.h(1)
  qc.cx(1,0)
  qc.measure([1,0], [1,0])

  qc.draw()
#+end_src

#+RESULTS:

#+begin_src python :results output :session qisprim :exports none
  fname = os.path.join('html', 'img', 'circuit_multiPUBex.png')
  qc.draw( filename = fname )

  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/circuit_multiPUBex.png]]

#+name: fig:StateVectorMultiPubCkt
#+attr_html: :width 480px
#+caption: A circuit for use in an example with multiple PUBs.
[[./img/circuit_multiPUBex.png]]

**** Run the Multi-Pub Basic Sampler
- Here, we run one job with two different PUBs, each with a different circuit.
#+begin_src python :results output :session qisprim :exports both
  result_sampler = sampler.run([(qc2, angles), (qc, None)], shots=1024).result()
#+end_src

#+RESULTS:

**** Retrieve Data for the Zeroth Circuit
#+begin_src python :results output :session qisprim :exports both
  counts_sampler = [ result_sampler[0].data.meas.get_counts(k) for k in range(3) ]

  print(counts_sampler)
#+end_src

#+RESULTS:
: [{'00': 857, '11': 167}, {'00': 774, '11': 250}, {'00': 501, '11': 523}]

**** Retrieve Data for the First Circuit
- Here, we have a non-parametrized circuit, so we don't need to provide an argument to =get_counts()=
#+begin_src python :results output :session qisprim :exports both
  counts_sampler = result_sampler[1].data.c.get_counts()
  print(counts_sampler)
#+end_src

#+RESULTS:
: {'11': 521, '00': 503}

** The Estimator Primitive
- The =StatevectorEstimator= primitive takes a PUB, but with a slightly different format from =BasicSampler=.
- The circuits cannot have any measurement gates
#+begin_src python :results output :session qisprim :exports both
  qc2 = QuantumCircuit(2)
  qc2.rx(θ, 1)
  qc2.cx(1, 0)

  qc2.draw( reverse_bits = True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session qisprim :exports none
  fname = os.path.join('html', 'img', 'sample_ckt_for_Estimator.png')
  qc2.draw( reverse_bits = True, filename=fname)

  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/sample_ckt_for_Estimator.png]]

#+name: fig:defaultName
#+attr_html: :width 480px
#+caption: This circuit was built for use with an =Estimator= simulation. For this reason, we do not include measurement blocks.
[[./img/sample_ckt_for_Estimator.png]]

*** Observables
- Since an estimator estimates expectation values \(\left\langle \psi |
  \mathbf{O} | \right\rangle\), we need an observable, \(\mathbf{O}\).
#+begin_src python :results output :session qisprim :exports both
  from qiskit.quantum_info import SparsePauliOp

  # This is a list of observables. I'm not sure why it's a list of lists.
  obsv = [ [ SparsePauliOp( ["XX", "IY"], [0.5, 0.5] ) ],
           [ SparsePauliOp( ["XX"], [1] ) ] ]

  print(obsv)
#+end_src

#+RESULTS:
: [[SparsePauliOp(['XX', 'IY'],
:               coeffs=[0.5+0.j, 0.5+0.j])], [SparsePauliOp(['XX'],
:               coeffs=[1.+0.j])]]

*** Run the Estimator

#+begin_src python :results output :session qisprim :exports both
  estimator = StatevectorEstimator()
  result_estimator = estimator.run( [(qc2, obsv, angles, 0.1)] ).result()
#+end_src

#+RESULTS:

*** Extract Expectation Values
- To extract the expectation values from the estimator result, we do the following:
  - index the result
  - use the =.data.evs= property
  - (optional) we can see some metadata using the =.metadata= function
#+begin_src python :results output :session qisprim :exports both
  # Extract the expectation values (evs) from the result for PUB 0
  print(result_estimator[0].data.evs)
  print(result_estimator[0].metadata)
#+end_src

#+RESULTS:
: [[ 0.05985877  0.14030793  0.18762585]
:  [ 0.10722808 -0.04870472  0.15934201]]
: {'target_precision': 0.1, 'circuit_metadata': {}}

- This is a list of two observables, with one value for each of the input
  parameters.
** Qiskit Estimator Example
- This provides another example from a Qiskit documentation [[https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives][tutorial]]
  #+begin_src python :results output :session IBMexample :exports both
    from qiskit import QuantumCircuit
    from qiskit.circuit import Parameter
 
    # circuit for which you want to obtain the expected value
    qc = QuantumCircuit(2)
    qc.ry(Parameter('theta'), 0)
    qc.h(0)
    qc.cx(0,1)
    qc.draw("mpl", style="iqp")
  #+end_src

  #+RESULTS:

  #+begin_src python :results output :session IBMexample :exports none
    def orgfig( fname, width=480 ):

        print(f'\n#+name: fig:defaultName')
        print(f'#+attr_html: :width {width}px')
        print(f'#+caption: Default caption.')
        print(f'[[./{fname}]]')

    import os

    fname = os.path.join('html', 'img', 'EstimatorIBMExCkt.png')
    qc.draw("mpl", style="iqp", filename=fname)

    orgfig( fname[5:] )

  #+end_src

  #+RESULTS:
  : 
  : #+name: fig:defaultName
  : #+attr_html: :width 480px
  : #+caption: Default caption.
  : [[./img/EstimatorIBMExCkt.png]]
  : Saved figure

  #+name: fig:defaultName
  #+attr_html: :width 480px
  #+caption: This is a simple circuit built for an IBM Quantum tutorial on using the =StatevectorEstimator=.
  [[./img/EstimatorIBMExCkt.png]]

*** Build an Operator
#+begin_src python :results output :session IBMexample :exports both
  from qiskit.quantum_info import SparsePauliOp
  import numpy as np

  # observable(s) whose expected values you want to compute
  from qiskit.quantum_info import SparsePauliOp
  observable = SparsePauliOp(["II", "XX", "YY", "ZZ"], coeffs=[1, 1, -1, 1])

  # value(s) for the circuit parameter(s)
  parameter_values = [[0], [np.pi/6], [np.pi/2]]
  print(parameter_values)
#+end_src

#+RESULTS:
: [[0], [0.5235987755982988], [1.5707963267948966]]

  
*** Instantiate a =StatevectorEstimator=
#+begin_src python :results output :session IBMexample :exports both
  from qiskit.primitives import StatevectorEstimator
  estimator = StatevectorEstimator()
#+end_src

#+RESULTS:

  
*** Transpile the Circuit
#+begin_src python :results output :session IBMexample :exports both
  # Generate a pass manager without providing a backend
  from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
 
  pm = generate_preset_pass_manager(optimization_level=1)
  isa_circuit = pm.run(qc)
  isa_observable = observable.apply_layout(isa_circuit.layout)
#+end_src

#+RESULTS:

*** Run the Estimator
- We form a PUB as an argument to the =StatevectorEstimator=
#+begin_src python :results output :session IBMexample :exports both
  job = estimator.run([(isa_circuit, isa_observable, parameter_values)])
  result = job.result()
  print(f" > Result class: {type(result)}")
#+end_src

#+RESULTS:
:  > Result class: <class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'>

*** Extract Results
- To extract the expectation values from the estimator result, we do the
  following:
  - index the result
  - use the =.data.evs= property
#+begin_src python :results output :session IBMexample :exports both
  print(result)
  print(len(result))
  print(f" > Expectation value: {result[0].data.evs}")
  print(f" > Metadata: {result[0].metadata}")
#+end_src

#+RESULTS:
: PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(3,), dtype=float64>), stds=np.ndarray(<shape=(3,), dtype=float64>), shape=(3,)), metadata={'target_precision': 0.0, 'circuit_metadata': {}})], metadata={'version': 2})
: 1
:  > Expectation value: [4.         3.73205081 2.        ]
:  > Metadata: {'target_precision': 0.0, 'circuit_metadata': {}}
    

* ~qiskit_aer~ Primitives
We demonstrate the use of ~qiskit_aer~ primitives.

** Example: Bell Circuits and the ~SamplerV2~ Class

Bell circuits are used to create entangled pairs of qubits. We will simulate two
of the four Bell circuits using the ~SamplerV2~ class provided in
~qiskit_aer.primitives~.

*** Helper function                                             :noexport:
#+begin_src  python :results output :session bellcirc :exports both
  from datetime  import datetime

  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')

  print(f'Defined function orgfig() at {datetime.now()}')

  # import sys
  # print(sys.version)
  # print(sys.executable)
#+end_src

#+RESULTS:
: Defined function orgfig() at 2025-03-11 11:40:54.656284

*** Imports
#+begin_src python :session bellcirc :results output :exports both
  from qiskit import QuantumCircuit
  from qiskit_aer.primitives import SamplerV2

  from datetime import datetime

  # Optional
  print(f'Imports complete at {datetime.now()}')
#+end_src

#+RESULTS:
: Imports complete at 2025-03-11 11:41:07.824550

#+begin_note
*Note*

If you are using Jupyter Lab, you need not use ~dateime~ and ~print()~ to
indicate completion.

Here, I'm using ~datetime~ and ~print()~ because I'm developing these notes in
Emacs org mode. Here, Python code blocks in session mode often do not indicate
errors, and completion messages help me know the code block has executed
properly.
#+end_note

*** Bell Circuits

**** First Case

Not only must we form a Bell circuit, but we must also add measurement
gates. The measurement gates are required if we wish to obtain circuit counts.
#+begin_src python :session bellcirc :results output :exports both
  Bell00 = QuantumCircuit(2)
  Bell00.h(0)
  Bell00.cx(0,1)

  # measure_all() adds a classical register named "meas"
  Bell00.measure_all()

  print(Bell00)
#+end_src

#+RESULTS:
:         ┌───┐      ░ ┌─┐   
:    q_0: ┤ H ├──■───░─┤M├───
:         └───┘┌─┴─┐ ░ └╥┘┌─┐
:    q_1: ─────┤ X ├─░──╫─┤M├
:              └───┘ ░  ║ └╥┘
: meas: 2/══════════════╩══╩═
:                       0  1


#+begin_src python :session bellcirc :results output :exports none
  import os

  fname = os.path.join( 'html', 'img', 'Bell00ckt.png' )
  Bell00.draw( filename = fname )

  # print(fname)
  orgfig( fname[5:] )

  print(f'\nCode block complete at {datetime.now()}')

#+end_src

#+RESULTS:
: /Users/enrique_blair/anaconda3/envs/QC2025env/lib/python3.11/site-packages/qiskit/visualization/circuit/matplotlib.py:278: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.
:   mpl_figure = plt.figure()
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/Bell00ckt.png]]
: 
: Code block complete at 2025-03-11 12:35:16.150760

#+name: fig:BellCircuit01
#+attr_html: :width 380px
#+caption: This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 00 \right\rangle + \left|11  \right\rangle \right)/\sqrt{2} \).
[[./img/Bell00ckt.png]]

**** A Second Circuit

#+begin_src python :session bellcirc :results output :exports both
  Bell01 = QuantumCircuit(2)
  Bell01.h(0)
  Bell01.x(1)
  Bell01.cx(0,1)

  # measure_all() adds a classical register named "meas"
  Bell01.measure_all()

  print(Bell01)
  print(f'\nCode block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: 
: Code block complete at 2025-03-11 11:41:33.493997


#+begin_src python :session bellcirc :results output :exports none
  import os

  fname = os.path.join( 'html', 'img', 'Bell01ckt.png' )
  Bell01.draw( filename = fname )

  # print(fname)
  orgfig( fname )

  print(f'\nCode block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./html/img/Bell01ckt.png]]
: 
: Code block complete at 2025-03-11 12:32:46.953944

#+name: fig:BellCircuit01
#+attr_html: :width 380px
#+caption: This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 01 \right\rangle + \left|10  \right\rangle \right)/\sqrt{2} \).
[[./img/Bell01ckt.png]]



**** Join Circuits into a List

Now, we form a list of circuits.
#+begin_src python :session bellcirc :results output :exports both
  # Form a list of Bell circuits
  BellCkts = [Bell00, Bell01]

  print(f'\nCode block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: 
: Code block complete at 2025-03-11 11:37:43.001165

*** Transpilation

We can now transpile our list of circuits. To *transpile* a circuit is to form
an equivalent circuit using a set of gates (instruction set architecture, or
ISA) that is supported on a specific quantum processing unit (QPU).

To transpile, we tools called =pass_managers=. =qiskit= has some preset pass
managers, which make it more convenient.

One other piece of information we must provide is the target backend. The target
backend could be an =AerSimulator()=, a local model of a QPU (=FakeBackend=), or
an actual QPU. Different resources may have different ISAs, so it is important
to specify your transpilation target.

#+begin_src python :session bellcirc :results output :exports both
  import sys
  from qiskit_aer import AerSimulator
  from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
  
  # create a backend
  backend_aer = AerSimulator()

  # Specify the target backend for transpilation
  target_aer = backend_aer.target
  
  # Create a pass manager object to perform the transpilation
  pm_aer = generate_preset_pass_manager(target=target_aer, optimization_level=1)

  # Want to know more about the pass manager? Start printing things about it.
  # print(f'Class of pm_aer: {type(pm_aer)}')
  # print(f'pm_aer: {pm_aer}')
  # print(f'pm_aer attributes: {pm_aer.__dict__}')

  print(f'\nCode block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: 
: Code block complete at 2025-03-11 11:43:31.984413


Next, we can transpile our circuits for the desired backend:
#+begin_src python :session bellcirc :results output :exports both
  BellCkts_aer = pm_aer.run( BellCkts ) 

  print(f'Code block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: Code block complete at 2025-03-11 11:45:38.043943

We may wish to compare our transpiled circuit to our original circuit:
#+begin_src python :session bellcirc :results output :exports both
  for idx, ckt in enumerate(BellCkts):
      print('='*70 + f'\nidx = {idx}')

      print('Original')
      print(ckt)

      print('Transpiled')
      print(BellCkts_aer[idx])      

#+end_src

#+RESULTS:
#+begin_example
======================================================================
idx = 0
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
======================================================================
idx = 1
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
#+end_example

In this case, both the original circuit and the transpiled circuit are the
same. When we try to use a =FakeBackend= or a real QPU, however, the transpiled
circuit may look quite different from the origial circuit you designed.

*** Forming PUBs

Now that we have transpiled circuits that we can run on a simulator--or, if
transpiled properly, on actual hardware--we can form a list of PUBs as a batch
of subtasks forming a job. A PUB is a "primitive unified bloc." Each PUB is a
tuple containing a circuit and circuit parameters, as in ~(circ, params)~. Here,
the circuits we are dealing with are simple and do not require parameters. Thus,
they are said to be non-parameterized circuits, and we use ~None~ for ~params~.

#+begin_src python :session bellcirc :results output :exports both
  PUBs_aer = [ (ckt, None) for ckt in BellCkts_aer ]

  print(f'Created a list of PUBs for the Aer SamplerV2 at {datetime.now()}')
  print(f'Your list of PUBs contains {len(PUBs_aer)} PUBs.')
#+end_src

#+RESULTS:
: Created a list of PUBs for the Aer SamplerV2 at 2025-03-11 11:45:59.322433
: Your list of PUBs contains 2 PUBs.

*** Simulating the Circuits

Here, we will use =qiskit_aer.primitives.SamplerV2()= as our simulation
platform. First, we instantiate a ~SamplerV2~ object. Note: we import
`qiskit_aer.primitives.SamplerV2~ as ~Sampler~ to distinguish it from the
~qiskit_ibm_runtime.SamplerV2~ which we will use later.

#+begin_src python :session bellcirc :results output :exports both
  # Instantiate a sampler
  from qiskit_aer.primitives import SamplerV2 as Sampler

  sampler_aer = Sampler() # sampler for simulator, no arguments
  # Run the `SamplerV2` simulation

  print(f'Created a SamplerV2 at {datetime.now()}')

#+end_src

#+RESULTS:
: Created a SamplerV2 at 2025-03-11 11:46:33.385617

Finally, we use the ~run()~ method of our sampler. We will specify a shot count
of 4096, since we may wish to compare with results from actual hardware using a
~qiskit_ibm_runtime.SamplerV2~ object. 

#+begin_src python :session bellcirc :results output :exports both
  # Instantiate a sampler
  from qiskit_aer.primitives import SamplerV2 as Sampler

  job_sim = sampler_aer.run( PUBs_aer, shots=4092 ) # simulated job with 4092 shots
  # Run the `SamplerV2` simulation

  print(f'Simulated the SamplerV2 at {datetime.now()}')

#+end_src

#+RESULTS:
: Simulated the SamplerV2 at 2025-03-11 11:46:43.562745

*** Accessing Results

We can extract results from our job using its ~.result()~ method:
#+begin_src python :session bellcirc :results output :exports both
  results_sim = job_sim.result()

  print(results_sim)
#+end_src

#+RESULTS:
: PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(<shape=(), num_shots=4092, num_bits=2>)), metadata={'shots': 4092, 'circuit_metadata': {}, 'simulator_metadata': {'time_taken_parameter_binding': 0.000403083, 'max_memory_mb': 36864, 'time_taken_execute': 0.018819333, 'omp_enabled': True, 'max_gpu_memory_mb': 0, 'parallel_experiments': 1}}), SamplerPubResult(data=DataBin(meas=BitArray(<shape=(), num_shots=4092, num_bits=2>)), metadata={'shots': 4092, 'circuit_metadata': {}, 'simulator_metadata': {'time_taken_parameter_binding': 0.000403083, 'max_memory_mb': 36864, 'time_taken_execute': 0.018819333, 'omp_enabled': True, 'max_gpu_memory_mb': 0, 'parallel_experiments': 1}})], metadata={'version': 2})

Since the list of PUBs contained two PUBs, our job has two results embedded in
it. We access them using an index, as in ~job_sim[0]~ and
~job_sim[1]~. Furthermore, to extract counts, we use the ~.data~ property for
each PUB result. We also must specify the name of the classical register on
which measurement results are stored. In this case, we used ~.measure_all()~ to
add measurement gates, so this creates a classical register named
~meas~. Finally, for our classical register, we use the ~get_counts()~ method.

#+begin_src python :session bellcirc :results output :exports both
  for idx in range(2):
      print(results_sim[idx].data.meas.get_counts())
#+end_src

#+RESULTS:
: {'00': 2081, '11': 2011}
: {'10': 2095, '01': 1997}

Indeed, we can print our results, but it is much nicer to plot them using a
histogram.

#+begin_src python :eval never
  from qiskit.visualization import plot_histogram

  for idx in range(2):
      print(f'Bell circuit {idx}')
      display(plot_histogram(results_sim[idx].data.meas.get_counts()))
#+end_src

#+begin_src python :session bellcirc :results output :exports none
  from qiskit.visualization import plot_histogram
  import os

  for idx in range(2):
      fname = os.path.join('html', 'img',
                           f'bell_ckt_results{idx:02d}.png')
    
      print(f'\nBell circuit {idx}:')
      plot_histogram(results_sim[idx].data.meas.get_counts(),
                     filename=fname)

      orgfig(fname[5:])
#+end_src

#+RESULTS:
#+begin_example

Bell circuit 0:

,#+name: fig:defaultName
,#+attr_html: :width 480px
,#+caption: Default caption.
[[./img/bell_ckt_results00.png]]

Bell circuit 1:

,#+name: fig:defaultName
,#+attr_html: :width 480px
,#+caption: Default caption.
[[./img/bell_ckt_results01.png]]
#+end_example

A histgoram for the results of Bell circuit 0 are shown here:
#+name: fig:BellCkt00_hist
#+attr_html: :width 480px
#+caption: The measured  result is consistent with Bell circuit 0, which produces \(\left(\left|00 \right\rangle + \left|11 \right\rangle\right)/\sqrt{2}\).
[[./img/bell_ckt_results00.png]]


A similar histogram for measurements on Bell circuit 1 are shown here:
#+name: fig:BellCkt01_hist
#+attr_html: :width 480px
#+caption: The measured  result is consistent with Bell circuit 0, which produces \(\left(\left|01 \right\rangle + \left|10 \right\rangle\right)/\sqrt{2}\).
[[./img/bell_ckt_results01.png]]

** Summary

We have used a ~qiskit_aer.primitives.SamplerV2~ object to perform noise-free
simulations of quantum circuits.

A next step will be to perform similar computations on actual quantum hardware,
and then to compare the results.

* Bell Circuits on IBM Quantum Hardware

To run the same Bell circuits on IBM hardware, we require the
~qiskit_ibm_runtime~ package. For an equivalent to our previous simulation of
Bell circuits, we will also use the ~SamplerV2~ class.

** Imports
Let's begin by importing some tools we need from ~qiskit_ibm_runtime~. We will
import the ~SamplerV2~ for getting measurement counts on actual hardware, and
~QiskitRuntimeService~ for making a connection to IBM Quantum.

#+begin_src python :session bellcirc :results output :exports both
  from qiskit_ibm_runtime import SamplerV2, QiskitRuntimeService

  print(f'\nCode block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: 
: Code block complete at 2025-03-11 13:38:02.145513

** The Bell Circuits

We do not recreate the Bell circuits here, since we already have created them.
Instead, we show them here once again.

#+name: fig:BellCircuit01-redrawn
#+attr_html: :width 380px
#+caption: This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 00 \right\rangle + \left|11  \right\rangle \right)/\sqrt{2} \).
[[./img/Bell00ckt.png]]

#+name: fig:BellCircuit01-redrawn
#+attr_html: :width 380px
#+caption: This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 01 \right\rangle + \left|10  \right\rangle \right)/\sqrt{2} \).
[[./img/Bell01ckt.png]]

** Transpilation

To transpile our circuits, we first require a backend, which is the target ISA
for the transpilation process. To obtain a backend, we must use our IBM Quantum
API token. To do this, you need to create an IBM Quantum account if you don't
already have one; and you need to find your IBM Quantum API token.

We will take the following steps:
1. Register for an IBM Quantum account if you don't already have one.
2. Find your IBM Quantum API token
3. Load your token in Python for programmatic access to IBM Quantum.
4. Establish a connection to IBM Quantum using your API token.
5. Select a backend QPU
6. Transpile your circuits for the target backend

*** Getting Your IBM Quantum API Token

1. If you don't already have one, use your university e-mail account
   (prefferable) to register for an account.
2. Once logged in, you can get your IBM token in one of two ways:
   1. Visit your [[https://quantum.ibm.com][IBM Quantum Platform dashboard]]
      1. In the upper right, you'll see a box where you can view or copy your
         IBM Quantum API token
         #+attr_html: :width 360px
         [[./img/IBMQuantumDashboard.png]]
   2. Click the "Account" button (by default, it looks like an anonymized
      profile pic). This brings up your /Profile Settings/
      #+attr_html: :width 360px
      [[./img/IBMQuantumAccountIcon.png]]
      1. Below the /Profile Details/ is an /API Token/. Click the icon that allows
         you to copy you IBM Quantum API token. You will paste this information
         elsewhere later.
         
#+begin_src python :session bellcirc :results output :exports both
  import sys
  from qiskit_aer import AerSimulator
  from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
  
  # create a backend
  backend_aer = AerSimulator()

  # Specify the target backend for transpilation
  target_aer = backend_aer.target
  
  # Create a pass manager object to perform the transpilation
  pm_aer = generate_preset_pass_manager(target=target_aer, optimization_level=1)

  # Want to know more about the pass manager? Start printing things about it.
  # print(f'Class of pm_aer: {type(pm_aer)}')
  # print(f'pm_aer: {pm_aer}')
  # print(f'pm_aer attributes: {pm_aer.__dict__}')

  print(f'\nCode block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: 
: Code block complete at 2025-03-11 11:43:31.984413


*** The [[https://docs.python.org/3/library/getpass.html][getpass]] Package
- This is a nice Python package that is useful in Jupyter notebooks
- It allows you to prompt the user for a password that can be used later in the file.
- The basic usage is:
  #+begin_src python :eval never
    import getpass # this comes with standard Python

    # This interactively prompts the user for their password
    token = getpass.getpass('Enter your password: ')
  #+end_src
- You can then use =token= in an API call
- This allows you to share Jupyter notebooks /without/ also sharing your
  password/token/API key.

*** My Approach to Loading My Token (not recommended)
#+begin_note
If you are using a Jupyter Lab notebook, please ignore this section. This is
useful for me, since I'm coding in Emacs Org mode.
#+end_note
- I use this approach because I sometimes run Python code /outside/ of a Jupyter
  notebook, so I don't have an opportunity to dynamically input my password
  using =getpass=
- My approach was to save a file on my computer, say, =~/.IBMQpass=
  - This is a text file containing only my IBM Quantum token
- Then, I can load the token in a variable called =token= using code like this:
  #+begin_src python :session bellcirc :results output :exports both
    import os
    from datetime import datetime

    # Read the token from a secure file
    # Expand the '~' to the full path
    file_path = os.path.expanduser("~/.IBMQpass")
    with open(file_path, "r") as file:
        token = file.read().strip()

    print('\nLoaded IBM Quantum token: {0}'.format(datetime.now()))
  #+end_src

  #+RESULTS:
  : 
  : Loaded IBM Quantum token: 2025-03-11 13:23:35.985776
*** Establish a Connection to IBM Quantum
- To interface with the IBM cloud resources, we establish a
  =QiskitRuntimeService= object, =service=
  #+begin_src python :session bellcirc :results output :exports both
    service = QiskitRuntimeService(channel='ibm_quantum')

    print(f'Established a service at {datetime.now()}')
  #+end_src

  #+RESULTS:
  : Established a service at 2025-03-11 13:38:33.591301

- We can then use the =service= object to query available QPUs
  #+begin_src python :session bellcirc :results output :exports both
    print(service.backends())
    # in Jupyter notebook, you don't need print() ... just use
    # service.backends() as the last command in your cell.
  #+end_src

  #+RESULTS:
  : [<IBMBackend('ibm_brisbane')>, <IBMBackend('ibm_kyiv')>, <IBMBackend('ibm_sherbrooke')>]

- This is a list of objects of the [[https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend][IBMBackend]] class
  - We can ask for the least-busy backend using the =.least_busy()= method:
    #+begin_src python :session bellcirc :results output :exports both
      # save the least-busy backend as backend
      backend_qpu = service.least_busy()

      print(f'Least busy QPU: {backend_qpu} ({datetime.now()})')
    #+end_src

    #+RESULTS:
    : Least busy QPU: <IBMBackend('ibm_kyiv')> (2025-03-11 13:50:36.850750)

- We can get information about a backend using properties such as ~.name~,
  ~.version~, and ~.num_qubits~:
  #+begin_src python :session bellcirc :results output :exports both
    print(
        f"Name: {backend_qpu.name}\n"
        f"Version: {backend_qpu.version}\n"
        f"No. of qubits: {backend_qpu.num_qubits}\n"
    )
  #+end_src

  #+RESULTS:
  : Name: ibm_kyiv
  : Version: 2
  : No. of qubits: 127

- Now that we've picked a backend, we can transpile our circuits for that
  backend.

*** Transpilation

Now that we have a backend in mind, we can transpile our circuits for the
desired backend:
#+begin_src python :session bellcirc :results output :exports both
  # Specify the target backend for transpilation
  target_qpu = backend_qpu.target

  # Create a pass manager object to perform the transpilation
  pm_qpu = generate_preset_pass_manager(target=target_qpu, optimization_level=1)

  # Want to know more about the pass manager? Start printing things about it.
  # print(f'Class of pm_aer: {type(pm_aer)}')
  # print(f'pm_aer: {pm_aer}')
  # print(f'pm_aer attributes: {pm_aer.__dict__}')

  BellCkts_qpu = pm_qpu.run( BellCkts ) 

  print(f'Code block complete at {datetime.now()}')
#+end_src

#+RESULTS:
: Code block complete at 2025-03-11 14:06:37.004840

We can see the transpiled version of our circuits if we print them.

In Jupyter Lab, something like the following may be used to display the
circuits:
#+begin_src python :session bellcirc :results output :exports both :eval never
  for idx, ckt in enumerate(BellCkts):
      display(BellCkts_qpu[idx].draw(idle_wires=False))
#+end_src

#+begin_src python :session bellcirc :results output :exports none
  for idx, ckt in enumerate(BellCkts):
      fname = os.path.join('html', 'img', f'BellCkt{idx}_qpu.png')
      BellCkts_qpu[idx].draw(idle_wires=False, filename=fname)

      orgfig( fname[5:] )

  print(f'saved images of circuits at {datetime.now()}.')

#+end_src

#+RESULTS:
#+begin_example

,#+name: fig:defaultName
,#+attr_html: :width 480px
,#+caption: Default caption.
[[./img/BellCkt0_qpu.png]]

,#+name: fig:defaultName
,#+attr_html: :width 480px
,#+caption: Default caption.
[[./img/BellCkt1_qpu.png]]
saved images of circuits at 2025-03-11 14:14:43.967534.
#+end_example

#+name: fig:BellCkt00_qpu
#+attr_html: :width 480px
#+caption: The first Bell circuit is transpiled for the selected backend, ~backend_qpu~.
[[./img/BellCkt0_qpu.png]]

#+name: fig:BellCkt01_qpu
#+attr_html: :width 480px
#+caption: The first Bell circuit is transpiled for the selected backend, ~backend_qpu~.
[[./img/BellCkt1_qpu.png]]


We may wish to compare our transpiled circuit to our original circuit:
#+begin_src python :session bellcirc :results output :exports both
  for idx, ckt in enumerate(BellCkts):
      print('='*70 + f'\nidx = {idx}')

      print('Original circuit design:')
      print(ckt)

#+end_src

#+RESULTS:
#+begin_example
======================================================================
idx = 0
Original circuit design:
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
======================================================================
idx = 1
Original circuit design:
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
#+end_example

Now, we can clearly see that the transpiled circuit looks rather different from
the original design. The transpiled circuit may have many more qubits than the
original design; however, extra qubits are suppressed from our drawings by using
the keyword ~idle_qubits=False~ in the ~draw()~ method for a circuit.

*** Forming PUBs

Now that we have transpiled circuits for the QPU, we must form a list of PUBs:
#+begin_src python :session bellcirc :results output :exports both
  PUBs_qpu = [ (ckt, None) for ckt in BellCkts_qpu ]

  print(f'Created a list of PUBs for the QPU at {datetime.now()}')
  print(f'Your list of PUBs contains {len(PUBs_qpu)} PUBs.')
#+end_src

#+RESULTS:
: Created a list of PUBs for the QPU at 2025-03-11 14:24:10.350039
: Your list of PUBs contains 2 PUBs.

Next, we will run our jobs by submittin the PUBs.

** Running the Circuits

Here, we will use =qiskit_aer.primitives.SamplerV2()= as our simulation
platform. First, we instantiate a ~SamplerV2~ object. Note: we import
`qiskit_aer.primitives.SamplerV2~ as ~Sampler~ to distinguish it from the
~qiskit_ibm_runtime.SamplerV2~ which we will use later.

#+begin_src python :session bellcirc :results output :exports both
  # Instantiate a sampler
  from qiskit_ibm_runtime import SamplerV2

  sampler_qpu = SamplerV2( backend_qpu )

  print(f'Created a SamplerV2 for use with a QPU at {datetime.now()}')
#+end_src

#+RESULTS:
: Created a SamplerV2 for use with a QPU at 2025-03-11 14:26:32.622540

Finally, we use the ~run()~ method of our sampler. We will specify a shot count
of 4096, since we may wish to compare with results from actual hardware using a
~qiskit_ibm_runtime.SamplerV2~ object. 

#+begin_src python :session bellcirc :results output :exports both
  # We specify the same number of shots as in our simulated run

  # use None to launch a new calculation.
  # use an actual job_id to retrieve an existing calculation.
  # job_id = None
  job_id = 'cz890patp60g008grx9g'

  if job_id is None:
      job_qpu = sampler_qpu.run( PUBs_qpu, shots=4092 ) 
      print(f'Submitted the QPU job at {datetime.now()}')
      job_id = job_qpu.job_id()
      print(f'   Job ID: {job_id}')

  else:
      job_qpu = service.job( job_id )
      print(f'Retrieved existing job ({datetime.now()}).')
      print(f'   Job ID: {job_id}')
#+end_src

#+RESULTS:
: Retrieved existing job (2025-03-11 14:35:30.892405).
:    Job ID: cz890patp60g008grx9g

We can check the status of our job:
#+begin_src python :session bellcirc :results output :exports both
  print(f'The status of our job is: {job_qpu.status()}')
#+end_src

#+RESULTS:
: The status of our job is: DONE

** Accessing the Results

We can extract results from our job using its ~.result()~ method:
#+begin_src python :session bellcirc :results output :exports both
  results_qpu = job_qpu.result()

  print(results_qpu)
#+end_src

#+RESULTS:
: PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(<shape=(), num_shots=4092, num_bits=2>)), metadata={'circuit_metadata': {}}), SamplerPubResult(data=DataBin(meas=BitArray(<shape=(), num_shots=4092, num_bits=2>)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([DoubleSliceSpan(<start='2025-03-11 19:34:53', stop='2025-03-11 19:34:56', size=8184>)])}, 'version': 2})

We can plot the results, just as before:

#+begin_src python :session bellcirc :results output :exports both
  for idx in range(2):
      print(results_qpu[idx].data.meas.get_counts())
#+end_src

#+RESULTS:
: {'00': 1961, '11': 2065, '01': 36, '10': 30}
: {'10': 2058, '01': 1964, '00': 22, '11': 48}

Indeed, we can print our results, but it is much nicer to plot them using a
histogram.

Unlike in the simulation, which was noise-free, we now have noise. Bell circuit
0 should not produce states \(\left| 01 \right \rangle\) nor
\(\left| 10 \right \rangle\), yet, they are listed in the measurement results,
indicating that they have a non-zero probability of occurring. Similarly,
circuit 1 should not produce \(\left| 00 \right \rangle\) nor
\(\left| 11 \right \rangle\).

For a better comparison between our noise-free simulation and QPU results, we
plot the counts on the same histogram. We can do this using the
~plot_histogram()~ method if we provide a list the counts we want to appear on
the same plot:
#+begin_src python :eval never

  for idx in range(2):
      print(f'Bell circuit {idx}')
      display(plot_histogram([results_sim[idx].data.meas.get_counts()),
                             results_qpu[idx].data.meas.get_counts())])
#+end_src

#+begin_src python :session bellcirc :results output :exports none
  legend_data = ['Noise-free Sim.', 'QPU']

  for idx in range(2):
      fname = os.path.join('html', 'img',
                           f'bell_ckt_results{idx:02d}_compare.png')

      print(f'\nBell circuit {idx}:')
      plot_histogram([results_sim[idx].data.meas.get_counts(),
                      results_qpu[idx].data.meas.get_counts()],
                     legend=legend_data,
                     figsize=(12,6),
                     filename=fname)

      orgfig(fname[5:])
#+end_src

#+RESULTS:
#+begin_example

Bell circuit 0:

,#+name: fig:defaultName
,#+attr_html: :width 480px
,#+caption: Default caption.
[[./img/bell_ckt_results00_compare.png]]

Bell circuit 1:

,#+name: fig:defaultName
,#+attr_html: :width 480px
,#+caption: Default caption.
[[./img/bell_ckt_results01_compare.png]]
#+end_example

#+name: fig:SampleBellCkt0-comparison
#+attr_html: :width 480px
#+caption: QPU results are compared with noise-free simulation results for Bell circuit 0.
[[./img/bell_ckt_results00_compare.png]]

Bell circuit 1:

#+name: fig:SampleBellCkt1-comparison
#+attr_html: :width 480px
#+caption: QPU results are compared with noise-free simulation results for Bell circuit 1.
[[./img/bell_ckt_results01_compare.png]]


* Qiskit IBM Runtime Primitives

** Helper Function: =orgfig=                                      :noexport:
#+begin_src python :results output :session IBMrun :exports both
  def orgfig( fname, width=480 ):

      print(f'\n#+name: fig:defaultName')
      print(f'#+attr_html: :width {width}px')
      print(f'#+caption: Default caption.')
      print(f'[[./{fname}]]')
#+end_src

#+RESULTS:


** Imports

#+begin_src python :results output :session IBMrun :exports both
  from math import pi as π

  from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
  from qiskit.circuit import Parameter
  from qiskit.quantum_info import SparsePauliOp
  from qiskit.visualization import plot_distribution
  from qiskit_aer import AerSimulator
  from qiskit_ibm_runtime import SamplerV2, EstimatorV2, QiskitRuntimeService
#+end_src

** Load a Personal IBM Token
- You need a personal IBM token to access the hardware.
- There are several ways to do this.
- The first thing, however, is to get a personal IBM Quantum token
*** Getting Your IBM Quantum Token
1. If you don't already have one, use your university e-mail account
   (prefferable) to register for an account.
2. Once logged in, you can get your IBM token in one of two ways:
   1. Visit your [[https://quantum.ibm.com][IBM Quantum Platform dashboard]]
      1. In the upper right, you'll see a box where you can view or copy your
         IBM Quantum API token
         #+attr_html: :width 360px
         [[./img/IBMQuantumDashboard.png]]
   2. Click the "Account" button (it looks like an anonymized profile pic). This
      brings up your /Profile Settings/
      #+attr_html: :width 360px
      [[./img/IBMQuantumAccountIcon.png]]
      1. Below the /Profile Details/ is an /API Token/. Click the icon that allows
         you to copy you IBM Quantum API token. You will paste this information
         elsewhere later.
         

      
*** The [[https://docs.python.org/3/library/getpass.html][getpass]] Package
- This is a nice Python package that is useful in Jupyter notebooks
- It allows you to prompt the user for a password that can be used later in the file.
- The basic usage is:
  #+begin_src python :eval never
    import getpass # this comes with standard Python

    # This interactively prompts the user for their password
    token = getpass.getpass('Enter your password: ')
  #+end_src
- You can then use =token= in an API call
- This allows you to share Jupyter notebooks /without/ also sharing your
  password/token/API key.

*** Acessing IBM Quantum Harware Using Your Token
- Once you have a variable =token= that contains your API key, you can
  leverage the =QiskitRuntimeService.save_account()= to save the token your
  computer for future use:
  #+begin_src python :eval never
    QiskitRuntimeService.save_account(
        channel="ibm_quantum",
        token=token,
        overwrite=True,
        set_as_default=True)
  #+end_src
We can then put it all together in the following way:
1. Check your computer to see if there's a saved IBM quantum token.
   1. If yes, use it
   2. If not, prompt the user for the token
      1. In this case, we replace the variable =token= with a call to
         =getpass.getpass()=, which effectively supplies the token to
         =QiskitRuntimeService()=
#+begin_src python :results output :session IBMrun :exports both
  try:
      # Load any previously-saved IBM Quantum tokens
      QiskitRuntimeService.saved_accounts()
      print("Found and loaded a previously-saved IBM Quantum API token.")
  except:
      # Otherwise, prompt user for token
      QiskitRuntimeService.save_account(
      channel="ibm_quantum",
      token=getpass.getpass("No token found. Enter your IBM Quantum API token: "),
      overwrite=True,
      set_as_default=True)

      print("Account saved successfully!")
#+end_src

#+RESULTS:
: Found and loaded a previously-saved IBM Quantum API token.


*** My Approach (not recommended)
- I use this approach because I sometimes run Python code /outside/ of a Jupyter
  notebook, so I don't have an opportunity to dynamically input my password
  using =getpass=
- My approach was to save a file on my computer, say, =~/.IBMQpass=
  - This is a text file containing only my IBM Quantum token
- Then, I can load the token in a variable called =token= using code like this:
  #+begin_src python :results output :session IBMrun :exports both
    import os
    from datetime import datetime

    # Read the token from a secure file
    # Expand the '~' to the full path
    file_path = os.path.expanduser("~/.IBMQpass")
    with open(file_path, "r") as file:
        token = file.read().strip()

    print('\nLoaded IBM Quantum token: {0}'.format(datetime.now()))
  #+end_src

** Establish a Connection
- To interface with the IBM cloud resources, we establish as
  =QiskitRuntimeService= object, =service=
  #+begin_src python :results output :session IBMrun :exports both
    service = QiskitRuntimeService(channel='ibm_quantum')
  #+end_src

  #+RESULTS:

- We can then use the =service= object to query available QPUs
  #+begin_src python :results output :session IBMrun :exports both
    print(service.backends())
    # in Jupyter notebook, you don't need print() ... just use
    # service.backends() as the last command in your cell.
  #+end_src

  #+RESULTS:
  : [<IBMBackend('ibm_brisbane')>, <IBMBackend('ibm_kyiv')>, <IBMBackend('ibm_sherbrooke')>]

- This is a list of objects of the [[https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend][IBMBackend]] class
  - We can ask for the least-busy backend using the =.least_busy()= method:
    #+begin_src python :results output :session IBMrun :exports both
      # save the least-busy backend as backend
      backend = service.least_busy()

      print(backend)
    #+end_src

    #+RESULTS:
    : <IBMBackend('ibm_brisbane')>

- We can get information about a backend using properties such as =.name=,
  =.version=, and =.num_qubits=:
  #+begin_src python :results output :session IBMrun :exports both
    print(
        f"Name: {backend.name}\n"
        f"Version: {backend.version}\n"
        f"No. of qubits: {backend.num_qubits}\n"
    )
  #+end_src

  #+RESULTS:
  : Name: ibm_brisbane
  : Version: 2
  : No. of qubits: 127
- A backend has more attributes, which we can uncover if we use the ~.__dict__~
  property:
  #+begin_src python :results output :session IBMrun :exports both
    print(backend.__dict__)
  #+end_src

  #+RESULTS:
  : {'_options': Options(shots=4000, memory=False, meas_level=<MeasLevel.CLASSIFIED: 2>, meas_return=<MeasReturnType.AVERAGE: 'avg'>, memory_slots=None, memory_slot_size=100, rep_time=None, rep_delay=None, init_qubits=True, use_measure_esp=None, use_fractional_gates=False, noise_model=None, seed_simulator=None), '_provider': None, 'name': 'ibm_brisbane', 'description': None, 'online_date': datetime.datetime(2023, 1, 23, 5, 0, tzinfo=tzutc()), 'backend_version': '1.1.66', '_coupling_map': None, '_instance': 'ibm-q/open/main', '_service': <QiskitRuntimeService>, '_api_client': <qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x122bed850>, '_configuration': <qiskit_ibm_runtime.models.backend_configuration.PulseBackendConfiguration object at 0x122915f90>, '_properties': <qiskit_ibm_runtime.models.backend_properties.BackendProperties object at 0x126f1a9d0>, '_defaults': <qiskit_ibm_runtime.models.pulse_defaults.PulseDefaults object at 0x126ccbdd0>, '_target': <qiskit.transpiler.target.Target object at 0x1206080a0>, '_max_circuits': 300, '_session': None}
** Define Sampler Instances
- We will create backends so we can compare a simulation using =AerSimulator()=
  against a calculation on actual quantum hardware
  #+begin_src python :results output :session IBMrun :exports both
    backend_aer = AerSimulator() # simulator backend
    backend_qpu = backend # hardware backend

    print(type(backend_aer))
    print(type(backend_qpu))
  #+end_src

  #+RESULTS:
  : <class 'qiskit_aer.backends.aer_simulator.AerSimulator'>
  : <class 'qiskit_ibm_runtime.ibm_backend.IBMBackend'>

- We now use the backends to define samplers
  #+begin_src python :results output :session IBMrun :exports both
    sampler_aer = SamplerV2(backend_aer) # sampler for simulator
    sampler_qpu = SamplerV2(backend_qpu) # sampler for QPU

    print(type(sampler_aer))
    print(type(sampler_qpu))
  #+end_src

  #+RESULTS:
  : <class 'qiskit_ibm_runtime.sampler.SamplerV2'>
  : <class 'qiskit_ibm_runtime.sampler.SamplerV2'>

** Create Some Circuits
#+begin_src python :results output :session IBMrun :exports both
  qc1 = QuantumCircuit(1)
  qc1.h(0)
  qc1.measure_all()
  qc1.draw()
#+end_src

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports none
  fname = os.path.join('html', 'img', 'simQPUckt1.png')
  qc1.draw(filename=fname)

  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/simQPUckt1.png]]

#+name: fig:simQPUckt1
#+attr_html: :width 480px
#+caption: This circuit is designed for simulation and implementation on actual IBM quantum hardware.
[[./img/simQPUckt.png]]

- A parametrized circuit is create as a second circuit to test
#+begin_src python :results output :session IBMrun :exports both
  θ = Parameter('θ')
  ϕ = Parameter('ϕ')

  qr = QuantumRegister(2, name='q')

  cr = ClassicalRegister(2, name='SomeName')

  qc2 = QuantumCircuit( qr, cr )
  qc2.rx(θ,1)
  qc2.cry(ϕ,1,0)
  qc2.measure(qr, cr)
  qc2.draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports none
  fname = os.path.join('html', 'img', 'simQPUckt2.png')
  qc2.draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/simQPUckt2.png]]

#+name: fig:simQPUckt2
#+attr_html: :width 480px
#+caption: This parameterized circuit provides a second circuit to compare in simulation and on actual hardware.
[[./img/simQPUckt2.png]]

- Next, we define angles for use with circuit 2:
  #+begin_src python :results output :session IBMrun :exports both
    angles = [[π/4, π/2], [π/3, π], [π/2, π]]
  #+end_src

  #+RESULTS:
  - The there are three sets of parameters
  - Each set has two angles, one for each parameter

** Transpile the Circuits

*** Circuit 1 (Aer)
- We transpile the circuit of Figure [[fig:simQPUckt1]] for the =AerSimulator=
#+begin_src python :results output :session IBMrun :exports both
  qc1_aer = transpile( qc1, backend=backend_aer)
  qc1_aer.draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports none
  fname = os.path.join('html', 'img', 'simQPUckt1trans_aer.png')
  qc1_aer.draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: The circuit of Figure [[fig:simQPUckt1]] is transpiled for the =AerSimulator=.
: [[./img/simQPUckt1trans_aer.png]]

#+attr_html: :width 480px
#+caption: The circuit of Figure [[fig:simQPUckt1]] is transpiled for the =AerSimulator=.
[[./img/simQPUckt1trans_aer.png]]

*** Circuit 2 (Aer)
- We transpile the circuit of Figure [[fig:simQPUckt2]] for the =AerSimulator=
#+begin_src python :results output :session IBMrun :exports both
  qc2_aer = transpile( qc2, backend=backend_aer)
  qc2_aer.draw(reverse_bits=True)
#+end_src

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports none
  fname = os.path.join('html', 'img', 'simQPUckt2trans_aer.png')
  qc2_aer.draw(reverse_bits=True, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: /Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit/visualization/circuit/matplotlib.py:278: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`). Consider using `matplotlib.pyplot.close()`.
:   mpl_figure = plt.figure()
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/simQPUckt2trans_aer.png]]

#+name: fig:ckt2_trans_aer
#+attr_html: :width 480px
#+caption: The circuit of Figure [[fig:simQPUckt2]] is transpiled for the =AerSimulator=.
[[./img/simQPUckt2trans_aer.png]]


- We also transpile and optimize the circuit =qc2=
  - To do this, we use the =generate_preset_pass_manager= function
    #+begin_src python :results output :session IBMrun :exports both
      from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

      target = backend_aer.target
      pm = generate_preset_pass_manager(target=target, optimization_level=1)
      qc2_aer = pm.run(qc2)
      qc2_aer.draw( reverse_bits=True )
    #+end_src

    #+RESULTS:

    #+begin_src python :results output :session IBMrun :exports none
      fname = os.path.join('html', 'img', 'simQPUckt2trans_aer_pm.png')
      qc2_aer.draw(reverse_bits=True, filename=fname)
      orgfig( fname[5:] )
    #+end_src

    #+RESULTS:
    : 
    : #+name: fig:defaultName
    : #+attr_html: :width 480px
    : #+caption: Default caption.
    : [[./img/simQPUckt2trans_aer_pm.png]]

    #+name: fig:ckt2_trans_aer_pm
    #+attr_html: :width 480px
    #+caption: Here, the circuit of Figure [[fig:simQPUckt2]] is transpiled using a pass manager. It is the same as the result in Figure [[fig:ckt2_trans_aer]].
    [[./img/simQPUckt2trans_aer_pm.png]]

*** Circuit 1 (QPU)
- We transpile the circuit of Figure [[fig:simQPUckt1]] for the quantum hardware
- Since the hardware has many more qubits than the circuit, we use
  ~idle_wires=False~ to suppress the display of idle qubits when we use the
  =.draw()= method
#+begin_src python :results output :session IBMrun :exports both
  qc1_qpu = transpile( qc1, backend=backend_qpu)
  qc1_qpu.draw(reverse_bits=True, idle_wires=False )
#+end_src

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports none
  fname = os.path.join('html', 'img', 'simQPUckt1trans_qpu.png')
  qc1_qpu.draw(reverse_bits=True, idle_wires=False, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/simQPUckt1trans_qpu.png]]

#+name: fig:simQPUckt1_trans_qpu
#+attr_html: :width 480px
#+caption: The circuit of Figure [[fig:simQPUckt1]] is transpiled for the quantum hardware.
[[./img/simQPUckt1trans_qpu.png]]
*** Circuit 2 (QPU)
- We transpile the circuit of Figure [[fig:simQPUckt2]] for the quantum hardware
#+begin_src python :results output :session IBMrun :exports both
  target = backend_qpu.target
  pm = generate_preset_pass_manager(target=target, optimization_level=1)
  qc2_qpu = pm.run(qc2)
  qc2_qpu.draw(reverse_bits=True, idle_wires=False )
#+end_src

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports none
  fname = os.path.join('html', 'img', 'simQPUckt2trans_qpu.png')
  qc2_qpu.draw(reverse_bits=True, idle_wires=False, filename=fname)
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/simQPUckt2trans_qpu.png]]

#+name: fig:ckt2_trans_qpu
#+attr_html: :width 480px
#+caption: The circuit of Figure [[fig:simQPUckt2]] is transpiled for the quantum hardware.
[[./img/simQPUckt2trans_qpu.png]]
** Simulate the Circuits
- The sampler =.run()= method triggers the simulation
*** Simulate on the Aer Sampler
#+begin_src python :results output :session IBMrun :exports both
  job_aer = sampler_aer.run( [ (qc1_aer, None, 100), (qc2_aer, angles, 1000) ] )

  # Print is not needed in Jupyter Lab
  print(job_aer.__dict__)
#+end_src

#+RESULTS:
: {'_job_id': '9288fdc7-7e26-40d7-b919-d32ca46a577a', 'metadata': {}, '_future': <Future at 0x145e6e6d0 state=running>, '_function': <bound method BackendSamplerV2._run of <qiskit.primitives.backend_sampler_v2.BackendSamplerV2 object at 0x14581b4d0>>, '_args': ([SamplerPub(<()>), SamplerPub(<(3,)>)],), '_kwargs': {}}

*** Run on Quantum Hardware
#+begin_src python :results output :session IBMrun :exports both
  job_qpu = sampler_qpu.run( [ (qc1_qpu, None, 100), (qc2_qpu, angles, 1000) ] )

  # Print is not needed in Jupyter Lab
  print(job_qpu)
#+end_src

#+RESULTS:
: /Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 625.82641167829 quantum seconds, but you only have 565 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
:   warnings.warn(warning_message)
: <RuntimeJobV2('cya60g201rbg008jq0v0', 'sampler')>

- Once your job is sumbitted, it IBM Quantum will assign it a unique job
  ID.
- Let's see what information is embedded in the job_qpu object:
#+begin_src python :results output :session IBMrun :exports both
  print(job_qpu.__dict__)
#+end_src

#+RESULTS:
: {'_job_id': 'cya60g201rbg008jq0v0', 'metadata': {}, '_backend': <IBMBackend('ibm_brisbane')>, '_api_client': <qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x14533be50>, '_interim_results': None, '_creation_date': None, '_program_id': 'sampler', '_reason': None, '_reason_code': None, '_error_message': None, '_image': None, '_final_interim_results': False, '_service': <QiskitRuntimeService>, '_session_id': None, '_tags': None, '_usage_estimation': {}, '_version': 2, '_queue_info': None, '_user_callback': None, '_status': 'INITIALIZING', '_interim_result_decoder': <class 'qiskit_ibm_runtime.utils.result_decoder.ResultDecoder'>, '_final_result_decoder': <class 'qiskit_ibm_runtime.utils.sampler_result_decoder.SamplerResultDecoder'>, '_ws_client_future': None, '_result_queue': <queue.Queue object at 0x1401a57d0>, '_ws_client': <qiskit_ibm_runtime.api.clients.runtime_ws.RuntimeWebsocketClient object at 0x1404550d0>}
- We can obtain using the .job_id() method.
#+begin_src python :results output :session IBMrun :exports both
  job_id = job_qpu.job_id()
  print(f"Your job's identifier is: {job_id}")
#+end_src

#+RESULTS:
: Your job's identifier is: cya60g201rbg008jq0v0

- As long as our Juptyer Lab notebook is open, we can access our job through the
  ~job_id~ object using the =result()= method:
  #+begin_src python :results output :session IBMrun :exports both
    result_qpu = job_qpu.result()
    print(result_qpu)
  #+end_src

  #+RESULTS:
  : PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(<shape=(), num_shots=100, num_bits=1>)), metadata={'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(<shape=(3,), num_shots=1000, num_bits=2>), shape=(3,)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([SliceSpan(<start='2025-01-25 03:53:39', stop='2025-01-25 03:53:54', size=100>), SliceSpan(<start='2025-01-25 03:53:39', stop='2025-01-25 03:53:52', size=3000>)])}, 'version': 2})
  
- If we shut down our Jupyter Lab notebook, we clear the memory, and the information stored in job_id is lost.
- The job ID is important because we can retrieve the results from IBM using
  this ID.
- Thus, it may be helpful to record the job ID somewhere. As a fallback, we can
  always go to the IBM Quantum portal and then find the job.  
*** Get Results from the =AerSampler=
- View results:
  #+begin_src python :results output :session IBMrun :exports both
    result_aer = job_aer.result()
    print(result_aer)
  #+end_src  

  #+RESULTS:
  : PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(<shape=(), num_shots=100, num_bits=1>)), metadata={'shots': 100, 'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(<shape=(3,), num_shots=1000, num_bits=2>), shape=(3,)), metadata={'shots': 1000, 'circuit_metadata': {}})], metadata={'version': 2})

- We retrieve the counts from the Aer sampler results:
  #+begin_src python :results output :session IBMrun :exports both
    counts_qc1_aer = result_aer[0].data.meas.get_counts()
    print(counts_qc1_aer)
  #+end_src    

  #+RESULTS:
  : {'0': 56, '1': 44}
  
*** Comparing Simulation and QPU Results

- When comparing results, it's usually a great idea to make a visualization
  #+begin_src python :results output :session IBMrun :exports both
    fig = plot_distribution([counts_qc1_aer, counts_qc1_qpu],
                            legend=['Simulator', 'QPU'])
  #+end_src

  #+RESULTS:
  : Saved figure

  #+begin_src python :results output :session IBMrun :exports none
    import matplotlib.pyplot as plt
    fname = os.path.join( 'html', 'img', 'compareCountsAerQPU.png')
    plt.tight_layout()
    fig.savefig(fname)
    orgfig(fname[5:])
  #+end_src

  #+RESULTS:
  : 
  : #+name: fig:defaultName
  : #+attr_html: :width 480px
  : #+caption: Default caption.
  : [[./img/compareCountsAerQPU.png]]

  #+name: fig:compareAerQPUcounts
  #+attr_html: :width 620px
  #+caption: Counts from the QPU are compared against those from the Aer simulator for circuit 1.
  [[./img/compareCountsAerQPU.png]]

** Simulation vs QPU: Estimator
- Estimators get us not counts, but expectation values for observables.
*** Defining Estimator Objects
- Define Aer and QPU estimators:
  #+begin_src python :results output :session IBMrun :exports both
    estimator_aer = EstimatorV2( backend_aer )
    estimator_qpu = EstimatorV2( backend_qpu )
  #+end_src

  #+RESULTS:
*** Defining Observable Operators
- We also need observable(s) to supply for the estimators:
  #+begin_src python :results output :session IBMrun :exports both
    obsv_list = [[SparsePauliOp(["XX", "IY"], [0.5, 0.5])],
                 [SparsePauliOp(["XX"], [1])],
                 [SparsePauliOp(["IY"], [1])]]
  #+end_src

  #+RESULTS:

*** Layout Mapping
- This observable must be mapped to the circuit of interest.
  - This is important because the hardware may have many more (idle) qubits than
    our circuit does.
  #+begin_src python :results output :session IBMrun :exports both
    layout = qc2_qpu.layout 

    print(type(layout))

    obsv_qpu = []

    for obsv in obsv_list:
        obsv_temp = obsv[0].apply_layout(layout)
        print(obsv_temp)
        obsv_qpu.append([obsv_temp])
  #+end_src    

  #+RESULTS:
  : <class 'qiskit.transpiler.layout.TranspileLayout'>
  : SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
  :               coeffs=[0.5+0.j, 0.5+0.j])
  : SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX'],
  :               coeffs=[1.+0.j])
  : SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
  :               coeffs=[1.+0.j])
- The simulated estimator does *not* need the modified observables, and we will run
  only one circuit
  
*** Simulation
#+begin_src python :results output :session IBMrun :exports both
  job2_aer = estimator_aer.run([(qc2_aer, obsv_list, angles, 0.01)])
#+end_src    

#+RESULTS:

*** QPU Submission

#+name: lst:QPUEstimator
#+begin_src python :results output :session IBMrun :exports both
  # If you've never submitted the job before, set job2_id to None
  # job2_id = None
  job2_id = 'cya6t20nrmz000862cs0'

  if job2_id is None:
      job2_qpu = estimator_qpu.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
      print( 'Submitted new job with id: {0}'.format(job2_qpu.job_id()) )
  else:
      # Loads by ID a pre-existing job from IBM Quantum 
      job2_gpu = QiskitRuntimeService().job(job2_id)
      print( 'Loaded old job with id: {0}'.format(job2_qpu.job_id()) )
#+end_src    

#+RESULTS:
: /Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 647.0957899365619 quantum seconds, but you only have 546 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
:   warnings.warn(warning_message)
: Submitted new job with id: cya6t20nrmz000862cs0


#+begin_src python :results output :session IBMrun :exports both
  print(job2_qpu)
  print( 'Job id: {0}'.format(job2_qpu.job_id()) )
  print( 'Status: {0}'.format(job2_qpu.status()) )

  if job2_qpu.status() == 'DONE':
      print(job2_qpu.metrics())
#+end_src    

#+RESULTS:
: <RuntimeJobV2('cya6t20nrmz000862cs0', 'estimator')>
: Job id: cya6t20nrmz000862cs0
: Status: DONE
: {'bss': {'seconds': 18}, 'usage': {'quantum_seconds': 18, 'seconds': 18}, 'timestamps': {'created': '2025-01-25T04:48:08.442Z', 'finished': '2025-01-25T04:48:43.251Z', 'running': '2025-01-25T04:48:11.227Z'}, 'executions': 62144, 'num_circuits': 224, 'num_qubits': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127], 'circuit_depths': [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23], 'qiskit_version': 'qiskit_ibm_runtime-0.33.2,qiskit-1.3.1*,qiskit_aer-0.16.0*', 'estimated_start_time': '2025-01-25T04:48:09.875Z', 'estimated_completion_time': '2025-01-25T04:48:27.875Z', 'position_in_queue': None, 'position_in_provider': None}

- My job submission showed a job ID of =cya6t20nrmz000862cs0=
  - If we want to shut down or Jupyter notebook, we need to record this job number
  - Additionally, we want to go back to Listing [[lst:QPUEstimator]] and comment out
    ~job2_id = None~, and uncomment ~job2_id = 'cya6t20nrmz000862cs0'~
    - This will prevent us from running a redundant job, and rather let us use
      the results already calculated
*** Retrieve Estimator Results
- We get the expectation values by indexing the result and using the =.data.evs=
  member data
#+begin_src python :results output :session IBMrun :exports both
  exp_vals_aer = job2_aer.result()[0].data.evs
  print(exp_vals_aer)
  print(angles)
#+end_src    

#+RESULTS:
: [[-0.0055 -0.0028  0.0034]
:  [-0.0104 -0.0038  0.0082]
:  [-0.0006 -0.0018 -0.0014]]
: [[0.7853981633974483, 1.5707963267948966], [1.0471975511965976, 3.141592653589793], [1.5707963267948966, 3.141592653589793]]

The above list of list contains the expectation values.
- There are three sublists, each corresponding to one of the three different
  parameter sets.
- Each sublist is a set of three expectation values corresponding to the three
  observables in =obs_qpu=.
** Three Runtime Execution Methods
1. Job. Send a list of Pubs, receive PUB results
2. Session. This is good for hybrid algorithms, such VQE and VAOA. Iterations of
   these algorithms depend on one another. Classical processing is done in the
   cloud. 
3. Batch. A series of independent jobs may be executed in parallel.
*** Sessions
We use context managers, soemthing like this:
#+begin_src python :exports both :eval never
  from qiskit_ibm_runtime import Session
  from qiskit_ibm_runtime.fake_provider import Fake

  obsv_qpu = [[obsv[0].apply_laout(qc2_qpu.layout) for obsv in obsv_list]
  print(obsv_qpu)

  with Session(backend=backend_man) as session
      # Submit a request to the Sampler primitive within the session
      sampler = SamplerV2(session=session)
      job = sampler.run([(qc2_qpu, angles, 1000)])
      pub_result = job.result()[0]
      print(f'1st Circuit Counts: \n {pub_result.data.SomeName.get_counts(0)} \n')

      # Submit a request to the Estimator primitive within the session
      estimator = EstimatorV2(session=session)
      job = estimator.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
      pub_result = job.result()[0]
      print(f'Expectation values: \n {pub_result.data.evs}')        
#+end_src    
**** Session on a Fake Backend
#+begin_src python :results output :session IBMrun :exports both
  from qiskit_ibm_runtime import Session
  from qiskit_ibm_runtime.fake_provider import FakeManilaV2
#+end_src    

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports both
  backend_fake = FakeManilaV2()
  sampler_fake = SamplerV2( backend_fake )
#+end_src    

#+RESULTS:

**** Transpile Circuit for =FakeManilaV2=
#+begin_src python :results output :session IBMrun :exports both
  qc2_fake = transpile(qc2, backend=backend_fake)
  qc2_fake.draw()
#+end_src

#+RESULTS:

#+begin_src python :results output :session IBMrun :exports none
  fname = os.path.join('html', 'img', 'fakeManillaCkt.png')
  qc2_fake.draw( filename=fname )
  orgfig( fname[5:] )
#+end_src

#+RESULTS:
: 
: #+name: fig:defaultName
: #+attr_html: :width 480px
: #+caption: Default caption.
: [[./img/fakeManillaCkt.png]]

#+name: fig:qc2_fake_ManillaV2_draw
#+attr_html: :width 680px
#+caption: A circuit is transpiled for simulation on the =FakeManilaV2= backend.
[[./img/fakeManillaCkt.png]]

**** Layout Mapping for Observable
#+begin_src python :results output :session IBMrun :exports both
  obsv_fake = [[obsv[0].apply_layout(qc2_fake.layout) for obsv in obsv_list]]
  print(obsv_fake)
#+end_src    

#+RESULTS:
: [[SparsePauliOp(['XXIII', 'YIIII'],
:               coeffs=[0.5+0.j, 0.5+0.j]), SparsePauliOp(['XXIII'],
:               coeffs=[1.+0.j]), SparsePauliOp(['YIIII'],
:               coeffs=[1.+0.j])]]


**** Run a Session
#+begin_src python :results output :session IBMrun :exports both
  with Session(backend=backend_fake) as session:
      # Submit a request to the Sampler primitive within the session
      sampler = SamplerV2(session)
      job = sampler.run([(qc2_fake, angles, 1000)])
      pub_result = job.result()[0]
      print(f'1st Circuit Counts: \n {pub_result.data.SomeName.get_counts(0)} \n')

      # Submit a request to the Estimator primitive within the session
      estimator = EstimatorV2(session)
      job = estimator.run([(qc2_fake, obsv_fake, angles, 0.01)])
      pub_result = job.result()[0]
      print(f'Expectation values: \n {pub_result.data.evs}')
#+end_src    

#+RESULTS:
: 1st Circuit Counts: 
:  {'10': 72, '00': 854, '11': 62, '01': 12} 
: 
: Expectation values: 
:  [[ 0.0097 -0.0074  0.022 ]]
