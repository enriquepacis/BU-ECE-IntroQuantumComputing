<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-02-26 Wed 22:22 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Qiskit + IBM: Simulation and Calculation</title>
<meta name="author" content="Dr. E.P. Blair" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Qiskit + IBM: Simulation and Calculation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#qinfoOverview">1. Overview</a></li>
<li><a href="#qinfoModule">2. The <code>quantum_info</code> Module</a>
<ul>
<li><a href="#org04bea4c">2.1. Overview</a></li>
<li><a href="#org0b380dc">2.2. Make a Quantum Circuit</a></li>
<li><a href="#org7402e20">2.3. Get an Output <code>Statevector()</code> Object</a></li>
<li><a href="#orga4f68b9">2.4. Measurement Probabilities</a></li>
<li><a href="#org2d0792c">2.5. Simulated Experiments</a>
<ul>
<li><a href="#org9f50f2e">2.5.1. Measurement Outcomes for Each Shot</a></li>
<li><a href="#org1a5bd62">2.5.2. Cumulative Results over an Ensemble</a></li>
<li><a href="#orgc2f68d9">2.5.3. Expectation Values</a></li>
<li><a href="#orgcd5ba1d">2.5.4. Bloch Vectors</a></li>
<li><a href="#orgfdd3cef">2.5.5. Density Matrices</a></li>
</ul>
</li>
<li><a href="#org3716919">2.6. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:BasicSimulator">3. The <code>BasicSimulator</code> Class</a>
<ul>
<li><a href="#org1ea332c">3.1. Build a Circuit</a></li>
<li><a href="#org223250a">3.2. Simulating the Circuit</a></li>
<li><a href="#org65ea726">3.3. Getting the Results</a>
<ul>
<li><a href="#org2daec8d">3.3.1. Simulation Counts</a></li>
<li><a href="#org1c5460d">3.3.2. Visualizing the Results</a></li>
<li><a href="#org19fdad0">3.3.3. Inspecting Results from Individual Measurements</a></li>
</ul>
</li>
<li><a href="#org527da66">3.4. Handling Complex Circuits</a>
<ul>
<li><a href="#org2d20d98">3.4.1. Transpilation</a></li>
</ul>
</li>
<li><a href="#org24facf5">3.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:QiskitAerSimulator">4. The <code>qiskit_aer.AerSimulator</code> Class</a>
<ul>
<li><a href="#orge3914e2">4.1. Overview</a></li>
<li><a href="#org0aba2f2">4.2. Imports</a></li>
<li><a href="#org393a6e2">4.3. Build a Circuit</a></li>
<li><a href="#org660a33f">4.4. Run the <code>AerSimulator()</code></a></li>
<li><a href="#org267d81d">4.5. Example 2: Circuit with Statevector in Middle of Circuit</a>
<ul>
<li><a href="#orgdd0eab1">4.5.1. Transpile and Run the Circuit</a></li>
</ul>
</li>
<li><a href="#org5f1b342">4.6. Efficient Simulation</a>
<ul>
<li><a href="#orgfe94e66">4.6.1. Build a Circuit</a></li>
<li><a href="#orgb163937">4.6.2. Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></a></li>
</ul>
</li>
<li><a href="#orgfb558e4">4.7. Simulation Methods</a>
<ul>
<li><a href="#org15fde6d">4.7.1. Build a Large Circuit</a></li>
<li><a href="#orgbeb0436">4.7.2. Run and Time the Simulation</a></li>
</ul>
</li>
<li><a href="#org59a6349">4.8. Noisy Simulation</a>
<ul>
<li><a href="#org2a970cd">4.8.1. Build a Circuit</a></li>
<li><a href="#orgf542de9">4.8.2. Ideal Result</a></li>
<li><a href="#orged41a36">4.8.3. Noisy Result</a></li>
<li><a href="#org0d8138b">4.8.4. Compare Ideal Result and Noisy Result</a></li>
</ul>
</li>
<li><a href="#org2597734">4.9. Summary</a></li>
</ul>
</li>
<li><a href="#org5daebd2">5. Qiskit Primitives</a>
<ul>
<li><a href="#orge12187d">5.1. Overview</a></li>
<li><a href="#orgf30692b">5.2. Primitives</a>
<ul>
<li><a href="#org91dc777">5.2.1. Imports</a></li>
<li><a href="#org2bf5a7d">5.2.2. Build a Circuit</a></li>
<li><a href="#orgf4de50a">5.2.3. Run Simulations</a></li>
<li><a href="#orgd405098">5.2.4. Extracting Results</a></li>
</ul>
</li>
<li><a href="#orgf3c7e12">5.3. Example: A Parametrized Circuit</a>
<ul>
<li><a href="#orgfbf70b8">5.3.1. <code>BasicSimulator</code> Usage</a></li>
<li><a href="#orgdddf42d">5.3.2. <code>StatevectorSampler</code> Usage</a></li>
<li><a href="#org8d3e26a">5.3.3. <code>StatevectorSampler</code> Usage with Multiple PUBs</a></li>
</ul>
</li>
<li><a href="#org2788cfc">5.4. The Estimator Primitive</a>
<ul>
<li><a href="#org5a2a121">5.4.1. Observables</a></li>
<li><a href="#org8b8c157">5.4.2. Run the Estimator</a></li>
<li><a href="#orgb555de1">5.4.3. Extract Expectation Values</a></li>
</ul>
</li>
<li><a href="#orga3d66b9">5.5. Qiskit Estimator Example</a>
<ul>
<li><a href="#org2c14b9d">5.5.1. Build an Operator</a></li>
<li><a href="#org3d4b52e">5.5.2. Instantiate a <code>StatevectorEstimator</code></a></li>
<li><a href="#org8fa308f">5.5.3. Transpile the Circuit</a></li>
<li><a href="#org954510f">5.5.4. Run the Estimator</a></li>
<li><a href="#org9ad00d8">5.5.5. Extract Results</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6292670">6. <code>qiskit_aer</code> Primitives</a>
<ul>
<li><a href="#org5616e24">6.1. <code>qiskit_aer.primitives.SamplerV2</code></a>
<ul>
<li><a href="#org7e609ef">6.1.1. Example: Bell Circuits</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org307e6dc">7. Qiskit IBM Runtime Primitives</a>
<ul>
<li><a href="#org1aa2e7a">7.1. Imports</a></li>
<li><a href="#orgaf0c185">7.2. Load a Personal IBM Token</a>
<ul>
<li><a href="#org90aea99">7.2.1. Getting Your IBM Quantum Token</a></li>
<li><a href="#orgf9f986b">7.2.2. The getpass Package</a></li>
<li><a href="#org0ea72aa">7.2.3. Acessing IBM Quantum Harware Using Your Token</a></li>
<li><a href="#org9d154dd">7.2.4. My Approach (not recommended)</a></li>
</ul>
</li>
<li><a href="#org2a68cb3">7.3. Establish a Connection</a></li>
<li><a href="#org552e72d">7.4. Define Sampler Instances</a></li>
<li><a href="#org2081d73">7.5. Create Some Circuits</a></li>
<li><a href="#orge0df7b9">7.6. Transpile the Circuits</a>
<ul>
<li><a href="#org1973d9c">7.6.1. Circuit 1 (Aer)</a></li>
<li><a href="#orga618686">7.6.2. Circuit 2 (Aer)</a></li>
<li><a href="#orga04e89f">7.6.3. Circuit 1 (QPU)</a></li>
<li><a href="#orga6cca0d">7.6.4. Circuit 2 (QPU)</a></li>
</ul>
</li>
<li><a href="#orge9d2ee7">7.7. Simulate the Circuits</a>
<ul>
<li><a href="#orgffc87db">7.7.1. Simulate on the Aer Sampler</a></li>
<li><a href="#orgcd70f80">7.7.2. Run on Quantum Hardware</a></li>
<li><a href="#orgdf9d8e6">7.7.3. Get Results from the <code>AerSampler</code></a></li>
<li><a href="#org682560c">7.7.4. Comparing Simulation and QPU Results</a></li>
</ul>
</li>
<li><a href="#org56e11a2">7.8. Simulation vs QPU: Estimator</a>
<ul>
<li><a href="#org339ee76">7.8.1. Defining Estimator Objects</a></li>
<li><a href="#orgc546533">7.8.2. Defining Observable Operators</a></li>
<li><a href="#orgc41bede">7.8.3. Layout Mapping</a></li>
<li><a href="#org5be88e0">7.8.4. Simulation</a></li>
<li><a href="#org2bbf845">7.8.5. QPU Submission</a></li>
<li><a href="#orgbbb7642">7.8.6. Retrieve Estimator Results</a></li>
</ul>
</li>
<li><a href="#org79416b8">7.9. Three Runtime Execution Methods</a>
<ul>
<li><a href="#org5c61db1">7.9.1. Sessions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-qinfoOverview" class="outline-2">
<h2 id="qinfoOverview"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-qinfoOverview">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>This page focuses on quantum computing simulations or job submissions on IBM
hardware
<ul class="org-ul">
<li>There are several ways to simulate quantum computations
<ul class="org-ul">
<li>Statevector simulations</li>
<li>Using SamplerV2 or EstimatorV2</li>
</ul></li>
</ul></li>
</ul>

<p>
The general work-flow is to:
</p>
<ol class="org-ol">
<li>Create a quantum circuit</li>
<li>Decide whether to simulate it or run it on quantum hardware
<ol class="org-ol">
<li>Typically, we simulate it first</li>
<li>We want our simulation syntax to match as closely as possible to the
syntax of job submission.</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-qinfoModule" class="outline-2">
<h2 id="qinfoModule"><span class="section-number-2">2.</span> The <code>quantum_info</code> Module</h2>
<div class="outline-text-2" id="text-qinfoModule">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-org04bea4c" class="outline-3">
<h3 id="org04bea4c"><span class="section-number-3">2.1.</span> Overview</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is built into <code>qiskit</code> and provides some basic
simulations
<ul class="org-ul">
<li>This is useful when we want to understand the quantum properties of the
output of a circuit</li>
<li>It provides:
<ul class="org-ul">
<li><code>Statevector</code> simulations</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0b380dc" class="outline-3">
<h3 id="org0b380dc"><span class="section-number-3">2.2.</span> Make a Quantum Circuit</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In a Jupyter notebook we could make a cell like this:
</p>
<div class="org-src-container">
<pre class="src src-python" id="orge1bba2f"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">import</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">as</span> qi

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.x(0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a NOT gate to qubit 0</span>
qc.h([0,1]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a H to both qubits</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter notebook, you can uncomment "qc.draw()"</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">to see your circuit</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">qc.draw()</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<p>
In Jupyter Lab, your result may be displayed automatically and look like Figure
<a href="#org2723357">1</a>.
</p>

<div id="org2723357" class="figure">
<p><img src="./img/xh2.png" alt="xh2.png" width="300px" />
</p>
<p><span class="figure-number">Figure 1: </span>A simple <code>qiskit</code> quantum circuit.</p>
</div>
</div>
</div>
<div id="outline-container-org7402e20" class="outline-3">
<h3 id="org7402e20"><span class="section-number-3">2.3.</span> Get an Output <code>Statevector()</code> Object</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We can then obtain the circuit output in <code>Statevector</code> form:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#968;</span> = qi.Statevector( qc )

<span style="color: #DCDCCC; font-weight: bold;">print</span>( &#968; )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter Lab notebook, you can see the result using this:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw()</span>
</pre>
</div>

<pre class="example">
Statevector([ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],
            dims=(2, 2))
</pre>


<p>
In a Jupyter notebook, you can comment <code>print( ψ )</code> and uncomment <code>ψ.draw()</code>
to  see a result that's nicer than the one shown here. It may look like this:
</p>

\begin{equation}
\label{orgb5c2381}
\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle-
\frac{1}{2} |11\rangle
\end{equation}
</div>
</div>

<div id="outline-container-orga4f68b9" class="outline-3">
<h3 id="orga4f68b9"><span class="section-number-3">2.4.</span> Measurement Probabilities</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Once we have a <code>Statevector</code> object, we can use it to see the probabilities of
measurement, which are the modulii squared of the coefficients:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>( &#968;.probabilities() )
</pre>
</div>

<pre class="example">
[0.25 0.25 0.25 0.25]
</pre>


<p>
In this case, there are four outcomes, each with a 1/4 probability of
occurring.
</p>
</div>
</div>

<div id="outline-container-org2d0792c" class="outline-3">
<h3 id="org2d0792c"><span class="section-number-3">2.5.</span> Simulated Experiments</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Generally, a quantum computing experiment requires establishing a circuit and
performing measurements many times. Each repetition is a <b>shot</b> or a <b>trial</b>,
and a collection of shots is an <b>ensemble</b> of measurements.
</p>
</div>

<div id="outline-container-org9f50f2e" class="outline-4">
<h4 id="org9f50f2e"><span class="section-number-4">2.5.1.</span> Measurement Outcomes for Each Shot</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
We can use <code>ψ</code> to simulate circuit measurements using the <code>sample_memory()</code>
method. We specify a number of shots (trials), and we get a histogram of
samples, that is, the number of times each outcome was measured.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">samples</span> = &#968;.sample_memory( shots = 10 )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This lists the outcomes measured for each of the 10 shots</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
['01' '01' '11' '01' '00' '00' '11' '01' '01' '00']

Calculation complete at 2025-02-26 13:41:02.891472
</pre>
</div>
</div>

<div id="outline-container-org1a5bd62" class="outline-4">
<h4 id="org1a5bd62"><span class="section-number-4">2.5.2.</span> Cumulative Results over an Ensemble</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>If we don't care about each shot, but rather, we care more about aggregate
data, we can use <code>sample_counts()</code>
<ul class="org-ul">
<li>For a given number of shots, it simulates the set of measurements, returning
a frequency (number of occurrences) for each outcome measured.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = &#968;.sample_counts( shots = 1024 )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
{np.str_('00'): np.int64(247), np.str_('01'): np.int64(253), np.str_('10'): np.int64(261), np.str_('11'): np.int64(263)}

Calculation complete at 2025-02-26 13:41:11.727536
</pre>


<p>
The counts can be visualized in a histogram. In a Jupyter notebook, use the
following, but uncomment the <code>plot_histogram()</code> command:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment in Jupyter to see histogram</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_histogram( counts )</span>
</pre>
</div>

<p>
#+RESULTS
</p>
<pre class="example">
[[./img/basic_hist.png]]

Calculation complete at 2025-02-26 13:41:38.404511
</pre>



<div id="org8f1afd6" class="figure">
<p><img src="./img/basic_hist.png" alt="basic_hist.png" width="480px" />
</p>
<p><span class="figure-number">Figure 2: </span>This is a histogram of simulated measurents based on a <code>Statevector</code> output from a quantum circuit.</p>
</div>

<p>
State vector simulations get us a state vector, and we are using that state
vector object to simulate measurements.
</p>
</div>
</div>

<div id="outline-container-orgc2f68d9" class="outline-4">
<h4 id="orgc2f68d9"><span class="section-number-4">2.5.3.</span> Expectation Values</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
State vector simulations also allow us to get expectation values, as defined in
Equation \eqref{orga2c2986}
</p>
\begin{equation}
\label{orga2c2986}
\left\langle \mathbf{O} \right\rangle = \left\langle \psi \left| \mathbf{O} \right| \psi  \right\rangle 
\end{equation}

<p>
First, we form an operator:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O</span> = qi.SparsePauliOp([<span style="color: #CC9393;">'ZZ'</span>, <span style="color: #CC9393;">'XX'</span>, <span style="color: #CC9393;">'II'</span>], [0.2, -0.3, 0.4])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment this in Jupyter</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">display(O.to_operator())</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment/omit this in Jupyter</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(O.to_operator())

</pre>
</div>

<pre class="example">
Operator([[ 0.6+0.j,  0. +0.j,  0. +0.j, -0.3+0.j],
          [ 0. +0.j,  0.2+0.j, -0.3+0.j,  0. +0.j],
          [ 0. +0.j, -0.3+0.j,  0.2+0.j,  0. +0.j],
          [-0.3+0.j,  0. +0.j,  0. +0.j,  0.6+0.j]],
         input_dims=(2, 2), output_dims=(2, 2))
</pre>


<p>
Next, we supply \(\mathbf{O}\) to the <code>ψ</code> (a <code>Statevector</code> object) in its
<code>expectation_value()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O_exp</span> = &#968;.expectation_value( O )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(O_exp)
</pre>
</div>

<pre class="example">
(0.6999999999999997+0j)
</pre>
</div>
</div>

<div id="outline-container-orgcd5ba1d" class="outline-4">
<h4 id="orgcd5ba1d"><span class="section-number-4">2.5.4.</span> Bloch Vectors</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
We can ask Python to draw the Bloch vector for ψ:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Use this in Jupyter:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw('bloch')</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment this out or omit the following in Jupyter</span>
p
<span style="color: #DFAF8F;">fname</span> = os.join(<span style="color: #CC9393;">'html'</span>, <span style="color: #CC9393;">'img'</span>, <span style="color: #CC9393;">'basicBlochVect.png'</span>)
&#968;.draw(<span style="color: #CC9393;">'bloch'</span>, filename=fname)
<span style="color: #F0DFAF; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #F0DFAF; font-weight: bold;">as</span> plt
plt.savefig( fname )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'[[./</span>{fname[5:]}<span style="color: #CC9393;">]]'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">ls *.png
</pre>
</div>


<div id="orgec9614b" class="figure">
<p><img src="./img/basicBlochVect.png" alt="basicBlochVect.png" width="480px" />
</p>
<p><span class="figure-number">Figure 3: </span>Bloch vectors for the two qubits in ψ.</p>
</div>
</div>
</div>


<div id="outline-container-orgfdd3cef" class="outline-4">
<h4 id="orgfdd3cef"><span class="section-number-4">2.5.5.</span> Density Matrices</h4>
<div class="outline-text-4" id="text-2-5-5">
<p>
Similar to a <code>Statevector</code>, we can also get a <code>DensityMarix</code> from a
circuit. Recall that a density matrix \(\rho\) may be obtained from a state
vector:
</p>
\begin{equation}
\rho = \ket{\psi} \bra{\psi}
\end{equation}
</div>

<ol class="org-ol">
<li><a id="org371d454"></a>Matrix Output<br />
<div class="outline-text-5" id="text-2-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;</span> = qi.DensityMatrix( qc )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, you may use</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">display( &#961; )</span>
</pre>
</div>

<pre class="example">
DensityMatrix([[ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j],
               [ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j]],
              dims=(2, 2))
</pre>



<p>
In Jupyter, you may see output like this from the <code>display()</code> command:
</p>
\begin{equation}
\begin{bmatrix}
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\end{bmatrix}
\end{equation}
</div>
</li>



<li><a id="orgadcd8e3"></a>The City Plot<br />
<div class="outline-text-5" id="text-2-5-5-2">
<p>
In Jupyter, we can plot the elements of the density matrix:
</p>

<div id="org92019d7" class="figure">
<p><img src="./img/dmCityScape.png" alt="dmCityScape.png" width="600px" />
</p>
</div>
</div>
</li>

<li><a id="org1dbf48c"></a>Partial Trace<br />
<div class="outline-text-5" id="text-2-5-5-3">
<p>
Given a multi-qubit density matrix, we can get a reduced density matrix for any
subset of qubits.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;1</span> = qi.partial_trace( &#961;, [0] )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;1)
</pre>
</div>

<pre class="example">
DensityMatrix([[0.5+0.j, 0.5+0.j],
               [0.5+0.j, 0.5+0.j]],
              dims=(2,))
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org3716919" class="outline-3">
<h3 id="org3716919"><span class="section-number-3">2.6.</span> Conclusion</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is useful for:
<ul class="org-ul">
<li>very basic simulations</li>
<li>exploring the quantum output of a circuit</li>
</ul></li>
<li>The <code>quantum_info</code> module does not handle circuit simulations that:
<ul class="org-ul">
<li>are too large</li>
<li>involve any measurement gates</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec:BasicSimulator" class="outline-2">
<h2 id="sec:BasicSimulator"><span class="section-number-2">3.</span> The <code>BasicSimulator</code> Class</h2>
<div class="outline-text-2" id="text-sec:BasicSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>We need the <code>BasicSimulator</code> class to perform simulations for circuits that
include measurement gates</li>
</ul>
</div>
<div id="outline-container-org1ea332c" class="outline-3">
<h3 id="org1ea332c"><span class="section-number-3">3.1.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Following Diego Serrano's tutorial, I build a circuit which includes
measurement gates
<ul class="org-ul">
<li><p>
Start by importing required code
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #DFAF8F;">simulator_basic</span> = BasicSimulator()
</pre>
</div>

<ul class="org-ul">
<li>The main things we've accomplished in this code are:
<ul class="org-ul">
<li>We have imported the <code>BasicSimulator</code> class</li>
<li>We have created <code>simulator_basic</code> as a <code>BasicSimulator</code> object.</li>
</ul></li>
</ul></li>
<li><p>
Build the circuit with two quantum bits and two classical bits
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 1</span>
qc.x(0).c_if(1,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1 </span>
qc.measure(0, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 0, record its result to classical bit 0</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>

<pre class="example">
/var/folders/88/d26ncvp97zg50164_cmmlyf511m8tn/T/babel-bmQJhU/python-AGP0D6:5: DeprecationWarning: The method ``qiskit.circuit.instructionset.InstructionSet.c_if()`` is deprecated as of qiskit 1.3.0. It will be removed in 2.0.0.
  qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1
</pre></li>
</ul></li>
</ul>



<div id="org5dbd403" class="figure">
<p><img src="./img/QCwithMeas.png" alt="QCwithMeas.png" width="525px" />
</p>
<p><span class="figure-number">Figure 4: </span>This circuit has two qubits and two classical bits. The classical bits are required for measuremnt.</p>
</div>

<p>
In a Jupyter notebook, the output of <code>qc.draw()</code> will resemble Figure
<a href="#org5dbd403">4</a>.
</p>
</div>
</div>
<div id="outline-container-org223250a" class="outline-3">
<h3 id="org223250a"><span class="section-number-3">3.2.</span> Simulating the Circuit</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
To run the circuit, we use the BasicSimulator.run() method, and we supply the
desired circuit, and we can specify the number of shots for our simulation:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">The .run() method performs the simulation, and and the run is</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">saved as job</span>
<span style="color: #DFAF8F;">job</span> = simulator_basic.run( qc, shots=1024 )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(job))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.providers.basic_provider.basic_provider_job.BasicProviderJob'&gt;
</pre>

<ul class="org-ul">
<li>This <code>run()</code> method returns a <code>BasicProviderJob</code> object
<ul class="org-ul">
<li>This has a <code>result()</code> method that returns a <code>Result()</code> object contains our
simulation results</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org65ea726" class="outline-3">
<h3 id="org65ea726"><span class="section-number-3">3.3.</span> Getting the Results</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li><p>
We save the results as <code>results</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results</span> = job.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(results))

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.result.result.Result'&gt;
Result(backend_name='basic_simulator', backend_version='0.1', qobj_id='5fa46fbe-251b-4733-b29c-6cd05bb52024', job_id='5abb07aa-3a06-4ff7-94e5-a27a9e678d07', success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 519, '0x3': 505}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['c', 0], ['c', 1]], memory_slots=2, creg_sizes=[['c', 2]], name='circuit-160', global_phase=0.0, metadata={}), status=DONE, name='circuit-160', seed_simulator=np.int32(1719395928), time_taken=0.07600593566894531)], date=None, status=COMPLETED, header=QobjHeader(backend_name='basic_simulator', backend_version='0.1'), time_taken=0.0760350227355957)
</pre></li>

<li>The results object has lots of information about our quantum experiment
simulation</li>
</ul>
</div>

<div id="outline-container-org2daec8d" class="outline-4">
<h4 id="org2daec8d"><span class="section-number-4">3.3.1.</span> Simulation Counts</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li><p>
A <code>get_counts()</code> method helps us retrieve the outcomes and their frequencies.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = results.get_counts()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)
</pre>
</div>

<pre class="example">
{'00': 519, '11': 505}
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org1c5460d" class="outline-4">
<h4 id="org1c5460d"><span class="section-number-4">3.3.2.</span> Visualizing the Results</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>We can plot the measurement results in two ways:
<ul class="org-ul">
<li>as a histogram (counts) using <code>plot_histogram()</code>, or</li>
<li>as a probability distribution using <code>plot_distribution()</code>.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

display( plot_distribution( counts ) )

display( plot_histogram( counts ) )
</pre>
</div>


<div id="org482246a" class="figure">
<p><img src="./img/basicSimHist.png" alt="basicSimHist.png" width="600px" />
</p>
<p><span class="figure-number">Figure 5: </span>A histogram from the results of a <code>BasicSimulator.run()</code> simulation.</p>
</div>


<div id="orga4f6ce0" class="figure">
<p><img src="./img/basicSimPD.png" alt="basicSimPD.png" width="600px" />
</p>
<p><span class="figure-number">Figure 6: </span>A quasi-probability distribution from the results of a <code>BasicSimulator.run()</code> simulation. Quasiprobabilities are not actual probabilities, but rather estimates of probabilites obtained by dividing the number of occurrences of an event by the total number of experiments (shots).</p>
</div>
</div>
</div>

<div id="outline-container-org19fdad0" class="outline-4">
<h4 id="org19fdad0"><span class="section-number-4">3.3.3.</span> Inspecting Results from Individual Measurements</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>We can see the results of individual measurements if we use the <code>get_memory()</code> method for a <code>Results</code> object
<ul class="org-ul">
<li>This requires using the <code>memory</code> keyword with a value of <code>True</code> in the
<code>run()</code> method for our basic simulator</li>
</ul></li>
<li>Here, we do this with a fewer number of shots so that we can avoid
overwhelming ourselves with numerous results</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">small_job</span> = simulator_basic.run( qc, shots=8, memory=<span style="color: #BFEBBF;">True</span>)
<span style="color: #DFAF8F;">small_result</span> = small_job.result()
<span style="color: #DFAF8F;">samples</span> = small_result.get_memory()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)
</pre>
</div>

<pre class="example">
['00', '00', '00', '00', '11', '11', '11', '00']
</pre>
</div>
</div>
</div>

<div id="outline-container-org527da66" class="outline-3">
<h3 id="org527da66"><span class="section-number-3">3.4.</span> Handling Complex Circuits</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>The basic simulator cannot handle more complex circuits readily, such as the QFT circuit</li>
<li>To handle complex circuits, we must first transpile our circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit.library <span style="color: #F0DFAF; font-weight: bold;">import</span> QFT

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(3, 3) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">3 qubits, 3 classical bits</span>
qc.append( QFT(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )
qc.measure( <span style="color: #DCDCCC; font-weight: bold;">range</span>(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )

qc.draw()
</pre>
</div>


<div id="orga27dfdb" class="figure">
<p><img src="./img/BasicSimQFT.png" alt="BasicSimQFT.png" width="480px" />
</p>
<p><span class="figure-number">Figure 7: </span>This is a more complex circuit including a QFT. <code>BasicSimulator</code> cannot handle this unless we first transpile it.</p>
</div>
</div>

<div id="outline-container-org2d20d98" class="outline-4">
<h4 id="org2d20d98"><span class="section-number-4">3.4.1.</span> Transpilation</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>Circuits may be composed of gates of various types</li>
<li>Some gates may not exist natively on a particular quantum processing unit
(QPU), but may be implemented using the available gates on the QPU
<ul class="org-ul">
<li>The set of available gates is often called the instruction set architecture
(ISA)</li>
</ul></li>
<li>To transpile a circuit is to represent it in the ISA of a particular machine</li>
<li>In this case, we transpile the QFT into gates available within the
<code>BasicSimulator</code> class.</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>This code transpiles the circuit of Figure <a href="#orga27dfdb">7</a></label><pre class="src src-python" id="orga9f6062"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile

<span style="color: #DFAF8F;">qc_trans</span> = transpile( qc, backend=simulator_basic)

qc_trans.draw()

</pre>
</div>

<p>
Jupyter output for Listing will resemble Figure <a href="#org82e3bb4">8</a>
</p>

<div id="org82e3bb4" class="figure">
<p><img src="./img/BasicSimQFTtrans.png" alt="BasicSimQFTtrans.png" width="640px" />
</p>
<p><span class="figure-number">Figure 8: </span>This is a transpiled version of the circuit from Figure <a href="#orga27dfdb">7</a></p>
</div>
</div>
</div>
</div>

<div id="outline-container-org24facf5" class="outline-3">
<h3 id="org24facf5"><span class="section-number-3">3.5.</span> Conclusion</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>The <code>BasicSimulator()</code> class is useful when we simulate a job where we need to
find counts or samples of a circuit with mid-circuit measurements</li>
<li>The <code>BasicSimulator()</code> class should not be used for:
<ul class="org-ul">
<li>large circuits with many qubits or many gates</li>
<li>circuits where a coherent state is desired (state vector or density matrix)</li>
<li>noisy simulations</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec:QiskitAerSimulator" class="outline-2">
<h2 id="sec:QiskitAerSimulator"><span class="section-number-2">4.</span> The <code>qiskit_aer.AerSimulator</code> Class</h2>
<div class="outline-text-2" id="text-sec:QiskitAerSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-orge3914e2" class="outline-3">
<h3 id="orge3914e2"><span class="section-number-3">4.1.</span> Overview</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>The Qiskit Aer AerSimulator class can be used to simulate complex circuits with mid-circuit measurements</li>
<li>We can obtain unitary results from these simulations.</li>
<li>Qiskit Aer supports both noise-free and noisy simulations</li>
<li>The Qiskit <code>AerSimulator</code> class has a <code>run()</code> method that is simple and
straightforward to use; however, its syntax is notably different from the
tools used to launch calculations on actual quantum hardware (quantum
processing units).</li>
<li>The <code>qiskit_ibm_runtime</code> package provides interfaces called <b>primitives</b> to
run jobs on QPUs. These primitives include:
<ul class="org-ul">
<li><code>SamplerV2</code> for obtaining counts for an ensemble of measurements on a circuit</li>
<li><code>EstimatorV2</code> for obtaining expectation values from the output of a circuit</li>
</ul></li>
<li>To simulate circuits in a way as closely as possible to the
<code>qiskit_ibm_runtime</code> primitives, <code>qiskit_aer</code> also provides <code>SamplerV2</code> and
<code>EstimatorV2</code> primitives
<ul class="org-ul">
<li>The <code>qiskit_aer</code> primitives are designed for similarity with
the <code>qiskit_ibm_runtime</code> primitives</li>
</ul></li>
<li>In summary:
<ul class="org-ul">
<li><code>qiskit_aer.AerSimulator</code> has a <code>run()</code> method for simulating quantum circuits
<ul class="org-ul">
<li>This is notably different from primitives used to run jobs on quantum hardware</li>
</ul></li>
<li><code>qiskit_aer.primitives</code> has <code>SamplerV2</code> and <code>EstimatorV2</code> classes, which may
be used to simulate circuits in a way very similar to the primitives used
for running jobs on QPUs using <code>qiskit_ibm_runtime</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org0aba2f2" class="outline-3">
<h3 id="org0aba2f2"><span class="section-number-3">4.2.</span> Imports</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>We begin by importing the required packages
<ul class="org-ul">
<li>This introduces the <code>qiskit_aer</code> package and the <code>AerSimulator</code> class</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit <span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">, transpile</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit.quantum_info import Statevector</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit.providers.basic_provider import BasicSimulator</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit_aer import AerSimulator</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator_basic = BasicSimulator()</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator_aer = AerSimulator()</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'test'</span>)
</pre>
</div>

<pre class="example">
test
</pre>
</div>
</div>


<div id="outline-container-org393a6e2" class="outline-3">
<h3 id="org393a6e2"><span class="section-number-3">4.3.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><p>
We define a circuit in Listing <a href="#orga215e97">1</a>
</p>
<div class="org-src-container">
<pre class="src src-python" id="orgf95916e"><span style="color: #F0DFAF; font-weight: bold;">import</span> qiskit
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 0</span>
qc.h(0).c_if(0,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1</span>
qc.save_statevector()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(qiskit.__version__)
</pre>
</div>

<pre class="example">
1.3.1
</pre></li>
</ul>




<div id="orga9292d4" class="figure">
<p><img src="./img/CktAerSim.png" alt="CktAerSim.png" width="480px" />
</p>
<p><span class="figure-number">Figure 9: </span>This is a two-qubit circuit with a measurement in the middle of the circuit.</p>
</div>

<ul class="org-ul">
<li>Here, the <code>save_statevector()</code> method defines a point in the circuit at
which we wish to knkow the state vector</li>
</ul>
</div>
</div>
<div id="outline-container-org660a33f" class="outline-3">
<h3 id="org660a33f"><span class="section-number-3">4.4.</span> Run the <code>AerSimulator()</code></h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><p>
We first transpile the circuit so it is suitable for our simulator, and then we run it:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968; <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">show the state vector in Jupyter Lab</span>
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle
\end{equation}</li>
</ul>
</div>
</div>
<div id="outline-container-org267d81d" class="outline-3">
<h3 id="org267d81d"><span class="section-number-3">4.5.</span> Example 2: Circuit with Statevector in Middle of Circuit</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li><p>
Now, we provide an example where the state vector is saved from a point prior to the end of the circuit.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(4)
qc.h(3)
qc.cx(3,2)
qc.save_statevector()
qc.cx(3,1)
qc.cx(3,0)
qc.measure_all()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org6608b1e" class="figure">
<p><img src="./img/AerSimMultiStatevectCkt.png" alt="AerSimMultiStatevectCkt.png" width="640px" />
</p>
<p><span class="figure-number">Figure 10: </span>This circuit saves a <code>Statevector</code> in the middle of the calculation and just prior to measurement.</p>
</div></li>
</ul>
</div>

<div id="outline-container-orgdd0eab1" class="outline-4">
<h4 id="orgdd0eab1"><span class="section-number-4">4.5.1.</span> Transpile and Run the Circuit</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li><p>
Next, we transpile and run the circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968;
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle
\end{equation}</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org5f1b342" class="outline-3">
<h3 id="org5f1b342"><span class="section-number-3">4.6.</span> Efficient Simulation</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>Portions of the <code>AerSimulator</code> code are compiled to <code>C</code>
<ul class="org-ul">
<li>This allows faster and more efficient simulations, which enables simulations
of larger and more complex circuits.</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgfe94e66" class="outline-4">
<h4 id="orgfe94e66"><span class="section-number-4">4.6.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-6-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 24
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-orgb163937" class="outline-4">
<h4 id="orgb163937"><span class="section-number-4">4.6.2.</span> Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></h4>
<div class="outline-text-4" id="text-4-6-2">
</div>
<ol class="org-ol">
<li><a id="orgca16664"></a>BasicSimulator<br />
<div class="outline-text-5" id="text-4-6-2-1">
<ul class="org-ul">
<li>In the following code, I simulate and time the circuit</li>
<li>In Jupyter Lab, the time to run a cell can be obtained by adding <code>%%time</code> at
the top of the cell.</li>
<li>These notes are not written in Jupyter Lab, so I use the <code>time</code> module
<ul class="org-ul">
<li>Key instructions:
<ul class="org-ul">
<li><code>import time</code> to access the module</li>
<li>Use <code>time.time()</code> to get the current time</li>
<li>The difference between two <code>time</code> objects can be used to calculate a time
interval in seconds</li>
</ul></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> time
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_basic.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_basic_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_basic_sim ))
</pre>
</div>

<pre class="example">
{'000000000000000000000000': 531, '111111111111111111111111': 493}
Time elapsed: 17.700 s
</pre>
</div>
</li>

<li><a id="org3edeedf"></a><code>AerSimulator</code><br />
<div class="outline-text-5" id="text-4-6-2-2">
<ul class="org-ul">
<li>We now run and time the same circuit using the <code>AerSimulator</code>, and we see it
is much faster for larger circuits</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'111111111111111111111111': 537, '000000000000000000000000': 487}
Time elapsed:  0.025 s
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgfb558e4" class="outline-3">
<h3 id="orgfb558e4"><span class="section-number-3">4.7.</span> Simulation Methods</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>Qiskit Aer supports different types of simulation, accessible through the
<code>method</code> keyword argument to the <code>run()</code> command.
<ul class="org-ul">
<li>The default is <code>method</code>'statevector'=
<ul class="org-ul">
<li>The limit here is 24 qubits</li>
</ul></li>
<li>Other methods include <code>'matrix_product_state'</code></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org15fde6d" class="outline-4">
<h4 id="org15fde6d"><span class="section-number-4">4.7.1.</span> Build a Large Circuit</h4>
<div class="outline-text-4" id="text-4-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 50
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-orgbeb0436" class="outline-4">
<h4 id="orgbeb0436"><span class="section-number-4">4.7.2.</span> Run and Time the Simulation</h4>
<div class="outline-text-4" id="text-4-7-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024, method=<span style="color: #CC9393;">'matrix_product_state'</span> ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'11111111111111111111111111111111111111111111111111': 492, '00000000000000000000000000000000000000000000000000': 532}
Time elapsed:  0.081 s
</pre>
</div>
</div>
</div>

<div id="outline-container-org59a6349" class="outline-3">
<h3 id="org59a6349"><span class="section-number-3">4.8.</span> Noisy Simulation</h3>
<div class="outline-text-3" id="text-4-8">
</div>
<div id="outline-container-org2a970cd" class="outline-4">
<h4 id="org2a970cd"><span class="section-number-4">4.8.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-8-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0])

qc.draw()
</pre>
</div>


<div id="org000f6c3" class="figure">
<p><img src="./img/noisyCktExample.png" alt="noisyCktExample.png" width="480px" />
</p>
<p><span class="figure-number">Figure 11: </span>This is a small circuit for noisy simulation using the <code>AerSimulator</code>.</p>
</div>
</div>
</div>

<div id="outline-container-orgf542de9" class="outline-4">
<h4 id="orgf542de9"><span class="section-number-4">4.8.2.</span> Ideal Result</h4>
<div class="outline-text-4" id="text-4-8-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This will throw an error for n &gt; 25 using method='statevector'</span>
<span style="color: #DFAF8F;">qc_aer</span> = transpile( qc, backend=simulator_aer )
<span style="color: #DFAF8F;">result_ideal</span> = simulator_aer.run( qc_aer, shots=1024 ).result()
<span style="color: #DFAF8F;">counts_ideal</span> = result_ideal.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_ideal)
</pre>
</div>

<pre class="example">
{'11': 520, '00': 504}
</pre>
</div>
</div>

<div id="outline-container-orged41a36" class="outline-4">
<h4 id="orged41a36"><span class="section-number-4">4.8.3.</span> Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> noise

<span style="color: #DFAF8F;">prob</span> = 0.1
<span style="color: #DFAF8F;">error</span> = noise.depolarizing_error( prob, 2 )

<span style="color: #DFAF8F;">noise_model</span> = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error( error, [<span style="color: #CC9393;">'cx'</span>])
<span style="color: #DFAF8F;">basis_gates</span> = noise_model.basis_gates

<span style="color: #DFAF8F;">result_noisy</span> = simulator_aer.run(qc,
                                shots=1024,
                                noise_model=noise_model,
                                basis_gates=basis_gates).result()

<span style="color: #DFAF8F;">counts_noisy</span> = result_noisy.get_counts()
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d8138b" class="outline-4">
<h4 id="org0d8138b"><span class="section-number-4">4.8.4.</span> Compare Ideal Result and Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment this to see the compared distributions</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )</span>
</pre>
</div>


<div id="orgbcefbf1" class="figure">
<p><img src="./img/AerSimIdealvsNoisy.png" alt="AerSimIdealvsNoisy.png" width="640px" />
</p>
<p><span class="figure-number">Figure 12: </span>An ideal <code>AerSimulator</code> result is compared to a noisy result.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2597734" class="outline-3">
<h3 id="org2597734"><span class="section-number-3">4.9.</span> Summary</h3>
<div class="outline-text-3" id="text-4-9">
<p>
The <code>AerSimulator()</code> is useful when we want to:
</p>
<ol class="org-ol">
<li>Find counts/samples of large circuits (simulators are efficient)</li>
<li>Find state vector/density matrix of circuits with measurements</li>
<li>Simulate circuits with noise</li>
</ol>

<p>
The AerSimulator() results do not match the output format of Qiskit IBM runtime
(the quantum hardware).
</p>

<p>
Qiskit Aer has its own sampler/estimator, which provide a closer match to the
inputs and outputs of the hardware, but these are being deprecated.
</p>

<p>
In the next section, we explore <a href="https://docs.quantum.ibm.com/api/qiskit/primitives">primitives</a>, which are used
in Qiskit IBM runtime.
</p>
</div>
</div>
</div>

<div id="outline-container-org5daebd2" class="outline-2">
<h2 id="org5daebd2"><span class="section-number-2">5.</span> Qiskit Primitives</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orge12187d" class="outline-3">
<h3 id="orge12187d"><span class="section-number-3">5.1.</span> Overview</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>The interface for the various simulators (BasicSimulator, AerSimulator) were
identical to the Qiskit IBM Provider interface to the quantum hardware</li>
<li>The backend was an abstraction for something that was either simulator or an
actual quantum processor.</li>
<li>Primitives abstract the interface between users and backends</li>
<li>There are two available primitives:
<ul class="org-ul">
<li>Sampler - this samples the output state of a circuit</li>
<li>Estimator - this stimates expectation values of a state with respect to
observables</li>
</ul></li>
<li>Qiskit, Qiskit Aer, and Qiskit IBM Runtime each provide different primitives.</li>
<li>Diego recommends starting with the version 2 primitives, which are compatible
with the current hardware:</li>

<li>Qiskit
<ul class="org-ul">
<li>StatevectorSampler</li>
<li>StatevectorEstimator</li>
</ul></li>
<li><code>qiskit_aer</code>
<ul class="org-ul">
<li><code>primitives.SamplerV2</code></li>
<li><code>primitives.EstimatorV2</code></li>
</ul></li>
<li><code>qiskit_ibm_runtime</code>
<ul class="org-ul">
<li><code>SamplerV2</code></li>
<li><code>EstimatorV2</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf30692b" class="outline-3">
<h3 id="orgf30692b"><span class="section-number-3">5.2.</span> Primitives</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Qiskit primitives are computational building blocks used in larger applications that require quantum resources to efficiently produce outputs. The inputs to a primitive consists of primitive unified blocs (PUBs).
</p>

<p>
There are two types of primitives:
</p>
<ol class="org-ol">
<li><code>EstimatorV2</code></li>
<li><code>SamplerV2</code></li>
</ol>

<p>
The workflow is as before: build a circuit, and then simulate it (or run it on
hardware).
</p>
</div>

<div id="outline-container-org91dc777" class="outline-4">
<h4 id="org91dc777"><span class="section-number-4">5.2.1.</span> Imports</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorSampler, StatevectorEstimator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'imports complete'</span>) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">it's sometimes desirable to check job completion</span>
</pre>
</div>

<pre class="example">
imports complete
</pre>
</div>
</div>

<div id="outline-container-org2bf5a7d" class="outline-4">
<h4 id="org2bf5a7d"><span class="section-number-4">5.2.2.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2, 2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measurement register: c</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="orgd74ce6b" class="figure">
<p><img src="./img/qisprimckt01.png" alt="qisprimckt01.png" width="480px" />
</p>
<p><span class="figure-number">Figure 13: </span>This is a circuit for use with the <code>qiskit</code> primitives.</p>
</div>
</div>
</div>

<div id="outline-container-orgf4de50a" class="outline-4">
<h4 id="orgf4de50a"><span class="section-number-4">5.2.3.</span> Run Simulations</h4>
<div class="outline-text-4" id="text-5-2-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">simulator</span> = BasicSimulator()
<span style="color: #DFAF8F;">sampler</span> = StatevectorSampler()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org410aa3c"></a>Basic Simulation<br />
<div class="outline-text-5" id="text-5-2-3-1">
<p>
This simulates the circuit using ~qiskit.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">No transpilation is needed for this simple circuit</span>
<span style="color: #DFAF8F;">job_simulator</span> = simulator.run( qc, shots=1024)
</pre>
</div>
</div>
</li>

<li><a id="orgb7f14fb"></a>Simulation using a Sampler<br />
<div class="outline-text-5" id="text-5-2-3-2">
<ul class="org-ul">
<li>The syntax for a sampler simulation is somewhat different than that of the
<code>BasicSimulator</code> class.
<ul class="org-ul">
<li>Here, inputs are in the form of primitive-unified blocs (PUBS)</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_sampler</span> = sampler.run( [qc], shots=1024)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgd405098" class="outline-4">
<h4 id="orgd405098"><span class="section-number-4">5.2.4.</span> Extracting Results</h4>
<div class="outline-text-4" id="text-5-2-4">
<ul class="org-ul">
<li>We extract results in the same way from both the simulator and the sampler:</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_simulator</span> = job_simulator.result()
<span style="color: #DFAF8F;">result_sampler</span> = job_sampler.result()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org60b32b1"></a>Simulator Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-1">
<ul class="org-ul">
<li><p>
We can retrieve counts from the simulator result as before, using the
<code>get_counts()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = result_simulator.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>( counts_simulator )
</pre>
</div>

<pre class="example">
{'11': 522, '00': 502}
</pre></li>
</ul>
</div>
</li>


<li><a id="org02e159d"></a>Sampler Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-2">
<ul class="org-ul">
<li><p>
Getting counts from the sampler is a bit more involved. Let's eamine the
results we obtained:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(result_sampler))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_sampler)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
PrimitiveResult([SamplerPubResult(data=DataBin(c=BitArray(&lt;shape=(), num_shots=1024, num_bits=2&gt;)), metadata={'shots': 1024, 'circuit_metadata': {}})], metadata={'version': 2})
</pre>


<ul class="org-ul">
<li>The results from the sampler come as an object of class <code>PubResult</code>
object.
<ul class="org-ul">
<li>This class has a <code>get_counts()</code> method.</li>
<li>Since the input PUB for the sampler is a list, we must similarly index the
result to get the result(s)  for a specific PUB item.</li>
<li>If we don't provide an index, get<sub>counts</sub>() will
aggregate the results, which may not be what we want.</li>
</ul></li>
</ul></li>
<li>To get counts, we do the following:</li>
<li>index the PUB result. Here, we call for the zeroth element.</li>
<li>reference the data member data element, and reference the classical register name.</li>
<li><p>
use the <code>get_counts()</code> method.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[0].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 504, '00': 520}
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgf3c7e12" class="outline-3">
<h3 id="orgf3c7e12"><span class="section-number-3">5.3.</span> Example: A Parametrized Circuit</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter
<span style="color: #F0DFAF; font-weight: bold;">from</span> math <span style="color: #F0DFAF; font-weight: bold;">import</span> pi

<span style="color: #DFAF8F;">&#952;</span> = Parameter(<span style="color: #CC9393;">'&#952;'</span>)

<span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">assign a parameter for this rotation</span>
qc2.cx(1, 0)
qc2.measure_all()
qc2.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org94da872" class="figure">
<p><img src="./img/prametrizedckt.png" alt="prametrizedckt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 14: </span>This circuit has a parameter θ.</p>
</div>
</div>


<div id="outline-container-orgfbf70b8" class="outline-4">
<h4 id="orgfbf70b8"><span class="section-number-4">5.3.1.</span> <code>BasicSimulator</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Here, we make a list of circuits, each with a specific value of the parameter θ.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">angles</span> = [[pi/4], [pi/3], [pi/2]]

<span style="color: #DFAF8F;">circuits</span> = []
<span style="color: #F0DFAF; font-weight: bold;">for</span> angle <span style="color: #F0DFAF; font-weight: bold;">in</span> angles:
    <span style="color: #DFAF8F;">qc_temp</span> = qc2.assign_parameters({&#952;:angle[0]})
    circuits.append(qc_temp)
</pre>
</div>

<p>
We can draw the different circuits by indexing the list:
</p>
<div class="org-src-container">
<pre class="src src-python">circuits[1].draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org7041e7e" class="figure">
<p><img src="./img/prametrizedckt_ex.png" alt="prametrizedckt_ex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 15: </span>We print a circuit from a list of circuits. Unlike the circuit of Fig. <a href="#org94da872">14</a>, this circuit has a specific value for θ.</p>
</div>
</div>


<ol class="org-ol">
<li><a id="orga8b1292"></a>Transpiling and Running<br />
<div class="outline-text-5" id="text-5-3-1-1">
<ul class="org-ul">
<li>The entire list of circuits can be transpiled in a single call to <code>transpile()</code></li>
<li><p>
The transpiled list can be called using one call to the <code>BasicSimulator.run()</code>
method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">transpile the circuit list</span>
<span style="color: #DFAF8F;">circuits_t</span> = transpile( circuits, backend=simulator )

<span style="color: #DFAF8F;">result_simulator</span> = simulator.run( circuits_t, shots=1024 ).result()
</pre>
</div></li>
<li><p>
We provide an index to <code>get_counts()</code> for the corresponding circuit in
<code>circuits_t</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = []

<span style="color: #F0DFAF; font-weight: bold;">for</span> i, _ <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(angles):
    <span style="color: #DFAF8F;">result_temp</span> = result_simulator.get_counts(i)
    counts_simulator.append(result_temp)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_simulator)
</pre>
</div>

<pre class="example">
[{'00': 875, '11': 149}, {'00': 780, '11': 244}, {'11': 465, '00': 559}]
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgdddf42d" class="outline-4">
<h4 id="orgdddf42d"><span class="section-number-4">5.3.2.</span> <code>StatevectorSampler</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>For a sampler, we pass a list of PUBs. This contains
<ul class="org-ul">
<li>the generic parametrized circuit, along with</li>
<li>the list of parameters</li>
</ul></li>
<li>This makes the <code>run()</code> command very simple.</li>
<li>To get the results, we index the <code>result_sampler</code>, i.e., <code>results_sampler[0]</code>
<ul class="org-ul">
<li>This indexes the zeroth (and only) PUB, with the flexibility to support multiple PUBs</li>
</ul></li>
<li>We iterate over the angles as before to get results for each angles</li>
</ul>
<div class="warning" id="org63befa5">
<p>
Caution: if we simply use <code>result.sampler[0].data.meas.get_counts()</code>, this aggregates the counts by summing them. Often, this is not what we want. 
</p>

</div>
</div>
</div>


<div id="outline-container-org8d3e26a" class="outline-4">
<h4 id="org8d3e26a"><span class="section-number-4">5.3.3.</span> <code>StatevectorSampler</code> Usage with Multiple PUBs</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
We now pass two PUBs, each with a different circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0], [1,0])

qc.draw()
</pre>
</div>


<div id="orga63b8f2" class="figure">
<p><img src="./img/circuit_multiPUBex.png" alt="circuit_multiPUBex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 16: </span>A circuit for use in an example with multiple PUBs.</p>
</div>
</div>

<ol class="org-ol">
<li><a id="org5092ad0"></a>Run the Multi-Pub Basic Sampler<br />
<div class="outline-text-5" id="text-5-3-3-1">
<ul class="org-ul">
<li>Here, we run one job with two different PUBs, each with a different circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_sampler</span> = sampler.run([(qc2, angles), (qc, <span style="color: #BFEBBF;">None</span>)], shots=1024).result()
</pre>
</div>
</div>
</li>

<li><a id="orgff27b26"></a>Retrieve Data for the Zeroth Circuit<br />
<div class="outline-text-5" id="text-5-3-3-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = [ result_sampler[0].data.meas.get_counts(k) <span style="color: #F0DFAF; font-weight: bold;">for</span> k <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
[{'00': 857, '11': 167}, {'00': 774, '11': 250}, {'00': 501, '11': 523}]
</pre>
</div>
</li>

<li><a id="org4a8907f"></a>Retrieve Data for the First Circuit<br />
<div class="outline-text-5" id="text-5-3-3-3">
<ul class="org-ul">
<li>Here, we have a non-parametrized circuit, so we don't need to provide an argument to <code>get_counts()</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[1].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 521, '00': 503}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org2788cfc" class="outline-3">
<h3 id="org2788cfc"><span class="section-number-3">5.4.</span> The Estimator Primitive</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>The <code>StatevectorEstimator</code> primitive takes a PUB, but with a slightly different format from <code>BasicSampler</code>.</li>
<li>The circuits cannot have any measurement gates</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1)
qc2.cx(1, 0)

qc2.draw( reverse_bits = <span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org7b4453a" class="figure">
<p><img src="./img/sample_ckt_for_Estimator.png" alt="sample_ckt_for_Estimator.png" width="480px" />
</p>
<p><span class="figure-number">Figure 17: </span>This circuit was built for use with an <code>Estimator</code> simulation. For this reason, we do not include measurement blocks.</p>
</div>
</div>

<div id="outline-container-org5a2a121" class="outline-4">
<h4 id="org5a2a121"><span class="section-number-4">5.4.1.</span> Observables</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>Since an estimator estimates expectation values \(\left\langle \psi |
  \mathbf{O} | \right\rangle\), we need an observable, \(\mathbf{O}\).</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This is a list of observables. I'm not sure why it's a list of lists.</span>
<span style="color: #DFAF8F;">obsv</span> = [ [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"IY"</span>], [0.5, 0.5] ) ],
         [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>], [1] ) ] ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv)
</pre>
</div>

<pre class="example">
[[SparsePauliOp(['XX', 'IY'],
              coeffs=[0.5+0.j, 0.5+0.j])], [SparsePauliOp(['XX'],
              coeffs=[1.+0.j])]]
</pre>
</div>
</div>

<div id="outline-container-org8b8c157" class="outline-4">
<h4 id="org8b8c157"><span class="section-number-4">5.4.2.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
<span style="color: #DFAF8F;">result_estimator</span> = estimator.run( [(qc2, obsv, angles, 0.1)] ).result()
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb555de1" class="outline-4">
<h4 id="orgb555de1"><span class="section-number-4">5.4.3.</span> Extract Expectation Values</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
<li>(optional) we can see some metadata using the <code>.metadata</code> function</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Extract the expectation values (evs) from the result for PUB 0</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].data.evs)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].metadata)
</pre>
</div>

<pre class="example">
[[ 0.05985877  0.14030793  0.18762585]
 [ 0.10722808 -0.04870472  0.15934201]]
{'target_precision': 0.1, 'circuit_metadata': {}}
</pre>


<ul class="org-ul">
<li>This is a list of two observables, with one value for each of the input
parameters.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga3d66b9" class="outline-3">
<h3 id="orga3d66b9"><span class="section-number-3">5.5.</span> Qiskit Estimator Example</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li><p>
This provides another example from a Qiskit documentation <a href="https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives">tutorial</a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">circuit for which you want to obtain the expected value</span>
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.ry(Parameter(<span style="color: #CC9393;">'theta'</span>), 0)
qc.h(0)
qc.cx(0,1)
qc.draw(<span style="color: #CC9393;">"mpl"</span>, style=<span style="color: #CC9393;">"iqp"</span>)
</pre>
</div>


<div id="orgd4f5d6c" class="figure">
<p><img src="./img/EstimatorIBMExCkt.png" alt="EstimatorIBMExCkt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 18: </span>This is a simple circuit built for an IBM Quantum tutorial on using the <code>StatevectorEstimator</code>.</p>
</div></li>
</ul>
</div>

<div id="outline-container-org2c14b9d" class="outline-4">
<h4 id="org2c14b9d"><span class="section-number-4">5.5.1.</span> Build an Operator</h4>
<div class="outline-text-4" id="text-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">observable(s) whose expected values you want to compute</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #DFAF8F;">observable</span> = SparsePauliOp([<span style="color: #CC9393;">"II"</span>, <span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"YY"</span>, <span style="color: #CC9393;">"ZZ"</span>], coeffs=[1, 1, -1, 1])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">value(s) for the circuit parameter(s)</span>
<span style="color: #DFAF8F;">parameter_values</span> = [[0], [np.pi/6], [np.pi/2]]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(parameter_values)
</pre>
</div>

<pre class="example">
[[0], [0.5235987755982988], [1.5707963267948966]]
</pre>
</div>
</div>


<div id="outline-container-org3d4b52e" class="outline-4">
<h4 id="org3d4b52e"><span class="section-number-4">5.5.2.</span> Instantiate a <code>StatevectorEstimator</code></h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorEstimator
<span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
</pre>
</div>
</div>
</div>


<div id="outline-container-org8fa308f" class="outline-4">
<h4 id="org8fa308f"><span class="section-number-4">5.5.3.</span> Transpile the Circuit</h4>
<div class="outline-text-4" id="text-5-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Generate a pass manager without providing a backend</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(optimization_level=1)
<span style="color: #DFAF8F;">isa_circuit</span> = pm.run(qc)
<span style="color: #DFAF8F;">isa_observable</span> = observable.apply_layout(isa_circuit.layout)
</pre>
</div>
</div>
</div>

<div id="outline-container-org954510f" class="outline-4">
<h4 id="org954510f"><span class="section-number-4">5.5.4.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-5-4">
<ul class="org-ul">
<li>We form a PUB as an argument to the <code>StatevectorEstimator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job</span> = estimator.run([(isa_circuit, isa_observable, parameter_values)])
<span style="color: #DFAF8F;">result</span> = job.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Result class: </span>{<span style="color: #DCDCCC; font-weight: bold;">type</span>(result)}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
&gt; Result class: &lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
</pre>
</div>
</div>

<div id="outline-container-org9ad00d8" class="outline-4">
<h4 id="org9ad00d8"><span class="section-number-4">5.5.5.</span> Extract Results</h4>
<div class="outline-text-4" id="text-5-5-5">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the
following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(result)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">len</span>(result))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Expectation value: </span>{result[0].data.evs}<span style="color: #CC9393;">"</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Metadata: </span>{result[0].metadata}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), stds=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), shape=(3,)), metadata={'target_precision': 0.0, 'circuit_metadata': {}})], metadata={'version': 2})
1
 &gt; Expectation value: [4.         3.73205081 2.        ]
 &gt; Metadata: {'target_precision': 0.0, 'circuit_metadata': {}}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org6292670" class="outline-2">
<h2 id="org6292670"><span class="section-number-2">6.</span> <code>qiskit_aer</code> Primitives</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org5616e24" class="outline-3">
<h3 id="org5616e24"><span class="section-number-3">6.1.</span> <code>qiskit_aer.primitives.SamplerV2</code></h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-org7e609ef" class="outline-4">
<h4 id="org7e609ef"><span class="section-number-4">6.1.1.</span> Example: Bell Circuits</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Bell circuits are used to create entangled pairs of qubits
</p>
</div>

<ol class="org-ol">
<li><a id="org31cd02c"></a>Imports<br />
<div class="outline-text-5" id="text-6-1-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2

<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Optional</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Imports complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Imports complete at 2025-02-26 22:00:10.084471
</pre>
</div>
</li>

<li><a id="org5c1cc3b"></a>Bell Circuits<br />
<div class="outline-text-5" id="text-6-1-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">Bell00</span> = QuantumCircuit(2)
Bell00.h(0)
Bell00.cx(0,1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(Bell00)</span>
</pre>
</div>


<div id="org377ea61" class="figure">
<p><img src="./img/Bell00ckt.png" alt="Bell00ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 19: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 00 \right\rangle + \left|11  \right\rangle \right)/\sqrt{2} \).</p>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org307e6dc" class="outline-2">
<h2 id="org307e6dc"><span class="section-number-2">7.</span> Qiskit IBM Runtime Primitives</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org1aa2e7a" class="outline-3">
<h3 id="org1aa2e7a"><span class="section-number-3">7.1.</span> Imports</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> math <span style="color: #F0DFAF; font-weight: bold;">import</span> pi <span style="color: #F0DFAF; font-weight: bold;">as</span> &#960;

<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_distribution
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2, EstimatorV2, QiskitRuntimeService
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaf0c185" class="outline-3">
<h3 id="orgaf0c185"><span class="section-number-3">7.2.</span> Load a Personal IBM Token</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>You need a personal IBM token to access the hardware.</li>
<li>There are several ways to do this.</li>
<li>The first thing, however, is to get a personal IBM Quantum token</li>
</ul>
</div>
<div id="outline-container-org90aea99" class="outline-4">
<h4 id="org90aea99"><span class="section-number-4">7.2.1.</span> Getting Your IBM Quantum Token</h4>
<div class="outline-text-4" id="text-7-2-1">
<ol class="org-ol">
<li>If you don't already have one, use your university e-mail account
(prefferable) to register for an account.</li>
<li>Once logged in, you can get your IBM token in one of two ways:
<ol class="org-ol">
<li>Visit your <a href="https://quantum.ibm.com">IBM Quantum Platform dashboard</a>
<ol class="org-ol">
<li><p>
In the upper right, you'll see a box where you can view or copy your
IBM Quantum API token
</p>

<div id="org8a7002f" class="figure">
<p><img src="./img/IBMQuantumDashboard.png" alt="IBMQuantumDashboard.png" width="360px" />
</p>
</div></li>
</ol></li>
<li><p>
Click the "Account" button (it looks like an anonymized profile pic). This
brings up your <i>Profile Settings</i>
</p>

<div id="org939992b" class="figure">
<p><img src="./img/IBMQuantumAccountIcon.png" alt="IBMQuantumAccountIcon.png" width="360px" />
</p>
</div>
<ol class="org-ol">
<li>Below the <i>Profile Details</i> is an <i>API Token</i>. Click the icon that allows
you to copy you IBM Quantum API token. You will paste this information
elsewhere later.</li>
</ol></li>
</ol></li>
</ol>
</div>
</div>



<div id="outline-container-orgf9f986b" class="outline-4">
<h4 id="orgf9f986b"><span class="section-number-4">7.2.2.</span> The <a href="https://docs.python.org/3/library/getpass.html">getpass</a> Package</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li>This is a nice Python package that is useful in Jupyter notebooks</li>
<li>It allows you to prompt the user for a password that can be used later in the file.</li>
<li><p>
The basic usage is:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> getpass <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">this comes with standard Python</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This interactively prompts the user for their password</span>
<span style="color: #DFAF8F;">token</span> = getpass.getpass(<span style="color: #CC9393;">'Enter your password: '</span>)
</pre>
</div></li>
<li>You can then use <code>token</code> in an API call</li>
<li>This allows you to share Jupyter notebooks <i>without</i> also sharing your
password/token/API key.</li>
</ul>
</div>
</div>

<div id="outline-container-org0ea72aa" class="outline-4">
<h4 id="org0ea72aa"><span class="section-number-4">7.2.3.</span> Acessing IBM Quantum Harware Using Your Token</h4>
<div class="outline-text-4" id="text-7-2-3">
<ul class="org-ul">
<li><p>
Once you have a variable <code>token</code> that contains your API key, you can
leverage the <code>QiskitRuntimeService.save_account()</code> to save the token your
computer for future use:
</p>
<div class="org-src-container">
<pre class="src src-python">QiskitRuntimeService.save_account(
    channel=<span style="color: #CC9393;">"ibm_quantum"</span>,
    token=token,
    overwrite=<span style="color: #BFEBBF;">True</span>,
    set_as_default=<span style="color: #BFEBBF;">True</span>)
</pre>
</div></li>
</ul>
<p>
We can then put it all together in the following way:
</p>
<ol class="org-ol">
<li>Check your computer to see if there's a saved IBM quantum token.
<ol class="org-ol">
<li>If yes, use it</li>
<li>If not, prompt the user for the token
<ol class="org-ol">
<li>In this case, we replace the variable <code>token</code> with a call to
<code>getpass.getpass()</code>, which effectively supplies the token to
<code>QiskitRuntimeService()</code></li>
</ol></li>
</ol></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">try</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Load any previously-saved IBM Quantum tokens</span>
    QiskitRuntimeService.saved_accounts()
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">"Found and loaded a previously-saved IBM Quantum API token."</span>)
<span style="color: #F0DFAF; font-weight: bold;">except</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Otherwise, prompt user for token</span>
    QiskitRuntimeService.save_account(
    channel=<span style="color: #CC9393;">"ibm_quantum"</span>,
    token=getpass.getpass(<span style="color: #CC9393;">"No token found. Enter your IBM Quantum API token: "</span>),
    overwrite=<span style="color: #BFEBBF;">True</span>,
    set_as_default=<span style="color: #BFEBBF;">True</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">"Account saved successfully!"</span>)
</pre>
</div>

<pre class="example">
Found and loaded a previously-saved IBM Quantum API token.
</pre>
</div>
</div>


<div id="outline-container-org9d154dd" class="outline-4">
<h4 id="org9d154dd"><span class="section-number-4">7.2.4.</span> My Approach (not recommended)</h4>
<div class="outline-text-4" id="text-7-2-4">
<ul class="org-ul">
<li>I use this approach because I sometimes run Python code <i>outside</i> of a Jupyter
notebook, so I don't have an opportunity to dynamically input my password
using <code>getpass</code></li>
<li>My approach was to save a file on my computer, say, <code>~/.IBMQpass</code>
<ul class="org-ul">
<li>This is a text file containing only my IBM Quantum token</li>
</ul></li>
<li><p>
Then, I can load the token in a variable called <code>token</code> using code like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Read the token from a secure file</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Expand the '~' to the full path</span>
<span style="color: #DFAF8F;">file_path</span> = os.path.expanduser(<span style="color: #CC9393;">"~/.IBMQpass"</span>)
<span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span>(file_path, <span style="color: #CC9393;">"r"</span>) <span style="color: #F0DFAF; font-weight: bold;">as</span> <span style="color: #DCDCCC; font-weight: bold;">file</span>:
    <span style="color: #DFAF8F;">token</span> = <span style="color: #DCDCCC; font-weight: bold;">file</span>.read().strip()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Loaded IBM Quantum token: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(datetime.now()))
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2a68cb3" class="outline-3">
<h3 id="org2a68cb3"><span class="section-number-3">7.3.</span> Establish a Connection</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li><p>
To interface with the IBM cloud resources, we establish as
<code>QiskitRuntimeService</code> object, <code>service</code>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">service</span> = QiskitRuntimeService(channel=<span style="color: #CC9393;">'ibm_quantum'</span>)
</pre>
</div></li>

<li><p>
We can then use the <code>service</code> object to query available QPUs
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(service.backends())
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">in Jupyter notebook, you don't need print() ... just use</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">service.backends() as the last command in your cell.</span>
</pre>
</div>

<pre class="example">
[&lt;IBMBackend('ibm_brisbane')&gt;, &lt;IBMBackend('ibm_kyiv')&gt;, &lt;IBMBackend('ibm_sherbrooke')&gt;]
</pre></li>

<li>This is a list of objects of the <a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend">IBMBackend</a> class
<ul class="org-ul">
<li><p>
We can ask for the least-busy backend using the <code>.least_busy()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">save the least-busy backend as backend</span>
<span style="color: #DFAF8F;">backend</span> = service.least_busy()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(backend)
</pre>
</div>

<pre class="example">
&lt;IBMBackend('ibm_brisbane')&gt;
</pre></li>
</ul></li>

<li><p>
We can get information about a backend using properties such as <code>.name</code>,
<code>.version</code>, and <code>.num_qubits</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(
    f<span style="color: #CC9393;">"Name: </span>{backend.name}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"Version: </span>{backend.version}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"No. of qubits: </span>{backend.num_qubits}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
)
</pre>
</div>

<pre class="example">
Name: ibm_brisbane
Version: 2
No. of qubits: 127
</pre></li>
<li><p>
A backend has more attributes, which we can uncover if we use the <code>.__dict__</code>
property:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(backend.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_options': Options(shots=4000, memory=False, meas_level=&lt;MeasLevel.CLASSIFIED: 2&gt;, meas_return=&lt;MeasReturnType.AVERAGE: 'avg'&gt;, memory_slots=None, memory_slot_size=100, rep_time=None, rep_delay=None, init_qubits=True, use_measure_esp=None, use_fractional_gates=False, noise_model=None, seed_simulator=None), '_provider': None, 'name': 'ibm_brisbane', 'description': None, 'online_date': datetime.datetime(2023, 1, 23, 5, 0, tzinfo=tzutc()), 'backend_version': '1.1.66', '_coupling_map': None, '_instance': 'ibm-q/open/main', '_service': &lt;QiskitRuntimeService&gt;, '_api_client': &lt;qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x122bed850&gt;, '_configuration': &lt;qiskit_ibm_runtime.models.backend_configuration.PulseBackendConfiguration object at 0x122915f90&gt;, '_properties': &lt;qiskit_ibm_runtime.models.backend_properties.BackendProperties object at 0x126f1a9d0&gt;, '_defaults': &lt;qiskit_ibm_runtime.models.pulse_defaults.PulseDefaults object at 0x126ccbdd0&gt;, '_target': &lt;qiskit.transpiler.target.Target object at 0x1206080a0&gt;, '_max_circuits': 300, '_session': None}
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org552e72d" class="outline-3">
<h3 id="org552e72d"><span class="section-number-3">7.4.</span> Define Sampler Instances</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li><p>
We will create backends so we can compare a simulation using <code>AerSimulator()</code>
against a calculation on actual quantum hardware
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">backend_aer</span> = AerSimulator() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator backend</span>
<span style="color: #DFAF8F;">backend_qpu</span> = backend <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">hardware backend</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(backend_aer))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(backend_qpu))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit_aer.backends.aer_simulator.AerSimulator'&gt;
&lt;class 'qiskit_ibm_runtime.ibm_backend.IBMBackend'&gt;
</pre></li>

<li><p>
We now use the backends to define samplers
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">sampler_aer</span> = SamplerV2(backend_aer) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for simulator</span>
<span style="color: #DFAF8F;">sampler_qpu</span> = SamplerV2(backend_qpu) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for QPU</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(sampler_aer))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(sampler_qpu))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit_ibm_runtime.sampler.SamplerV2'&gt;
&lt;class 'qiskit_ibm_runtime.sampler.SamplerV2'&gt;
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org2081d73" class="outline-3">
<h3 id="org2081d73"><span class="section-number-3">7.5.</span> Create Some Circuits</h3>
<div class="outline-text-3" id="text-7-5">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1</span> = QuantumCircuit(1)
qc1.h(0)
qc1.measure_all()
qc1.draw()
</pre>
</div>


<div id="orgd796055" class="figure">
<p><img src="./img/simQPUckt.png" alt="simQPUckt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 20: </span>This circuit is designed for simulation and implementation on actual IBM quantum hardware.</p>
</div>

<ul class="org-ul">
<li>A parametrized circuit is create as a second circuit to test</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#952;</span> = Parameter(<span style="color: #CC9393;">'&#952;'</span>)
<span style="color: #DFAF8F;">&#981;</span> = Parameter(<span style="color: #CC9393;">'&#981;'</span>)

<span style="color: #DFAF8F;">qr</span> = QuantumRegister(2, name=<span style="color: #CC9393;">'q'</span>)

<span style="color: #DFAF8F;">cr</span> = ClassicalRegister(2, name=<span style="color: #CC9393;">'SomeName'</span>)

<span style="color: #DFAF8F;">qc2</span> = QuantumCircuit( qr, cr )
qc2.rx(&#952;,1)
qc2.cry(&#981;,1,0)
qc2.measure(qr, cr)
qc2.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="orgd3564a4" class="figure">
<p><img src="./img/simQPUckt2.png" alt="simQPUckt2.png" width="480px" />
</p>
<p><span class="figure-number">Figure 21: </span>This parameterized circuit provides a second circuit to compare in simulation and on actual hardware.</p>
</div>

<ul class="org-ul">
<li><p>
Next, we define angles for use with circuit 2:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">angles</span> = [[&#960;/4, &#960;/2], [&#960;/3, &#960;], [&#960;/2, &#960;]]
</pre>
</div>

<ul class="org-ul">
<li>The there are three sets of parameters</li>
<li>Each set has two angles, one for each parameter</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orge0df7b9" class="outline-3">
<h3 id="orge0df7b9"><span class="section-number-3">7.6.</span> Transpile the Circuits</h3>
<div class="outline-text-3" id="text-7-6">
</div>
<div id="outline-container-org1973d9c" class="outline-4">
<h4 id="org1973d9c"><span class="section-number-4">7.6.1.</span> Circuit 1 (Aer)</h4>
<div class="outline-text-4" id="text-7-6-1">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#orgd796055">20</a> for the <code>AerSimulator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1_aer</span> = transpile( qc1, backend=backend_aer)
qc1_aer.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>

<pre class="example">
#+attr_html: :width 480px
#+caption: The circuit of Figure [[fig:simQPUckt1]] is transpiled for the =AerSimulator=.
[[./img/simQPUckt1trans_aer.png]]
</pre>



<div id="org19a1e3a" class="figure">
<p><img src="./img/simQPUckt1trans_aer.png" alt="simQPUckt1trans_aer.png" width="480px" />
</p>
<p><span class="figure-number">Figure 22: </span>The circuit of Figure <a href="#orgd796055">20</a> is transpiled for the <code>AerSimulator</code>.</p>
</div>
</div>
</div>

<div id="outline-container-orga618686" class="outline-4">
<h4 id="orga618686"><span class="section-number-4">7.6.2.</span> Circuit 2 (Aer)</h4>
<div class="outline-text-4" id="text-7-6-2">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#orgd3564a4">21</a> for the <code>AerSimulator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2_aer</span> = transpile( qc2, backend=backend_aer)
qc2_aer.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org1f66d7c" class="figure">
<p><img src="./img/simQPUckt2trans_aer.png" alt="simQPUckt2trans_aer.png" width="480px" />
</p>
<p><span class="figure-number">Figure 23: </span>The circuit of Figure <a href="#orgd3564a4">21</a> is transpiled for the <code>AerSimulator</code>.</p>
</div>


<ul class="org-ul">
<li>We also transpile and optimize the circuit <code>qc2</code>
<ul class="org-ul">
<li><p>
To do this, we use the <code>generate_preset_pass_manager</code> function
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #DFAF8F;">target</span> = backend_aer.target
<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(target=target, optimization_level=1)
<span style="color: #DFAF8F;">qc2_aer</span> = pm.run(qc2)
qc2_aer.draw( reverse_bits=<span style="color: #BFEBBF;">True</span> )
</pre>
</div>


<div id="orgcb4327f" class="figure">
<p><img src="./img/simQPUckt2trans_aer_pm.png" alt="simQPUckt2trans_aer_pm.png" width="480px" />
</p>
<p><span class="figure-number">Figure 24: </span>Here, the circuit of Figure <a href="#orgd3564a4">21</a> is transpiled using a pass manager. It is the same as the result in Figure <a href="#org1f66d7c">23</a>.</p>
</div></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orga04e89f" class="outline-4">
<h4 id="orga04e89f"><span class="section-number-4">7.6.3.</span> Circuit 1 (QPU)</h4>
<div class="outline-text-4" id="text-7-6-3">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#orgd796055">20</a> for the quantum hardware</li>
<li>Since the hardware has many more qubits than the circuit, we use
<code>idle_wires=False</code> to suppress the display of idle qubits when we use the
<code>.draw()</code> method</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1_qpu</span> = transpile( qc1, backend=backend_qpu)
qc1_qpu.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>, idle_wires=<span style="color: #BFEBBF;">False</span> )
</pre>
</div>


<div id="orgebfe378" class="figure">
<p><img src="./img/simQPUckt1trans_qpu.png" alt="simQPUckt1trans_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 25: </span>The circuit of Figure <a href="#orgd796055">20</a> is transpiled for the quantum hardware.</p>
</div>
</div>
</div>
<div id="outline-container-orga6cca0d" class="outline-4">
<h4 id="orga6cca0d"><span class="section-number-4">7.6.4.</span> Circuit 2 (QPU)</h4>
<div class="outline-text-4" id="text-7-6-4">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#orgd3564a4">21</a> for the quantum hardware</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">target</span> = backend_qpu.target
<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(target=target, optimization_level=1)
<span style="color: #DFAF8F;">qc2_qpu</span> = pm.run(qc2)
qc2_qpu.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>, idle_wires=<span style="color: #BFEBBF;">False</span> )
</pre>
</div>


<div id="org8981446" class="figure">
<p><img src="./img/simQPUckt2trans_qpu.png" alt="simQPUckt2trans_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 26: </span>The circuit of Figure <a href="#orgd3564a4">21</a> is transpiled for the quantum hardware.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge9d2ee7" class="outline-3">
<h3 id="orge9d2ee7"><span class="section-number-3">7.7.</span> Simulate the Circuits</h3>
<div class="outline-text-3" id="text-7-7">
<ul class="org-ul">
<li>The sampler <code>.run()</code> method triggers the simulation</li>
</ul>
</div>
<div id="outline-container-orgffc87db" class="outline-4">
<h4 id="orgffc87db"><span class="section-number-4">7.7.1.</span> Simulate on the Aer Sampler</h4>
<div class="outline-text-4" id="text-7-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_aer</span> = sampler_aer.run( [ (qc1_aer, <span style="color: #BFEBBF;">None</span>, 100), (qc2_aer, angles, 1000) ] )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Print is not needed in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(job_aer.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_job_id': '9288fdc7-7e26-40d7-b919-d32ca46a577a', 'metadata': {}, '_future': &lt;Future at 0x145e6e6d0 state=running&gt;, '_function': &lt;bound method BackendSamplerV2._run of &lt;qiskit.primitives.backend_sampler_v2.BackendSamplerV2 object at 0x14581b4d0&gt;&gt;, '_args': ([SamplerPub(&lt;()&gt;), SamplerPub(&lt;(3,)&gt;)],), '_kwargs': {}}
</pre>
</div>
</div>

<div id="outline-container-orgcd70f80" class="outline-4">
<h4 id="orgcd70f80"><span class="section-number-4">7.7.2.</span> Run on Quantum Hardware</h4>
<div class="outline-text-4" id="text-7-7-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_qpu</span> = sampler_qpu.run( [ (qc1_qpu, <span style="color: #BFEBBF;">None</span>, 100), (qc2_qpu, angles, 1000) ] )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Print is not needed in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(job_qpu)
</pre>
</div>

<pre class="example">
/Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 625.82641167829 quantum seconds, but you only have 565 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
  warnings.warn(warning_message)
&lt;RuntimeJobV2('cya60g201rbg008jq0v0', 'sampler')&gt;
</pre>


<ul class="org-ul">
<li>Once your job is sumbitted, it IBM Quantum will assign it a unique job
ID.</li>
<li>Let's see what information is embedded in the job<sub>qpu</sub> object:</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(job_qpu.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_job_id': 'cya60g201rbg008jq0v0', 'metadata': {}, '_backend': &lt;IBMBackend('ibm_brisbane')&gt;, '_api_client': &lt;qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x14533be50&gt;, '_interim_results': None, '_creation_date': None, '_program_id': 'sampler', '_reason': None, '_reason_code': None, '_error_message': None, '_image': None, '_final_interim_results': False, '_service': &lt;QiskitRuntimeService&gt;, '_session_id': None, '_tags': None, '_usage_estimation': {}, '_version': 2, '_queue_info': None, '_user_callback': None, '_status': 'INITIALIZING', '_interim_result_decoder': &lt;class 'qiskit_ibm_runtime.utils.result_decoder.ResultDecoder'&gt;, '_final_result_decoder': &lt;class 'qiskit_ibm_runtime.utils.sampler_result_decoder.SamplerResultDecoder'&gt;, '_ws_client_future': None, '_result_queue': &lt;queue.Queue object at 0x1401a57d0&gt;, '_ws_client': &lt;qiskit_ibm_runtime.api.clients.runtime_ws.RuntimeWebsocketClient object at 0x1404550d0&gt;}
</pre>

<ul class="org-ul">
<li>We can obtain using the .job<sub>id</sub>() method.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_id</span> = job_qpu.job_id()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">"Your job's identifier is: </span>{job_id}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
Your job's identifier is: cya60g201rbg008jq0v0
</pre>


<ul class="org-ul">
<li><p>
As long as our Juptyer Lab notebook is open, we can access our job through the
<code>job_id</code> object using the <code>result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_qpu</span> = job_qpu.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_qpu)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=100, num_bits=1&gt;)), metadata={'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(&lt;shape=(3,), num_shots=1000, num_bits=2&gt;), shape=(3,)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([SliceSpan(&lt;start='2025-01-25 03:53:39', stop='2025-01-25 03:53:54', size=100&gt;), SliceSpan(&lt;start='2025-01-25 03:53:39', stop='2025-01-25 03:53:52', size=3000&gt;)])}, 'version': 2})
</pre></li>

<li>If we shut down our Jupyter Lab notebook, we clear the memory, and the information stored in job<sub>id</sub> is lost.</li>
<li>The job ID is important because we can retrieve the results from IBM using
this ID.</li>
<li>Thus, it may be helpful to record the job ID somewhere. As a fallback, we can
always go to the IBM Quantum portal and then find the job.</li>
</ul>
</div>
</div>
<div id="outline-container-orgdf9d8e6" class="outline-4">
<h4 id="orgdf9d8e6"><span class="section-number-4">7.7.3.</span> Get Results from the <code>AerSampler</code></h4>
<div class="outline-text-4" id="text-7-7-3">
<ul class="org-ul">
<li><p>
View results:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_aer</span> = job_aer.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_aer)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=100, num_bits=1&gt;)), metadata={'shots': 100, 'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(&lt;shape=(3,), num_shots=1000, num_bits=2&gt;), shape=(3,)), metadata={'shots': 1000, 'circuit_metadata': {}})], metadata={'version': 2})
</pre></li>

<li><p>
We retrieve the counts from the Aer sampler results:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_qc1_aer</span> = result_aer[0].data.meas.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_qc1_aer)
</pre>
</div>

<pre class="example">
{'0': 56, '1': 44}
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org682560c" class="outline-4">
<h4 id="org682560c"><span class="section-number-4">7.7.4.</span> Comparing Simulation and QPU Results</h4>
<div class="outline-text-4" id="text-7-7-4">
<ul class="org-ul">
<li><p>
When comparing results, it's usually a great idea to make a visualization
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fig</span> = plot_distribution([counts_qc1_aer, counts_qc1_qpu],
                        legend=[<span style="color: #CC9393;">'Simulator'</span>, <span style="color: #CC9393;">'QPU'</span>])
</pre>
</div>

<pre class="example">
Saved figure
</pre>



<div id="org31ab261" class="figure">
<p><img src="./img/compareCountsAerQPU.png" alt="compareCountsAerQPU.png" width="620px" />
</p>
<p><span class="figure-number">Figure 27: </span>Counts from the QPU are compared against those from the Aer simulator for circuit 1.</p>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org56e11a2" class="outline-3">
<h3 id="org56e11a2"><span class="section-number-3">7.8.</span> Simulation vs QPU: Estimator</h3>
<div class="outline-text-3" id="text-7-8">
<ul class="org-ul">
<li>Estimators get us not counts, but expectation values for observables.</li>
</ul>
</div>
<div id="outline-container-org339ee76" class="outline-4">
<h4 id="org339ee76"><span class="section-number-4">7.8.1.</span> Defining Estimator Objects</h4>
<div class="outline-text-4" id="text-7-8-1">
<ul class="org-ul">
<li><p>
Define Aer and QPU estimators:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">estimator_aer</span> = EstimatorV2( backend_aer )
<span style="color: #DFAF8F;">estimator_qpu</span> = EstimatorV2( backend_qpu )
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgc546533" class="outline-4">
<h4 id="orgc546533"><span class="section-number-4">7.8.2.</span> Defining Observable Operators</h4>
<div class="outline-text-4" id="text-7-8-2">
<ul class="org-ul">
<li><p>
We also need observable(s) to supply for the estimators:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">obsv_list</span> = [[SparsePauliOp([<span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"IY"</span>], [0.5, 0.5])],
             [SparsePauliOp([<span style="color: #CC9393;">"XX"</span>], [1])],
             [SparsePauliOp([<span style="color: #CC9393;">"IY"</span>], [1])]]
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgc41bede" class="outline-4">
<h4 id="orgc41bede"><span class="section-number-4">7.8.3.</span> Layout Mapping</h4>
<div class="outline-text-4" id="text-7-8-3">
<ul class="org-ul">
<li><p>
This observable must be mapped to the circuit of interest.
</p>
<ul class="org-ul">
<li>This is important because the hardware may have many more (idle) qubits than
our circuit does.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">layout</span> = qc2_qpu.layout 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(layout))

<span style="color: #DFAF8F;">obsv_qpu</span> = []

<span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list:
    <span style="color: #DFAF8F;">obsv_temp</span> = obsv[0].apply_layout(layout)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_temp)
    obsv_qpu.append([obsv_temp])
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.transpiler.layout.TranspileLayout'&gt;
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
              coeffs=[0.5+0.j, 0.5+0.j])
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX'],
              coeffs=[1.+0.j])
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
              coeffs=[1.+0.j])
</pre></li>
<li>The simulated estimator does <b>not</b> need the modified observables, and we will run
only one circuit</li>
</ul>
</div>
</div>

<div id="outline-container-org5be88e0" class="outline-4">
<h4 id="org5be88e0"><span class="section-number-4">7.8.4.</span> Simulation</h4>
<div class="outline-text-4" id="text-7-8-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job2_aer</span> = estimator_aer.run([(qc2_aer, obsv_list, angles, 0.01)])
</pre>
</div>
</div>
</div>

<div id="outline-container-org2bbf845" class="outline-4">
<h4 id="org2bbf845"><span class="section-number-4">7.8.5.</span> QPU Submission</h4>
<div class="outline-text-4" id="text-7-8-5">
<div class="org-src-container">
<pre class="src src-python" id="org150ae3c"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">If you've never submitted the job before, set job2_id to None</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">job2_id = None</span>
<span style="color: #DFAF8F;">job2_id</span> = <span style="color: #CC9393;">'cya6t20nrmz000862cs0'</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span> job2_id <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
    <span style="color: #DFAF8F;">job2_qpu</span> = estimator_qpu.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
    <span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Submitted new job with id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Loads by ID a pre-existing job from IBM Quantum </span>
    <span style="color: #DFAF8F;">job2_gpu</span> = QiskitRuntimeService().job(job2_id)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Loaded old job with id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
</pre>
</div>

<pre class="example">
/Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 647.0957899365619 quantum seconds, but you only have 546 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
  warnings.warn(warning_message)
Submitted new job with id: cya6t20nrmz000862cs0
</pre>



<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(job2_qpu)
<span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Job id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
<span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Status: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.status()) )

<span style="color: #F0DFAF; font-weight: bold;">if</span> job2_qpu.status() == <span style="color: #CC9393;">'DONE'</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(job2_qpu.metrics())
</pre>
</div>

<pre class="example">
&lt;RuntimeJobV2('cya6t20nrmz000862cs0', 'estimator')&gt;
Job id: cya6t20nrmz000862cs0
Status: DONE
{'bss': {'seconds': 18}, 'usage': {'quantum_seconds': 18, 'seconds': 18}, 'timestamps': {'created': '2025-01-25T04:48:08.442Z', 'finished': '2025-01-25T04:48:43.251Z', 'running': '2025-01-25T04:48:11.227Z'}, 'executions': 62144, 'num_circuits': 224, 'num_qubits': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127], 'circuit_depths': [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23], 'qiskit_version': 'qiskit_ibm_runtime-0.33.2,qiskit-1.3.1*,qiskit_aer-0.16.0*', 'estimated_start_time': '2025-01-25T04:48:09.875Z', 'estimated_completion_time': '2025-01-25T04:48:27.875Z', 'position_in_queue': None, 'position_in_provider': None}
</pre>


<ul class="org-ul">
<li>My job submission showed a job ID of <code>cya6t20nrmz000862cs0</code>
<ul class="org-ul">
<li>If we want to shut down or Jupyter notebook, we need to record this job number</li>
<li>Additionally, we want to go back to Listing <a href="#org150ae3c">2</a> and comment out
<code>job2_id = None</code>, and uncomment <code>job2_id = 'cya6t20nrmz000862cs0'</code>
<ul class="org-ul">
<li>This will prevent us from running a redundant job, and rather let us use
the results already calculated</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgbbb7642" class="outline-4">
<h4 id="orgbbb7642"><span class="section-number-4">7.8.6.</span> Retrieve Estimator Results</h4>
<div class="outline-text-4" id="text-7-8-6">
<ul class="org-ul">
<li>We get the expectation values by indexing the result and using the <code>.data.evs</code>
member data</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">exp_vals_aer</span> = job2_aer.result()[0].data.evs
<span style="color: #DCDCCC; font-weight: bold;">print</span>(exp_vals_aer)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(angles)
</pre>
</div>

<pre class="example">
[[-0.0055 -0.0028  0.0034]
 [-0.0104 -0.0038  0.0082]
 [-0.0006 -0.0018 -0.0014]]
[[0.7853981633974483, 1.5707963267948966], [1.0471975511965976, 3.141592653589793], [1.5707963267948966, 3.141592653589793]]
</pre>


<p>
The above list of list contains the expectation values.
</p>
<ul class="org-ul">
<li>There are three sublists, each corresponding to one of the three different
parameter sets.</li>
<li>Each sublist is a set of three expectation values corresponding to the three
observables in <code>obs_qpu</code>.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org79416b8" class="outline-3">
<h3 id="org79416b8"><span class="section-number-3">7.9.</span> Three Runtime Execution Methods</h3>
<div class="outline-text-3" id="text-7-9">
<ol class="org-ol">
<li>Job. Send a list of Pubs, receive PUB results</li>
<li>Session. This is good for hybrid algorithms, such VQE and VAOA. Iterations of
these algorithms depend on one another. Classical processing is done in the
cloud.</li>
<li>Batch. A series of independent jobs may be executed in parallel.</li>
</ol>
</div>
<div id="outline-container-org5c61db1" class="outline-4">
<h4 id="org5c61db1"><span class="section-number-4">7.9.1.</span> Sessions</h4>
<div class="outline-text-4" id="text-7-9-1">
<p>
We use context managers, soemthing like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> Session
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime.fake_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> Fake

<span style="color: #DFAF8F;">obsv_qpu</span> = [[obsv[0].apply_laout(qc2_qpu.layout) <span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_qpu)

<span style="color: #F0DFAF; font-weight: bold;">with</span> Session(backend=backend_man) <span style="color: #F0DFAF; font-weight: bold;">as</span> session
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Sampler primitive within the session</span>
    sampler = SamplerV2(session=session)
    job = sampler.run([(qc2_qpu, angles, 1000)])
    pub_result = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'1st Circuit Counts: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.SomeName.get_counts(0)}<span style="color: #CC9393;"> </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">'</span>)

    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Estimator primitive within the session</span>
    estimator = EstimatorV2(session=session)
    job = estimator.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
    pub_result = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Expectation values: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.evs}<span style="color: #CC9393;">'</span>)        
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="orgcb6ac72"></a>Session on a Fake Backend<br />
<div class="outline-text-5" id="text-7-9-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> Session
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime.fake_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> FakeManilaV2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">backend_fake</span> = FakeManilaV2()
<span style="color: #DFAF8F;">sampler_fake</span> = SamplerV2( backend_fake )
</pre>
</div>
</div>
</li>

<li><a id="orgd20e9eb"></a>Transpile Circuit for <code>FakeManilaV2</code><br />
<div class="outline-text-5" id="text-7-9-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2_fake</span> = transpile(qc2, backend=backend_fake)
qc2_fake.draw()
</pre>
</div>


<div id="org55e7541" class="figure">
<p><img src="./img/fakeManillaCkt.png" alt="fakeManillaCkt.png" width="680px" />
</p>
<p><span class="figure-number">Figure 28: </span>A circuit is transpiled for simulation on the <code>FakeManilaV2</code> backend.</p>
</div>
</div>
</li>

<li><a id="orgf8e4483"></a>Layout Mapping for Observable<br />
<div class="outline-text-5" id="text-7-9-1-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">obsv_fake</span> = [[obsv[0].apply_layout(qc2_fake.layout) <span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list]]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_fake)
</pre>
</div>

<pre class="example">
[[SparsePauliOp(['XXIII', 'YIIII'],
              coeffs=[0.5+0.j, 0.5+0.j]), SparsePauliOp(['XXIII'],
              coeffs=[1.+0.j]), SparsePauliOp(['YIIII'],
              coeffs=[1.+0.j])]]
</pre>
</div>
</li>


<li><a id="org1b5697e"></a>Run a Session<br />
<div class="outline-text-5" id="text-7-9-1-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">with</span> Session(backend=backend_fake) <span style="color: #F0DFAF; font-weight: bold;">as</span> session:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Sampler primitive within the session</span>
    <span style="color: #DFAF8F;">sampler</span> = SamplerV2(session)
    <span style="color: #DFAF8F;">job</span> = sampler.run([(qc2_fake, angles, 1000)])
    <span style="color: #DFAF8F;">pub_result</span> = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'1st Circuit Counts: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.SomeName.get_counts(0)}<span style="color: #CC9393;"> </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">'</span>)

    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Estimator primitive within the session</span>
    <span style="color: #DFAF8F;">estimator</span> = EstimatorV2(session)
    <span style="color: #DFAF8F;">job</span> = estimator.run([(qc2_fake, obsv_fake, angles, 0.01)])
    <span style="color: #DFAF8F;">pub_result</span> = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Expectation values: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.evs}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
1st Circuit Counts: 
 {'10': 72, '00': 854, '11': 62, '01': 12} 

Expectation values: 
 [[ 0.0097 -0.0074  0.022 ]]
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Dr. E.P. Blair</p>
<p class="date">Created: 2025-02-26 Wed 22:22</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
