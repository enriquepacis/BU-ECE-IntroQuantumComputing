<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-03-11 Tue 22:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Example: Bell Circuits</title>
<meta name="author" content="Dr. E.P. Blair" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Example: Bell Circuits</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org7ea259d">1. <code>qiskit_aer</code> Primitives</a>
<ul>
<li><a href="#org2463f83">1.1. Example: Bell Circuits and the <code>SamplerV2</code> Class</a>
<ul>
<li><a href="#org44122b9">1.1.1. Imports</a></li>
<li><a href="#org2f9141c">1.1.2. Bell Circuits</a></li>
<li><a href="#org63c8845">1.1.3. Transpilation</a></li>
<li><a href="#orgddf0c1e">1.1.4. Forming PUBs</a></li>
<li><a href="#org98ed83a">1.1.5. Simulating the Circuits</a></li>
<li><a href="#orgd4ffca1">1.1.6. Accessing Results</a></li>
</ul>
</li>
<li><a href="#org1d4b6d0">1.2. Summary</a></li>
</ul>
</li>
<li><a href="#org5d541b6">2. Bell Circuits on IBM Quantum Hardware</a>
<ul>
<li><a href="#org7e74d5e">2.1. Imports</a></li>
<li><a href="#org4cb6712">2.2. The Bell Circuits</a></li>
<li><a href="#orgf0e3c61">2.3. Transpilation</a>
<ul>
<li><a href="#org55453aa">2.3.1. Overview</a></li>
<li><a href="#orgb9100de">2.3.2. Getting Your IBM Quantum API Token</a></li>
<li><a href="#org3b4d83e">2.3.3. The getpass Package</a></li>
<li><a href="#orgec7ff29">2.3.4. My Approach to Loading My Token (not recommended)</a></li>
<li><a href="#org02d53aa">2.3.5. Establish a Connection to IBM Quantum</a></li>
<li><a href="#orgd70d80d">2.3.6. Transpilation</a></li>
<li><a href="#org83d6eee">2.3.7. Forming PUBs</a></li>
</ul>
</li>
<li><a href="#org803d63d">2.4. Running the Circuits</a></li>
<li><a href="#org7212ecb">2.5. Accessing the Results</a></li>
</ul>
</li>
<li><a href="#orga0f9350">3. Bell Circuits on Simulated Hardware</a>
<ul>
<li><a href="#org0af9b3d">3.1. Overview</a></li>
<li><a href="#org3b38d6e">3.2. Instantiate a Fake Backend</a></li>
<li><a href="#orge75b9f3">3.3. Transpilation</a></li>
<li><a href="#org2370147">3.4. Forming PUBs</a></li>
<li><a href="#orge5959a0">3.5. Running the Circuits</a></li>
<li><a href="#orgd92a9e4">3.6. Accessing the Results</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org7ea259d" class="outline-2">
<h2 id="org7ea259d"><span class="section-number-2">1.</span> <code>qiskit_aer</code> Primitives</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>Primitives</b> provide an interface to quantum processing units (QPUs, actual
quantum hardware). Version 2 (V2) Primitives are the current allowed interface
to IBM QPUs. To access real IBM Quantum hardware, we use the
<code>qiskit_ibm_runtime</code> package, which includes two primitives include:
</p>
<ol class="org-ol">
<li><code>SamplerV2</code> for obtaining counts from circuits.</li>
<li><code>EstimatorV2</code>, for estimating expectation values from circuit measurements.</li>
</ol>

<p>
The older simulator, <code>BasicSimulator</code>, and the <code>qiskit_aer.AerSimulator</code> class,
both provide an older simulation interface, which mimics an older (and
deprecated) interface to actual hardware. Only <code>qiskit_aer.primitives</code>, however,
provides <code>SamplerV2</code> and <code>EstimatorV2</code> primitives to mimic their counterparts
from <code>qiskit_ibm_runtime</code>. 
</p>

<p>
We demonstrate the use of <code>qiskit_aer</code> primitives.
</p>
</div>

<div id="outline-container-org2463f83" class="outline-3">
<h3 id="org2463f83"><span class="section-number-3">1.1.</span> Example: Bell Circuits and the <code>SamplerV2</code> Class</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Bell circuits are used to create entangled pairs of qubits. We will simulate two
of the four Bell circuits using the <code>SamplerV2</code> class provided in
<code>qiskit_aer.primitives</code>.
</p>
</div>

<div id="outline-container-org44122b9" class="outline-4">
<h4 id="org44122b9"><span class="section-number-4">1.1.1.</span> Imports</h4>
<div class="outline-text-4" id="text-1-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2

<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Optional</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Imports complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Imports complete at 2025-03-11 21:33:03.353820
</pre>


<div class="note" id="org8a42263">
<p>
<b>Note</b>
</p>

<p>
If you are using Jupyter Lab, you need not use <code>dateime</code> and <code>print()</code> to
indicate completion.
</p>

<p>
Here, I'm using <code>datetime</code> and <code>print()</code> because I'm developing these notes in
Emacs org mode. Here, Python code blocks in session mode often do not indicate
errors, and completion messages help me know the code block has executed
properly.
</p>

</div>
</div>
</div>

<div id="outline-container-org2f9141c" class="outline-4">
<h4 id="org2f9141c"><span class="section-number-4">1.1.2.</span> Bell Circuits</h4>
<div class="outline-text-4" id="text-1-1-2">
</div>
<ol class="org-ol">
<li><a id="org01f2ed9"></a>First Case<br />
<div class="outline-text-5" id="text-1-1-2-1">
<p>
Not only must we form a Bell circuit, but we must also add measurement
gates. The measurement gates are required if we wish to obtain circuit counts.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">Bell00</span> = QuantumCircuit(2)
Bell00.h(0)
Bell00.cx(0,1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure_all() adds a classical register named "meas"</span>
Bell00.measure_all()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(Bell00)
</pre>
</div>

<pre class="example">
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
</pre>




<div id="orgcb50f8c" class="figure">
<p><img src="./img/Bell00ckt.png" alt="Bell00ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 1: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 00 \right\rangle + \left|11  \right\rangle \right)/\sqrt{2} \).</p>
</div>
</div>
</li>

<li><a id="org986e49e"></a>A Second Circuit<br />
<div class="outline-text-5" id="text-1-1-2-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">Bell01</span> = QuantumCircuit(2)
Bell01.h(0)
Bell01.x(1)
Bell01.cx(0,1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure_all() adds a classical register named "meas"</span>
Bell01.measure_all()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(Bell01)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 

Code block complete at 2025-03-11 21:34:11.983964
</pre>




<div id="org2e19a71" class="figure">
<p><img src="./img/Bell01ckt.png" alt="Bell01ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 2: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 01 \right\rangle + \left|10  \right\rangle \right)/\sqrt{2} \).</p>
</div>
</div>
</li>



<li><a id="org928c4da"></a>Join Circuits into a List<br />
<div class="outline-text-5" id="text-1-1-2-3">
<p>
Now, we form a list of circuits.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Form a list of Bell circuits</span>
<span style="color: #DFAF8F;">BellCkts</span> = [Bell00, Bell01]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 21:34:29.318626
</pre>
</div>
</li>
</ol>
</div>

<div id="outline-container-org63c8845" class="outline-4">
<h4 id="org63c8845"><span class="section-number-4">1.1.3.</span> Transpilation</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
We can now transpile our list of circuits. To <b>transpile</b> a circuit is to form
an equivalent circuit using a set of gates (instruction set architecture, or
ISA) that is supported on a specific quantum processing unit (QPU).
</p>

<p>
To transpile, we tools called <code>pass_managers</code>. <code>qiskit</code> has some preset pass
managers, which make it more convenient.
</p>

<p>
One other piece of information we must provide is the target backend. The target
backend could be an <code>AerSimulator()</code>, a local model of a QPU (<code>FakeBackend</code>), or
an actual QPU. Different resources may have different ISAs, so it is important
to specify your transpilation target.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> sys
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">create a backend</span>
<span style="color: #DFAF8F;">backend_aer</span> = AerSimulator()

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Specify the target backend for transpilation</span>
<span style="color: #DFAF8F;">target_aer</span> = backend_aer.target

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Create a pass manager object to perform the transpilation</span>
<span style="color: #DFAF8F;">pm_aer</span> = generate_preset_pass_manager(target=target_aer, optimization_level=1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Want to know more about the pass manager? Start printing things about it.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'Class of pm_aer: {type(pm_aer)}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer: {pm_aer}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer attributes: {pm_aer.__dict__}')</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 21:34:38.875126
</pre>



<p>
Next, we can transpile our circuits for the desired backend:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">BellCkts_aer</span> = pm_aer.run( BellCkts ) 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Code block complete at 2025-03-11 21:34:50.041597
</pre>


<p>
We may wish to compare our transpiled circuit to our original circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx, ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(BellCkts):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'='</span>*70 + f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">idx = </span>{idx}<span style="color: #CC9393;">'</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Original'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(ckt)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Transpiled'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(BellCkts_aer[idx])      

</pre>
</div>

<pre class="example" id="org0ddce87">
======================================================================
idx = 0
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
======================================================================
idx = 1
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
</pre>

<p>
In this case, both the original circuit and the transpiled circuit are the
same. When we try to use a <code>FakeBackend</code> or a real QPU, however, the transpiled
circuit may look quite different from the origial circuit you designed.
</p>
</div>
</div>

<div id="outline-container-orgddf0c1e" class="outline-4">
<h4 id="orgddf0c1e"><span class="section-number-4">1.1.4.</span> Forming PUBs</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
Now that we have transpiled circuits that we can run on a simulator&#x2013;or, if
transpiled properly, on actual hardware&#x2013;we can form a list of PUBs as a batch
of subtasks forming a job. A PUB is a "primitive unified bloc." Each PUB is a
tuple containing a circuit and circuit parameters, as in <code>(circ, params)</code>. Here,
the circuits we are dealing with are simple and do not require parameters. Thus,
they are said to be non-parameterized circuits, and we use <code>None</code> for <code>params</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">PUBs_aer</span> = [ (ckt, <span style="color: #BFEBBF;">None</span>) <span style="color: #F0DFAF; font-weight: bold;">for</span> ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> BellCkts_aer ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a list of PUBs for the Aer SamplerV2 at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Your list of PUBs contains </span>{<span style="color: #DCDCCC; font-weight: bold;">len</span>(PUBs_aer)}<span style="color: #CC9393;"> PUBs.'</span>)
</pre>
</div>

<pre class="example">
Created a list of PUBs for the Aer SamplerV2 at 2025-03-11 21:35:14.715106
Your list of PUBs contains 2 PUBs.
</pre>
</div>
</div>

<div id="outline-container-org98ed83a" class="outline-4">
<h4 id="org98ed83a"><span class="section-number-4">1.1.5.</span> Simulating the Circuits</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
Here, we will use <code>qiskit_aer.primitives.SamplerV2()</code> as our simulation
platform. First, we instantiate a <code>SamplerV2</code> object. Note: we import
`qiskit<sub>aer.primitives.SamplerV2</sub>~ as <code>Sampler</code> to distinguish it from the
<code>qiskit_ibm_runtime.SamplerV2</code> which we will use later.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Instantiate a sampler</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2 <span style="color: #F0DFAF; font-weight: bold;">as</span> Sampler

<span style="color: #DFAF8F;">sampler_aer</span> = Sampler() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for simulator, no arguments</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Run the `SamplerV2` simulation</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a SamplerV2 at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)

</pre>
</div>

<pre class="example">
Created a SamplerV2 at 2025-03-11 21:35:22.412285
</pre>


<p>
Finally, we use the <code>run()</code> method of our sampler. We will specify a shot count
of 4096, since we may wish to compare with results from actual hardware using a
<code>qiskit_ibm_runtime.SamplerV2</code> object. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Instantiate a sampler</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2 <span style="color: #F0DFAF; font-weight: bold;">as</span> Sampler

<span style="color: #DFAF8F;">job_sim</span> = sampler_aer.run( PUBs_aer, shots=4092 ) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulated job with 4092 shots</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Run the `SamplerV2` simulation</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Simulated the SamplerV2 at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)

</pre>
</div>

<pre class="example">
Simulated the SamplerV2 at 2025-03-11 21:35:26.778244
</pre>
</div>
</div>

<div id="outline-container-orgd4ffca1" class="outline-4">
<h4 id="orgd4ffca1"><span class="section-number-4">1.1.6.</span> Accessing Results</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
We can extract results from our job using its <code>.result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results_sim</span> = job_sim.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results_sim)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'shots': 4092, 'circuit_metadata': {}, 'simulator_metadata': {'time_taken_parameter_binding': 0.000166, 'max_memory_mb': 36864, 'time_taken_execute': 0.011682375, 'omp_enabled': True, 'max_gpu_memory_mb': 0, 'parallel_experiments': 1}}), SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'shots': 4092, 'circuit_metadata': {}, 'simulator_metadata': {'time_taken_parameter_binding': 0.000166, 'max_memory_mb': 36864, 'time_taken_execute': 0.011682375, 'omp_enabled': True, 'max_gpu_memory_mb': 0, 'parallel_experiments': 1}})], metadata={'version': 2})
</pre>


<p>
Since the list of PUBs contained two PUBs, our job has two results embedded in
it. We access them using an index, as in <code>job_sim[0]</code> and
<code>job_sim[1]</code>. Furthermore, to extract counts, we use the <code>.data</code> property for
each PUB result. We also must specify the name of the classical register on
which measurement results are stored. In this case, we used <code>.measure_all()</code> to
add measurement gates, so this creates a classical register named
<code>meas</code>. Finally, for our classical register, we use the <code>get_counts()</code> method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(results_sim[idx].data.meas.get_counts())

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
{'11': 2059, '00': 2033}
{'01': 2068, '10': 2024}
Code block complete at 2025-03-11 21:36:29.485855
</pre>


<p>
Indeed, we can print our results, but it is much nicer to plot them using a
histogram.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram

<span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Bell circuit </span>{idx}<span style="color: #CC9393;">'</span>)
    display(plot_histogram(results_sim[idx].data.meas.get_counts()))

</pre>
</div>

<p>
A histgoram for the results of Bell circuit 0 are shown here:
</p>

<div id="org1a281aa" class="figure">
<p><img src="./img/bell_ckt_results00.png" alt="bell_ckt_results00.png" width="480px" />
</p>
<p><span class="figure-number">Figure 3: </span>The measured  result is consistent with Bell circuit 0, which produces \(\left(\left|00 \right\rangle + \left|11 \right\rangle\right)/\sqrt{2}\).</p>
</div>


<p>
A similar histogram for measurements on Bell circuit 1 are shown here:
</p>

<div id="org0ff7a71" class="figure">
<p><img src="./img/bell_ckt_results01.png" alt="bell_ckt_results01.png" width="480px" />
</p>
<p><span class="figure-number">Figure 4: </span>The measured  result is consistent with Bell circuit 0, which produces \(\left(\left|01 \right\rangle + \left|10 \right\rangle\right)/\sqrt{2}\).</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org1d4b6d0" class="outline-3">
<h3 id="org1d4b6d0"><span class="section-number-3">1.2.</span> Summary</h3>
<div class="outline-text-3" id="text-1-2">
<p>
We have used a <code>qiskit_aer.primitives.SamplerV2</code> object to perform noise-free
simulations of quantum circuits.
</p>

<p>
A next step will be to perform similar computations on actual quantum hardware,
and then to compare the results.
</p>
</div>
</div>
</div>

<div id="outline-container-org5d541b6" class="outline-2">
<h2 id="org5d541b6"><span class="section-number-2">2.</span> Bell Circuits on IBM Quantum Hardware</h2>
<div class="outline-text-2" id="text-2">
<p>
To run the same Bell circuits on IBM hardware, we require the
<code>qiskit_ibm_runtime</code> package. For an equivalent to our previous simulation of
Bell circuits, we will also use the <code>SamplerV2</code> class.
</p>
</div>

<div id="outline-container-org7e74d5e" class="outline-3">
<h3 id="org7e74d5e"><span class="section-number-3">2.1.</span> Imports</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Let's begin by importing some tools we need from <code>qiskit_ibm_runtime</code>. We will
import the <code>SamplerV2</code> for getting measurement counts on actual hardware, and
<code>QiskitRuntimeService</code> for making a connection to IBM Quantum.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2, QiskitRuntimeService

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 21:38:10.249899
</pre>
</div>
</div>

<div id="outline-container-org4cb6712" class="outline-3">
<h3 id="org4cb6712"><span class="section-number-3">2.2.</span> The Bell Circuits</h3>
<div class="outline-text-3" id="text-2-2">
<p>
We do not recreate the Bell circuits here, since we already have created them.
Instead, we show them here once again.
</p>


<div id="org73ca9de" class="figure">
<p><img src="./img/Bell00ckt.png" alt="Bell00ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 5: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 00 \right\rangle + \left|11  \right\rangle \right)/\sqrt{2} \).</p>
</div>


<div id="orgfa0f12a" class="figure">
<p><img src="./img/Bell01ckt.png" alt="Bell01ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 6: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 01 \right\rangle + \left|10  \right\rangle \right)/\sqrt{2} \).</p>
</div>
</div>
</div>

<div id="outline-container-orgf0e3c61" class="outline-3">
<h3 id="orgf0e3c61"><span class="section-number-3">2.3.</span> Transpilation</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org55453aa" class="outline-4">
<h4 id="org55453aa"><span class="section-number-4">2.3.1.</span> Overview</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
To transpile our circuits, we first require a backend, which is the target ISA
for the transpilation process. To obtain a backend, we must use our IBM Quantum
API token. To do this, you need to create an IBM Quantum account if you don't
already have one; and you need to find your IBM Quantum API token.
</p>

<p>
We will take the following steps:
</p>
<ol class="org-ol">
<li>Register for an IBM Quantum account if you don't already have one.</li>
<li>Find your IBM Quantum API token</li>
<li>Load your token in Python for programmatic access to IBM Quantum.</li>
<li>Establish a connection to IBM Quantum using your API token.</li>
<li>Select a backend QPU</li>
<li>Transpile your circuits for the target backend</li>
</ol>
</div>
</div>

<div id="outline-container-orgb9100de" class="outline-4">
<h4 id="orgb9100de"><span class="section-number-4">2.3.2.</span> Getting Your IBM Quantum API Token</h4>
<div class="outline-text-4" id="text-2-3-2">
<ol class="org-ol">
<li>If you don't already have one, use your university e-mail account
(prefferable) to register for an account.</li>
<li>Once logged in, you can get your IBM token in one of two ways:
<ol class="org-ol">
<li>Visit your <a href="https://quantum.ibm.com">IBM Quantum Platform dashboard</a>
<ol class="org-ol">
<li><p>
In the upper right, you'll see a box where you can view or copy your
IBM Quantum API token
</p>

<div id="org66e47dc" class="figure">
<p><img src="./img/IBMQuantumDashboard.png" alt="IBMQuantumDashboard.png" width="360px" />
</p>
</div></li>
</ol></li>
<li><p>
Click the "Account" button (by default, it looks like an anonymized
profile pic). This brings up your <i>Profile Settings</i>
</p>

<div id="orga107e8f" class="figure">
<p><img src="./img/IBMQuantumAccountIcon.png" alt="IBMQuantumAccountIcon.png" width="360px" />
</p>
</div>
<ol class="org-ol">
<li>Below the <i>Profile Details</i> is an <i>API Token</i>. Click the icon that allows
you to copy you IBM Quantum API token. You will paste this information
elsewhere later.</li>
</ol></li>
</ol></li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> sys
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">create a backend</span>
<span style="color: #DFAF8F;">backend_aer</span> = AerSimulator()

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Specify the target backend for transpilation</span>
<span style="color: #DFAF8F;">target_aer</span> = backend_aer.target

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Create a pass manager object to perform the transpilation</span>
<span style="color: #DFAF8F;">pm_aer</span> = generate_preset_pass_manager(target=target_aer, optimization_level=1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Want to know more about the pass manager? Start printing things about it.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'Class of pm_aer: {type(pm_aer)}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer: {pm_aer}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer attributes: {pm_aer.__dict__}')</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 21:38:52.661463
</pre>
</div>
</div>


<div id="outline-container-org3b4d83e" class="outline-4">
<h4 id="org3b4d83e"><span class="section-number-4">2.3.3.</span> The <a href="https://docs.python.org/3/library/getpass.html">getpass</a> Package</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>This is a nice Python package that is useful in Jupyter notebooks</li>
<li>It allows you to prompt the user for a password that can be used later in the file.</li>
<li><p>
The basic usage is:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> getpass <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">this comes with standard Python</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This interactively prompts the user for their password</span>
<span style="color: #DFAF8F;">token</span> = getpass.getpass(<span style="color: #CC9393;">'Enter your password: '</span>)
</pre>
</div></li>
<li>You can then use <code>token</code> in an API call</li>
<li>This allows you to share Jupyter notebooks <i>without</i> also sharing your
password/token/API key.</li>
</ul>
</div>
</div>

<div id="outline-container-orgec7ff29" class="outline-4">
<h4 id="orgec7ff29"><span class="section-number-4">2.3.4.</span> My Approach to Loading My Token (not recommended)</h4>
<div class="outline-text-4" id="text-2-3-4">
<div class="note" id="org544010d">
<p>
If you are using a Jupyter Lab notebook, please ignore this section. This is
useful for me, since I'm coding in Emacs Org mode.
</p>

</div>
<ul class="org-ul">
<li>I use this approach because I sometimes run Python code <i>outside</i> of a Jupyter
notebook, so I don't have an opportunity to dynamically input my password
using <code>getpass</code></li>
<li>My approach was to save a file on my computer, say, <code>~/.IBMQpass</code>
<ul class="org-ul">
<li>This is a text file containing only my IBM Quantum token</li>
</ul></li>
<li><p>
Then, I can load the token in a variable called <code>token</code> using code like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Read the token from a secure file</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Expand the '~' to the full path</span>
<span style="color: #DFAF8F;">file_path</span> = os.path.expanduser(<span style="color: #CC9393;">"~/.IBMQpass"</span>)
<span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span>(file_path, <span style="color: #CC9393;">"r"</span>) <span style="color: #F0DFAF; font-weight: bold;">as</span> <span style="color: #DCDCCC; font-weight: bold;">file</span>:
    <span style="color: #DFAF8F;">token</span> = <span style="color: #DCDCCC; font-weight: bold;">file</span>.read().strip()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Loaded IBM Quantum token: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(datetime.now()))
</pre>
</div>

<pre class="example">

Loaded IBM Quantum token: 2025-03-11 21:39:16.412666
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org02d53aa" class="outline-4">
<h4 id="org02d53aa"><span class="section-number-4">2.3.5.</span> Establish a Connection to IBM Quantum</h4>
<div class="outline-text-4" id="text-2-3-5">
<ul class="org-ul">
<li><p>
To interface with the IBM cloud resources, we establish a
<code>QiskitRuntimeService</code> object, <code>service</code>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">service</span> = QiskitRuntimeService(channel=<span style="color: #CC9393;">'ibm_quantum'</span>)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Established a service at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Established a service at 2025-03-11 21:39:30.280964
</pre></li>

<li><p>
We can then use the <code>service</code> object to query available QPUs
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(service.backends())
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">in Jupyter notebook, you don't need print() ... just use</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">service.backends() as the last command in your cell.</span>
</pre>
</div>

<pre class="example">
[&lt;IBMBackend('ibm_brisbane')&gt;, &lt;IBMBackend('ibm_kyiv')&gt;, &lt;IBMBackend('ibm_sherbrooke')&gt;]
</pre></li>

<li>This is a list of objects of the <a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend">IBMBackend</a> class
<ul class="org-ul">
<li><p>
We can ask for the least-busy backend using the <code>.least_busy()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">save the least-busy backend as backend</span>
<span style="color: #DFAF8F;">backend_qpu</span> = service.least_busy()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Least busy QPU: </span>{backend_qpu}<span style="color: #CC9393;"> (</span>{datetime.now()}<span style="color: #CC9393;">)'</span>)
</pre>
</div>

<pre class="example">
Least busy QPU: &lt;IBMBackend('ibm_brisbane')&gt; (2025-03-11 21:39:45.853255)
</pre></li>
</ul></li>

<li><p>
We can get information about a backend using properties such as <code>.name</code>,
<code>.version</code>, and <code>.num_qubits</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(
    f<span style="color: #CC9393;">"Name: </span>{backend_qpu.name}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"Version: </span>{backend_qpu.version}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"No. of qubits: </span>{backend_qpu.num_qubits}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
)
</pre>
</div>

<pre class="example">
Name: ibm_brisbane
Version: 2
No. of qubits: 127
</pre></li>

<li>Now that we've picked a backend, we can transpile our circuits for that
backend.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd70d80d" class="outline-4">
<h4 id="orgd70d80d"><span class="section-number-4">2.3.6.</span> Transpilation</h4>
<div class="outline-text-4" id="text-2-3-6">
<p>
Now that we have a backend in mind, we can transpile our circuits for the
desired backend:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Specify the target backend for transpilation</span>
<span style="color: #DFAF8F;">target_qpu</span> = backend_qpu.target

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Create a pass manager object to perform the transpilation</span>
<span style="color: #DFAF8F;">pm_qpu</span> = generate_preset_pass_manager(target=target_qpu, optimization_level=1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Want to know more about the pass manager? Start printing things about it.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'Class of pm_aer: {type(pm_aer)}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer: {pm_aer}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer attributes: {pm_aer.__dict__}')</span>

<span style="color: #DFAF8F;">BellCkts_qpu</span> = pm_qpu.run( BellCkts ) 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Code block complete at 2025-03-11 21:40:01.345139
</pre>


<p>
We can see the transpiled version of our circuits if we print them.
</p>

<p>
In Jupyter Lab, something like the following may be used to display the
circuits:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx, ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(BellCkts):
    display(BellCkts_qpu[idx].draw(idle_wires=<span style="color: #BFEBBF;">False</span>))
</pre>
</div>


<div id="org1068c5a" class="figure">
<p><img src="./img/BellCkt0_qpu.png" alt="BellCkt0_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 7: </span>The first Bell circuit is transpiled for the selected backend, <code>backend_qpu</code>.</p>
</div>


<div id="orge157407" class="figure">
<p><img src="./img/BellCkt1_qpu.png" alt="BellCkt1_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 8: </span>The first Bell circuit is transpiled for the selected backend, <code>backend_qpu</code>.</p>
</div>


<p>
We may wish to compare our transpiled circuit to our original circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx, ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(BellCkts):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'='</span>*70 + f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">idx = </span>{idx}<span style="color: #CC9393;">'</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Original circuit design:'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(ckt)

</pre>
</div>

<pre class="example" id="orgd3ddbe8">
======================================================================
idx = 0
Original circuit design:
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
======================================================================
idx = 1
Original circuit design:
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
</pre>

<p>
Now, we can clearly see that the transpiled circuit looks rather different from
the original design. The transpiled circuit may have many more qubits than the
original design; however, extra qubits are suppressed from our drawings by using
the keyword <code>idle_qubits=False</code> in the <code>draw()</code> method for a circuit.
</p>
</div>
</div>

<div id="outline-container-org83d6eee" class="outline-4">
<h4 id="org83d6eee"><span class="section-number-4">2.3.7.</span> Forming PUBs</h4>
<div class="outline-text-4" id="text-2-3-7">
<p>
Now that we have transpiled circuits for the QPU, we must form a list of PUBs:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">PUBs_qpu</span> = [ (ckt, <span style="color: #BFEBBF;">None</span>) <span style="color: #F0DFAF; font-weight: bold;">for</span> ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> BellCkts_qpu ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a list of PUBs for the QPU at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Your list of PUBs contains </span>{<span style="color: #DCDCCC; font-weight: bold;">len</span>(PUBs_qpu)}<span style="color: #CC9393;"> PUBs.'</span>)
</pre>
</div>

<pre class="example">
Created a list of PUBs for the QPU at 2025-03-11 21:40:44.414779
Your list of PUBs contains 2 PUBs.
</pre>


<p>
Next, we will run our jobs by submittin the PUBs.
</p>
</div>
</div>
</div>

<div id="outline-container-org803d63d" class="outline-3">
<h3 id="org803d63d"><span class="section-number-3">2.4.</span> Running the Circuits</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Here, we will use <code>qiskit_aer.primitives.SamplerV2()</code> as our simulation
platform. First, we instantiate a <code>SamplerV2</code> object. Note: we import
`qiskit<sub>aer.primitives.SamplerV2</sub>~ as <code>Sampler</code> to distinguish it from the
<code>qiskit_ibm_runtime.SamplerV2</code> which we will use later.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Instantiate a sampler</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2

<span style="color: #DFAF8F;">sampler_qpu</span> = SamplerV2( backend_qpu )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a SamplerV2 for use with a QPU at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Created a SamplerV2 for use with a QPU at 2025-03-11 21:40:55.329822
</pre>


<p>
Finally, we use the <code>run()</code> method of our sampler. We will specify a shot count
of 4096, since we may wish to compare with results from actual hardware using a
<code>qiskit_ibm_runtime.SamplerV2</code> object. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">We specify the same number of shots as in our simulated run</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">use None to launch a new calculation.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">use an actual job_id to retrieve an existing calculation.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">job_id = None</span>
<span style="color: #DFAF8F;">job_id</span> = <span style="color: #CC9393;">'cz890patp60g008grx9g'</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span> job_id <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
    <span style="color: #DFAF8F;">job_qpu</span> = sampler_qpu.run( PUBs_qpu, shots=4092 ) 
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Submitted the QPU job at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
    <span style="color: #DFAF8F;">job_id</span> = job_qpu.job_id()
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'   Job ID: </span>{job_id}<span style="color: #CC9393;">'</span>)

<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DFAF8F;">job_qpu</span> = service.job( job_id )
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Retrieved existing job (</span>{datetime.now()}<span style="color: #CC9393;">).'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'   Job ID: </span>{job_id}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Retrieved existing job (2025-03-11 21:41:03.382712).
   Job ID: cz890patp60g008grx9g
</pre>


<p>
We can check the status of our job:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'The status of our job is: </span>{job_qpu.status()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
The status of our job is: DONE
</pre>
</div>
</div>

<div id="outline-container-org7212ecb" class="outline-3">
<h3 id="org7212ecb"><span class="section-number-3">2.5.</span> Accessing the Results</h3>
<div class="outline-text-3" id="text-2-5">
<p>
We can extract results from our job using its <code>.result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results_qpu</span> = job_qpu.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results_qpu)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'circuit_metadata': {}}), SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([DoubleSliceSpan(&lt;start='2025-03-11 19:34:53', stop='2025-03-11 19:34:56', size=8184&gt;)])}, 'version': 2})
</pre>


<p>
We can plot the results, just as before:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(results_qpu[idx].data.meas.get_counts())
</pre>
</div>

<pre class="example">
{'00': 1961, '11': 2065, '01': 36, '10': 30}
{'10': 2058, '01': 1964, '00': 22, '11': 48}
</pre>


<p>
Indeed, we can print our results, but it is much nicer to plot them using a
histogram.
</p>

<p>
Unlike in the simulation, which was noise-free, we now have noise. Bell circuit
0 should not produce states \(\left| 01 \right \rangle\) nor
\(\left| 10 \right \rangle\), yet, they are listed in the measurement results,
indicating that they have a non-zero probability of occurring. Similarly,
circuit 1 should not produce \(\left| 00 \right \rangle\) nor
\(\left| 11 \right \rangle\).
</p>

<p>
For a better comparison between our noise-free simulation and QPU results, we
plot the counts on the same histogram. We can do this using the
<code>plot_histogram()</code> method if we provide a list the counts we want to appear on
the same plot:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">legend_data</span> = [<span style="color: #CC9393;">'Noise-free Sim.'</span>, <span style="color: #CC9393;">'QPU'</span>]

<span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Bell circuit </span>{idx}<span style="color: #CC9393;">'</span>)
    display(plot_histogram([results_sim[idx].data.meas.get_counts(),
                           results_qpu[idx].data.meas.get_counts()],
                           legend=legend_data)
</pre>
</div>


<div id="orgcd58af7" class="figure">
<p><img src="./img/bell_ckt_results00_compare.png" alt="bell_ckt_results00_compare.png" width="480px" />
</p>
<p><span class="figure-number">Figure 9: </span>QPU results are compared with noise-free simulation results for Bell circuit 0.</p>
</div>

<p>
Bell circuit 1:
</p>


<div id="org65653b4" class="figure">
<p><img src="./img/bell_ckt_results01_compare.png" alt="bell_ckt_results01_compare.png" width="480px" />
</p>
<p><span class="figure-number">Figure 10: </span>QPU results are compared with noise-free simulation results for Bell circuit 1.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga0f9350" class="outline-2">
<h2 id="orga0f9350"><span class="section-number-2">3.</span> Bell Circuits on Simulated Hardware</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org0af9b3d" class="outline-3">
<h3 id="org0af9b3d"><span class="section-number-3">3.1.</span> Overview</h3>
<div class="outline-text-3" id="text-3-1">
<p>
If you are unable to access IBM Quantum, you may wish to use a fake
backend. <code>ibm_qiskit_runtime.fake_provider</code> provides fake backends designed to
mimic the behaviors of IBM Quantum systems from system snapshots.
</p>
</div>
</div>

<div id="outline-container-org3b38d6e" class="outline-3">
<h3 id="org3b38d6e"><span class="section-number-3">3.2.</span> Instantiate a Fake Backend</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime.fake_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> FakeManilaV2

<span style="color: #DFAF8F;">backend_fake_qpu</span> = FakeManilaV2()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 21:43:05.396416
</pre>
</div>
</div>

<div id="outline-container-orge75b9f3" class="outline-3">
<h3 id="orge75b9f3"><span class="section-number-3">3.3.</span> Transpilation</h3>
<div class="outline-text-3" id="text-3-3">
<p>
We can now transpile our list of circuits. To <b>transpile</b> a circuit is to form
an equivalent circuit using a set of gates (instruction set architecture, or
ISA) that is supported on a specific quantum processing unit (QPU).
</p>

<p>
To transpile, we tools called <code>pass_managers</code>. <code>qiskit</code> has some preset pass
managers, which make it more convenient.
</p>

<p>
One other piece of information we must provide is the target backend. The target
backend could be an <code>AerSimulator()</code>, a local model of a QPU (<code>FakeBackend</code>), or
an actual QPU. Different resources may have different ISAs, so it is important
to specify your transpilation target.
</p>

<div class="org-src-container">
<pre class="src src-python">
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Specify the target backend for transpilation</span>
<span style="color: #DFAF8F;">target_fake_qpu</span> = backend_fake_qpu.target

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Create a pass manager object to perform the transpilation</span>
<span style="color: #DFAF8F;">pm_fake_qpu</span> = generate_preset_pass_manager(target=target_fake_qpu, optimization_level=1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Want to know more about the pass manager? Start printing things about it.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'Class of pm_aer: {type(pm_aer)}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer: {pm_aer}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer attributes: {pm_aer.__dict__}')</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 21:44:33.308363
</pre>



<p>
Next, we can transpile our circuits for the desired backend:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">BellCkts_fake_qpu</span> = pm_fake_qpu.run( BellCkts ) 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Code block complete at 2025-03-11 21:45:39.211152
</pre>


<p>
We may wish to compare our transpiled circuit to our original circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx, ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(BellCkts):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'='</span>*70 + f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">idx = </span>{idx}<span style="color: #CC9393;">'</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Original'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(ckt)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Transpiled'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(BellCkts_fake_qpu[idx])      

</pre>
</div>

<pre class="example" id="org1ed2f80">
======================================================================
idx = 0
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
global phase: π/4
               ┌─────────┐┌────┐┌─────────┐      ░ ┌─┐   
      q_0 -&gt; 0 ┤ Rz(π/2) ├┤ √X ├┤ Rz(π/2) ├──■───░─┤M├───
               └─────────┘└────┘└─────────┘┌─┴─┐ ░ └╥┘┌─┐
      q_1 -&gt; 1 ────────────────────────────┤ X ├─░──╫─┤M├
                                           └───┘ ░  ║ └╥┘
ancilla_0 -&gt; 2 ─────────────────────────────────────╫──╫─
                                                    ║  ║ 
ancilla_1 -&gt; 3 ─────────────────────────────────────╫──╫─
                                                    ║  ║ 
ancilla_2 -&gt; 4 ─────────────────────────────────────╫──╫─
                                                    ║  ║ 
       meas: 2/═════════════════════════════════════╩══╩═
                                                    0  1 
======================================================================
idx = 1
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
global phase: π/4
               ┌─────────┐┌────┐┌─────────┐      ░ ┌─┐   
      q_0 -&gt; 0 ┤ Rz(π/2) ├┤ √X ├┤ Rz(π/2) ├──■───░─┤M├───
               └──┬───┬──┘└────┘└─────────┘┌─┴─┐ ░ └╥┘┌─┐
      q_1 -&gt; 1 ───┤ X ├────────────────────┤ X ├─░──╫─┤M├
                  └───┘                    └───┘ ░  ║ └╥┘
ancilla_0 -&gt; 2 ─────────────────────────────────────╫──╫─
                                                    ║  ║ 
ancilla_1 -&gt; 3 ─────────────────────────────────────╫──╫─
                                                    ║  ║ 
ancilla_2 -&gt; 4 ─────────────────────────────────────╫──╫─
                                                    ║  ║ 
       meas: 2/═════════════════════════════════════╩══╩═
                                                    0  1
</pre>

<p>
In this case, both the original circuit and the transpiled circuit are the
same. When we try to use a <code>FakeBackend</code> or a real QPU, however, the transpiled
circuit may look quite different from the origial circuit you designed.
</p>
</div>
</div>


<div id="outline-container-org2370147" class="outline-3">
<h3 id="org2370147"><span class="section-number-3">3.4.</span> Forming PUBs</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Now that we have transpiled circuits for the fake QPU, we must form a list of
PUBs: 
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">PUBs_fake_qpu</span> = [ (ckt, <span style="color: #BFEBBF;">None</span>) <span style="color: #F0DFAF; font-weight: bold;">for</span> ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> BellCkts_fake_qpu ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a list of PUBs for the QPU at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Your list of PUBs contains </span>{<span style="color: #DCDCCC; font-weight: bold;">len</span>(PUBs_fake_qpu)}<span style="color: #CC9393;"> PUBs.'</span>)
</pre>
</div>

<pre class="example">
Created a list of PUBs for the QPU at 2025-03-11 21:51:12.709933
Your list of PUBs contains 2 PUBs.
</pre>


<p>
Next, we will run our jobs by submitting the PUBs.
</p>
</div>
</div>

<div id="outline-container-orge5959a0" class="outline-3">
<h3 id="orge5959a0"><span class="section-number-3">3.5.</span> Running the Circuits</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Here, we will use <code>qiskit_aer.primitives.SamplerV2()</code> as our simulation
platform. First, we instantiate a <code>SamplerV2</code> object. Note: we import
`qiskit<sub>aer.primitives.SamplerV2</sub>~ as <code>Sampler</code> to distinguish it from the
<code>qiskit_ibm_runtime.SamplerV2</code> which we will use later.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Instantiate a sampler</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2

<span style="color: #DFAF8F;">sampler_fake_qpu</span> = SamplerV2( backend_fake_qpu )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a SamplerV2 for use with a fake QPU at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Created a SamplerV2 for use with a fake QPU at 2025-03-11 21:55:16.767693
</pre>


<p>
Finally, we use the <code>run()</code> method of our sampler. We will specify a shot count
of 4096, since we may wish to compare with results from actual hardware using a
<code>qiskit_ibm_runtime.SamplerV2</code> object. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">We specify the same number of shots as in our simulated run</span>

<span style="color: #DFAF8F;">job_fake_qpu</span> = sampler_fake_qpu.run( PUBs_fake_qpu, shots=4092 )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Submitted the fake QPU job at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)

</pre>
</div>

<pre class="example">
Submitted the fake QPU job at 2025-03-11 21:57:10.160899
</pre>
</div>
</div>


<div id="outline-container-orgd92a9e4" class="outline-3">
<h3 id="orgd92a9e4"><span class="section-number-3">3.6.</span> Accessing the Results</h3>
<div class="outline-text-3" id="text-3-6">
<p>
We can extract results from our job using its <code>.result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results_fake_qpu</span> = job_fake_qpu.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results_fake_qpu)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'shots': 4092, 'circuit_metadata': {}}), SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'shots': 4092, 'circuit_metadata': {}})], metadata={'version': 2})
</pre>


<p>
We can plot the results, just as before:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(results_fake_qpu[idx].data.meas.get_counts())
</pre>
</div>

<pre class="example">
{'00': 2048, '11': 1811, '01': 90, '10': 143}
{'00': 193, '10': 1846, '01': 1980, '11': 73}
</pre>


<p>
We also can print our results against those of the noise-free simulation.
</p>

<p>
Unlike in the noise-free simulation, the fake backend provides a local, noisy
simulation. In fact, the fake backend includes a noise-model designed to mimic
an actual backend. In this case, <code>FakeManilaV2</code> is intended to be a mock-up of a
real QPU, <code>Manila</code>, which is now out of service.
</p>

<p>
We compare the counts from the noisy simulation to the counts from the noisy
simulation. To do this, we plot the results on the same plot:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">legend_data</span> = [<span style="color: #CC9393;">'Noise-free Sim.'</span>, <span style="color: #CC9393;">'Fake QPU'</span>]

<span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Bell circuit </span>{idx}<span style="color: #CC9393;">'</span>)
    display(plot_histogram([results_sim[idx].data.meas.get_counts(),
                            results_qpu[idx].data.meas.get_counts()],
                           legend=legend_data))
</pre>
</div>


<div id="org714ab04" class="figure">
<p><img src="./img/bell_ckt_results00_compare_nf_fake_qpu.png" alt="bell_ckt_results00_compare_nf_fake_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 11: </span>Fake QPU results are compared with noise-free simulation results for Bell circuit 0.</p>
</div>

<p>
For Bell circuit 1:
</p>


<div id="org2c6cb90" class="figure">
<p><img src="./img/bell_ckt_results01_compare_nf_fake_qpu.png" alt="bell_ckt_results01_compare_nf_fake_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 12: </span>Fake QPU results are compared with noise-free simulation results for Bell circuit 1.</p>
</div>


<p>
Finally, we can compare noise-free and noisy simulations, both against the
results from the real QPU:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">legend_data</span> = [<span style="color: #CC9393;">'Noise-free Sim.'</span>, <span style="color: #CC9393;">'Fake QPU'</span>, <span style="color: #CC9393;">'QPU'</span>]

<span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Bell circuit </span>{idx}<span style="color: #CC9393;">'</span>)
    display(plot_histogram([results_sim[idx].data.meas.get_counts(),
                            results_fake_qpu[idx].data.meas.get_counts(),
                            results_qpu[idx].data.meas.get_counts()],
                           legend=legend_data))
</pre>
</div>

<p>
Bell circuit 0:
</p>


<div id="org48a5390" class="figure">
<p><img src="./img/bell_ckt_results00_compare_nf_fake_qpu_qpu.png" alt="bell_ckt_results00_compare_nf_fake_qpu_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 13: </span>A noise-free simulation is compared to a noisy simulation and an anctual QPU for Bell circuit 0.</p>
</div>

<p>
Bell circuit 1:
</p>


<div id="org4700d57" class="figure">
<p><img src="./img/bell_ckt_results01_compare_nf_fake_qpu_qpu.png" alt="bell_ckt_results01_compare_nf_fake_qpu_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 14: </span>A noise-free simulation is compared to a noisy simulation and an anctual QPU for Bell circuit 1.</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Dr. E.P. Blair</p>
<p class="date">Created: 2025-03-11 Tue 22:46</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
