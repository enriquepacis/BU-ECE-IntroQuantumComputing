<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-24 Fri 23:22 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Qiskit + IBM: Simulation and Calculation</title>
<meta name="author" content="Dr. E.P. Blair" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Qiskit + IBM: Simulation and Calculation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#qinfoOverview">1. Overview</a></li>
<li><a href="#qinfoModule">2. The <code>quantum_info</code> Module</a>
<ul>
<li><a href="#orgba4f589">2.1. Overview</a></li>
<li><a href="#orgdbd23f5">2.2. Make a Quantum Circuit</a></li>
<li><a href="#org208d583">2.3. Get an Output <code>Statevector()</code> Object</a></li>
<li><a href="#org3a16c71">2.4. Measurement Probabilities</a></li>
<li><a href="#org2bd5c3d">2.5. Simulated Experiments</a>
<ul>
<li><a href="#org0c0fac2">2.5.1. Measurement Outcomes for Each Shot</a></li>
<li><a href="#org28edf11">2.5.2. Cumulative Results over an Ensemble</a></li>
<li><a href="#org986adc1">2.5.3. Expectation Values</a></li>
<li><a href="#org1e77ae3">2.5.4. Bloch Vectors</a></li>
<li><a href="#orgb1a7398">2.5.5. Density Matrices</a></li>
</ul>
</li>
<li><a href="#orgdcf9398">2.6. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:BasicSimulator">3. The <code>BasicSimulator</code> Class</a>
<ul>
<li><a href="#org3284596">3.1. Build a Circuit</a></li>
<li><a href="#org7e458c8">3.2. Simulating the Circuit</a></li>
<li><a href="#org0fdc5cc">3.3. Getting the Results</a>
<ul>
<li><a href="#orgabbb42a">3.3.1. Simulation Counts</a></li>
<li><a href="#org64c0faf">3.3.2. Visualizing the Results</a></li>
<li><a href="#org5da6f5a">3.3.3. Inspecting Results from Individual Measurements</a></li>
</ul>
</li>
<li><a href="#org7d67cd1">3.4. Handling Complex Circuits</a>
<ul>
<li><a href="#org14e731e">3.4.1. Transpilation</a></li>
</ul>
</li>
<li><a href="#org0bed986">3.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:QiskitAerSimulator">4. The Qiskit <code>AerSimulator</code></a>
<ul>
<li><a href="#orge6bd683">4.1. Overview</a></li>
<li><a href="#org3a0ac9a">4.2. Imports</a></li>
<li><a href="#org817e7e7">4.3. Build a Circuit</a></li>
<li><a href="#org41aa857">4.4. Run the <code>AerSimulator()</code></a></li>
<li><a href="#org1d868d5">4.5. Example 2: Circuit with Statevector in Middle of Circuit</a>
<ul>
<li><a href="#org9b41151">4.5.1. Transpile and Run the Circuit</a></li>
</ul>
</li>
<li><a href="#orgbcf5b96">4.6. Efficient Simulation</a>
<ul>
<li><a href="#org686cde5">4.6.1. Build a Circuit</a></li>
<li><a href="#orgad16ed7">4.6.2. Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></a></li>
</ul>
</li>
<li><a href="#org538fec2">4.7. Simulation Methods</a>
<ul>
<li><a href="#org61d6858">4.7.1. Build a Large Circuit</a></li>
<li><a href="#org1d1ba1d">4.7.2. Run and Time the Simulation</a></li>
</ul>
</li>
<li><a href="#orgdbe5d01">4.8. Noisy Simulation</a>
<ul>
<li><a href="#org72bd844">4.8.1. Build a Circuit</a></li>
<li><a href="#org2b2e1ea">4.8.2. Ideal Result</a></li>
<li><a href="#orgd522cda">4.8.3. Noisy Result</a></li>
<li><a href="#org711e418">4.8.4. Compare Ideal Result and Noisy Result</a></li>
</ul>
</li>
<li><a href="#org2da6bbd">4.9. Summary</a></li>
</ul>
</li>
<li><a href="#org8bdaef7">5. Qiskit Primitives</a>
<ul>
<li><a href="#org92d8699">5.1. Overview</a></li>
<li><a href="#org9123edc">5.2. Primitives</a>
<ul>
<li><a href="#org65c2064">5.2.1. Imports</a></li>
<li><a href="#org57830a6">5.2.2. Build a Circuit</a></li>
<li><a href="#org3dc35eb">5.2.3. Run Simulations</a></li>
<li><a href="#orgfe0eff4">5.2.4. Extracting Results</a></li>
</ul>
</li>
<li><a href="#org9af13e7">5.3. Example: A Parametrized Circuit</a>
<ul>
<li><a href="#org450d046">5.3.1. <code>BasicSimulator</code> Usage</a></li>
<li><a href="#org3582a58">5.3.2. <code>StatevectorSampler</code> Usage</a></li>
<li><a href="#orgd742efb">5.3.3. <code>StatevectorSampler</code> Usage with Multiple PUBs</a></li>
</ul>
</li>
<li><a href="#org67ab06c">5.4. The Estimator Primitive</a>
<ul>
<li><a href="#org11fd80d">5.4.1. Observables</a></li>
<li><a href="#orga071f6f">5.4.2. Run the Estimator</a></li>
<li><a href="#org0489841">5.4.3. Extract Expectation Values</a></li>
</ul>
</li>
<li><a href="#org52ef8b8">5.5. Qiskit Estimator Example</a>
<ul>
<li><a href="#orge214bbe">5.5.1. Build an Operator</a></li>
<li><a href="#org4824695">5.5.2. Instantiate a <code>StatevectorEstimator</code></a></li>
<li><a href="#org6c71d61">5.5.3. Transpile the Circuit</a></li>
<li><a href="#org04fc17e">5.5.4. Run the Estimator</a></li>
<li><a href="#org4abc252">5.5.5. Extract Results</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga6a2476">6. Qiskit IBM Runtime Primitives</a>
<ul>
<li><a href="#org0c1b90b">6.1. Imports</a></li>
<li><a href="#org3c9f6c1">6.2. Load a Personal IBM Token</a>
<ul>
<li><a href="#org2d8da26">6.2.1. Getting Your IBM Quantum Token</a></li>
<li><a href="#org8d6c6af">6.2.2. The getpass Package</a></li>
<li><a href="#org60a85fd">6.2.3. Acessing IBM Quantum Harware Using Your Token</a></li>
<li><a href="#org15633d2">6.2.4. My Approach (not recommended)</a></li>
</ul>
</li>
<li><a href="#orgde9e4dc">6.3. Establish a Connection</a></li>
<li><a href="#orga558281">6.4. Define Sampler Instances</a></li>
<li><a href="#orgce144d3">6.5. Create Some Circuits</a></li>
<li><a href="#org662cb98">6.6. Transpile the Circuits</a>
<ul>
<li><a href="#org354d8d6">6.6.1. Circuit 1 (Aer)</a></li>
<li><a href="#orgdccb6b5">6.6.2. Circuit 2 (Aer)</a></li>
<li><a href="#org1c7d4ca">6.6.3. Circuit 1 (QPU)</a></li>
<li><a href="#orgacc190e">6.6.4. Circuit 2 (QPU)</a></li>
</ul>
</li>
<li><a href="#orgaa2a1e3">6.7. Simulate the Circuits</a>
<ul>
<li><a href="#org4a2c2f9">6.7.1. Simulate on the Aer Sampler</a></li>
<li><a href="#org37fefad">6.7.2. Run on Quantum Hardware</a></li>
<li><a href="#orgd5bf3a1">6.7.3. Get Results from the <code>AerSampler</code></a></li>
<li><a href="#org3ba9395">6.7.4. Comparing Simulation and QPU Results</a></li>
</ul>
</li>
<li><a href="#org1623104">6.8. Simulation vs QPU: Estimator</a>
<ul>
<li><a href="#org37b4bf9">6.8.1. Defining Estimator Objects</a></li>
<li><a href="#org273a7c9">6.8.2. Defining Observable Operators</a></li>
<li><a href="#orga31be8c">6.8.3. Layout Mapping</a></li>
<li><a href="#orgc04f23f">6.8.4. Simulation</a></li>
<li><a href="#org1f7005f">6.8.5. QPU Submission</a></li>
<li><a href="#orgf51b942">6.8.6. Retrieve Estimator Results</a></li>
</ul>
</li>
<li><a href="#orgb4f2eed">6.9. Three Runtime Execution Methods</a>
<ul>
<li><a href="#org641c773">6.9.1. Sessions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-qinfoOverview" class="outline-2">
<h2 id="qinfoOverview"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-qinfoOverview">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>This page focuses on quantum computing simulations or job submissions on IBM
hardware
<ul class="org-ul">
<li>There are several ways to simulate quantum computations
<ul class="org-ul">
<li>Statevector simulations</li>
<li>Using SamplerV2 or EstimatorV2</li>
</ul></li>
</ul></li>
</ul>

<p>
The general work-flow is to:
</p>
<ol class="org-ol">
<li>Create a quantum circuit</li>
<li>Decide whether to simulate it or run it on quantum hardware
<ol class="org-ol">
<li>Typically, we simulate it first</li>
<li>We want our simulation syntax to match as closely as possible to the
syntax of job submission.</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-qinfoModule" class="outline-2">
<h2 id="qinfoModule"><span class="section-number-2">2.</span> The <code>quantum_info</code> Module</h2>
<div class="outline-text-2" id="text-qinfoModule">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-orgba4f589" class="outline-3">
<h3 id="orgba4f589"><span class="section-number-3">2.1.</span> Overview</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is built into <code>qiskit</code> and provides some basic
simulations
<ul class="org-ul">
<li>This is useful when we want to understand the quantum properties of the
output of a circuit</li>
<li>It provides:
<ul class="org-ul">
<li><code>Statevector</code> simulations</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdbd23f5" class="outline-3">
<h3 id="orgdbd23f5"><span class="section-number-3">2.2.</span> Make a Quantum Circuit</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In a Jupyter notebook we could make a cell like this:
</p>
<div class="org-src-container">
<pre class="src src-python" id="org3655e8f"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">import</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">as</span> qi

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.x(0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a NOT gate to qubit 0</span>
qc.h([0,1]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a H to both qubits</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter notebook, you can uncomment "qc.draw()"</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">to see your circuit</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">qc.draw()</span>
</pre>
</div>

<p>
In Jupyter Lab, your result may be displayed automatically and look like Figure
<a href="#org4e255ee">1</a>.
</p>

<div id="org4e255ee" class="figure">
<p><img src="./img/xh2.png" alt="xh2.png" width="300px" />
</p>
<p><span class="figure-number">Figure 1: </span>A simple <code>qiskit</code> quantum circuit.</p>
</div>
</div>
</div>
<div id="outline-container-org208d583" class="outline-3">
<h3 id="org208d583"><span class="section-number-3">2.3.</span> Get an Output <code>Statevector()</code> Object</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We can then obtain the circuit output in <code>Statevector</code> form:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#968;</span> = qi.Statevector( qc )

<span style="color: #DCDCCC; font-weight: bold;">print</span>( &#968; )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter Lab notebook, you can see the result using this:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw()</span>
</pre>
</div>

<pre class="example">
Statevector([ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],
            dims=(2, 2))
</pre>


<p>
In a Jupyter notebook, you can comment <code>print( ψ )</code> and uncomment <code>ψ.draw()</code>
to  see a result that's nicer than the one shown here. It may look like this:
</p>

\begin{equation}
\label{orgc0f579f}
\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle-
\frac{1}{2} |11\rangle
\end{equation}
</div>
</div>

<div id="outline-container-org3a16c71" class="outline-3">
<h3 id="org3a16c71"><span class="section-number-3">2.4.</span> Measurement Probabilities</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Once we have a <code>Statevector</code> object, we can use it to see the probabilities of
measurement, which are the modulii squared of the coefficients:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>( psi.probabilities() )
</pre>
</div>

<pre class="example">
[0.25 0.25 0.25 0.25]
</pre>


<p>
In this case, there are four outcomes, each with a 1/4 probability of
occurring.
</p>
</div>
</div>

<div id="outline-container-org2bd5c3d" class="outline-3">
<h3 id="org2bd5c3d"><span class="section-number-3">2.5.</span> Simulated Experiments</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Generally, a quantum computing experiment requires establishing a circuit and
performing measurements many times. Each repetition is a <b>shot</b> or a <b>trial</b>,
and a collection of shots is an <b>ensemble</b> of measurements.
</p>
</div>

<div id="outline-container-org0c0fac2" class="outline-4">
<h4 id="org0c0fac2"><span class="section-number-4">2.5.1.</span> Measurement Outcomes for Each Shot</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
We can use <code>ψ</code> to simulate circuit measurements using the <code>sample_memory()</code>
method. We specify a number of shots (trials), and we get a histogram of
samples, that is, the number of times each outcome was measured.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">samples</span> = &#968;.sample_memory( shots = 10 )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This lists the outcomes measured for each of the 10 shots</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)
</pre>
</div>

<pre class="example">
['11' '01' '10' '10' '01' '11' '01' '11' '01' '11']
</pre>
</div>
</div>

<div id="outline-container-org28edf11" class="outline-4">
<h4 id="org28edf11"><span class="section-number-4">2.5.2.</span> Cumulative Results over an Ensemble</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>If we don't care about each shot, but rather, we care more about aggregate
data, we can use <code>sample_counts()</code>
<ul class="org-ul">
<li>For a given number of shots, it simulates the set of measurements, returning
a frequency (number of occurrences) for each outcome measured.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = &#968;.sample_counts( shots = 1024 )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)
</pre>
</div>

<pre class="example">
{np.str_('00'): np.int64(266), np.str_('01'): np.int64(256), np.str_('10'): np.int64(244), np.str_('11'): np.int64(258)}
</pre>


<p>
The counts can be visualized in a histogram. In a Jupyter notebook, use the
following, but uncomment the <code>plot_histogram()</code> command:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment in Jupyter to see histogram</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_histogram( counts )</span>
</pre>
</div>


<div id="orgec30cd1" class="figure">
<p><img src="./img/basic_hist.png" alt="basic_hist.png" width="480px" />
</p>
<p><span class="figure-number">Figure 2: </span>This is a histogram of simulated measurents based on a <code>Statevector</code> output from a quantum circuit.</p>
</div>

<p>
State vector simulations get us a state vector, and we are using that state
vector object to simulate measurements.
</p>
</div>
</div>

<div id="outline-container-org986adc1" class="outline-4">
<h4 id="org986adc1"><span class="section-number-4">2.5.3.</span> Expectation Values</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
State vector simulations also allow us to get expectation values, as defined in
Equation \eqref{orgd65d446}
</p>
\begin{equation}
\label{orgd65d446}
\left\langle \mathbf{O} \right\rangle = \left\langle \psi \left| \mathbf{O} \right| \psi  \right\rangle 
\end{equation}

<p>
First, we form an operator:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O</span> = qi.SparsePauliOp([<span style="color: #CC9393;">'ZZ'</span>, <span style="color: #CC9393;">'XX'</span>, <span style="color: #CC9393;">'II'</span>], [0.2, -0.3, 0.4])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment this in Jupyter</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">display(O.to_operator())</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment/omit this in Jupyter</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(O.to_operator())

</pre>
</div>

<pre class="example">
Operator([[ 0.6+0.j,  0. +0.j,  0. +0.j, -0.3+0.j],
          [ 0. +0.j,  0.2+0.j, -0.3+0.j,  0. +0.j],
          [ 0. +0.j, -0.3+0.j,  0.2+0.j,  0. +0.j],
          [-0.3+0.j,  0. +0.j,  0. +0.j,  0.6+0.j]],
         input_dims=(2, 2), output_dims=(2, 2))
</pre>


<p>
Next, we supply \(\mathbf{O}\) to the <code>ψ</code> (a <code>Statevector</code> object) in its
<code>expectation_value()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O_exp</span> = &#968;.expectation_value( O )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(O_exp)
</pre>
</div>

<pre class="example">
(0.6999999999999997+0j)
</pre>
</div>
</div>

<div id="outline-container-org1e77ae3" class="outline-4">
<h4 id="org1e77ae3"><span class="section-number-4">2.5.4.</span> Bloch Vectors</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
We can ask Python to draw the Bloch vector for ψ:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Use this in Jupyter:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw('bloch')</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment this out or omit the following in Jupyter</span>
p
<span style="color: #DFAF8F;">fname</span> = os.join(<span style="color: #CC9393;">'html'</span>, <span style="color: #CC9393;">'img'</span>, <span style="color: #CC9393;">'basicBlochVect.png'</span>)
&#968;.draw(<span style="color: #CC9393;">'bloch'</span>, filename=fname)
<span style="color: #F0DFAF; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #F0DFAF; font-weight: bold;">as</span> plt
plt.savefig( fname )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'[[./</span>{fname[5:]}<span style="color: #CC9393;">]]'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">ls *.png
</pre>
</div>


<div id="org2a4448d" class="figure">
<p><img src="./img/basicBlochVect.png" alt="basicBlochVect.png" width="480px" />
</p>
<p><span class="figure-number">Figure 3: </span>Bloch vectors for the two qubits in ψ.</p>
</div>
</div>
</div>


<div id="outline-container-orgb1a7398" class="outline-4">
<h4 id="orgb1a7398"><span class="section-number-4">2.5.5.</span> Density Matrices</h4>
<div class="outline-text-4" id="text-2-5-5">
<p>
Similar to a <code>Statevector</code>, we can also get a <code>DensityMarix</code> from a
circuit. Recall that a density matrix \(\rho\) may be obtained from a state
vector:
</p>
\begin{equation}
\rho = \ket{\psi} \bra{\psi}
\end{equation}
</div>

<ol class="org-ol">
<li><a id="orgcd4d913"></a>Matrix Output<br />
<div class="outline-text-5" id="text-2-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;</span> = qi.DensityMatrix( qc )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, you may use</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">display( &#961; )</span>
</pre>
</div>

<pre class="example">
DensityMatrix([[ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j],
               [ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j]],
              dims=(2, 2))
</pre>



<p>
In Jupyter, you may see output like this from the <code>display()</code> command:
</p>
\begin{equation}
\begin{bmatrix}
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\end{bmatrix}
\end{equation}


<p>
In Jupyter, we can plot the elements of the density matrix:
</p>
</div>
</li>
<li><a id="org09c7261"></a>The City Plot<br />
<div class="outline-text-5" id="text-2-5-5-2">

<div id="orgb62cfd7" class="figure">
<p><img src="./img/dmCityScape.png" alt="dmCityScape.png" width="600px" />
</p>
</div>
</div>
</li>

<li><a id="org3a1447a"></a>Partial Trace<br />
<div class="outline-text-5" id="text-2-5-5-3">
<p>
Given a multi-qubit density matrix, we can get a reduced density matrix for any
subset of qubits.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;1</span> = qi.partial_trace( &#961;, [0] )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;1)
</pre>
</div>

<pre class="example">
DensityMatrix([[0.5+0.j, 0.5+0.j],
               [0.5+0.j, 0.5+0.j]],
              dims=(2,))
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgdcf9398" class="outline-3">
<h3 id="orgdcf9398"><span class="section-number-3">2.6.</span> Conclusion</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is useful for:
<ul class="org-ul">
<li>very basic simulations</li>
<li>exploring the quantum output of a circuit</li>
</ul></li>
<li>The <code>quantum_info</code> module does not handle circuit simulations that:
<ul class="org-ul">
<li>are too large</li>
<li>involve any measurement gates</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec:BasicSimulator" class="outline-2">
<h2 id="sec:BasicSimulator"><span class="section-number-2">3.</span> The <code>BasicSimulator</code> Class</h2>
<div class="outline-text-2" id="text-sec:BasicSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>We need the <code>BasicSimulator</code> class to perform simulations for circuits that
include measurement gates</li>
</ul>
</div>
<div id="outline-container-org3284596" class="outline-3">
<h3 id="org3284596"><span class="section-number-3">3.1.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Following Diego Serrano's tutorial, I build a circuit which includes
measurement gates
<ul class="org-ul">
<li><p>
Start by importing required code
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #DFAF8F;">simulator_basic</span> = BasicSimulator()
</pre>
</div>

<ul class="org-ul">
<li>The main things we've accomplished in this code are:
<ul class="org-ul">
<li>We have imported the <code>BasicSimulator</code> class</li>
<li>We have created <code>simulator_basic</code> as a <code>BasicSimulator</code> object.</li>
</ul></li>
</ul></li>
<li><p>
Build the circuit with two quantum bits and two classical bits
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 1</span>
qc.x(0).c_if(1,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1 </span>
qc.measure(0, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 0, record its result to classical bit 0</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>

<pre class="example">
/var/folders/88/d26ncvp97zg50164_cmmlyf511m8tn/T/babel-bmQJhU/python-AGP0D6:5: DeprecationWarning: The method ``qiskit.circuit.instructionset.InstructionSet.c_if()`` is deprecated as of qiskit 1.3.0. It will be removed in 2.0.0.
  qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1
</pre></li>
</ul></li>
</ul>



<div id="orga46d5d3" class="figure">
<p><img src="./img/QCwithMeas.png" alt="QCwithMeas.png" width="525px" />
</p>
<p><span class="figure-number">Figure 4: </span>This circuit has two qubits and two classical bits. The classical bits are required for measuremnt.</p>
</div>

<p>
In a Jupyter notebook, the output of <code>qc.draw()</code> will resemble Figure
<a href="#orga46d5d3">4</a>.
</p>
</div>
</div>
<div id="outline-container-org7e458c8" class="outline-3">
<h3 id="org7e458c8"><span class="section-number-3">3.2.</span> Simulating the Circuit</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
To run the circuit, we use the BasicSimulator.run() method, and we supply the
desired circuit, and we can specify the number of shots for our simulation:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">The .run() method performs the simulation, and and the run is</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">saved as job</span>
<span style="color: #DFAF8F;">job</span> = simulator_basic.run( qc, shots=1024 )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(job))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.providers.basic_provider.basic_provider_job.BasicProviderJob'&gt;
</pre>

<ul class="org-ul">
<li>This <code>run()</code> method returns a <code>BasicProviderJob</code> object
<ul class="org-ul">
<li>This has a <code>result()</code> method that returns a <code>Result()</code> object contains our
simulation results</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org0fdc5cc" class="outline-3">
<h3 id="org0fdc5cc"><span class="section-number-3">3.3.</span> Getting the Results</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li><p>
We save the results as <code>results</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results</span> = job.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(results))

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.result.result.Result'&gt;
Result(backend_name='basic_simulator', backend_version='0.1', qobj_id='5fa46fbe-251b-4733-b29c-6cd05bb52024', job_id='5abb07aa-3a06-4ff7-94e5-a27a9e678d07', success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 519, '0x3': 505}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['c', 0], ['c', 1]], memory_slots=2, creg_sizes=[['c', 2]], name='circuit-160', global_phase=0.0, metadata={}), status=DONE, name='circuit-160', seed_simulator=np.int32(1719395928), time_taken=0.07600593566894531)], date=None, status=COMPLETED, header=QobjHeader(backend_name='basic_simulator', backend_version='0.1'), time_taken=0.0760350227355957)
</pre></li>

<li>The results object has lots of information about our quantum experiment
simulation</li>
</ul>
</div>

<div id="outline-container-orgabbb42a" class="outline-4">
<h4 id="orgabbb42a"><span class="section-number-4">3.3.1.</span> Simulation Counts</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li><p>
A <code>get_counts()</code> method helps us retrieve the outcomes and their frequencies.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = results.get_counts()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)
</pre>
</div>

<pre class="example">
{'00': 519, '11': 505}
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org64c0faf" class="outline-4">
<h4 id="org64c0faf"><span class="section-number-4">3.3.2.</span> Visualizing the Results</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>We can plot the measurement results in two ways:
<ul class="org-ul">
<li>as a histogram (counts) using <code>plot_histogram()</code>, or</li>
<li>as a probability distribution using <code>plot_distribution()</code>.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

display( plot_distribution( counts ) )

display( plot_histogram( counts ) )
</pre>
</div>


<div id="orgff3ec03" class="figure">
<p><img src="./img/basicSimHist.png" alt="basicSimHist.png" width="600px" />
</p>
<p><span class="figure-number">Figure 5: </span>A histogram from the results of a <code>BasicSimulator.run()</code> simulation.</p>
</div>


<div id="org2b32457" class="figure">
<p><img src="./img/basicSimPD.png" alt="basicSimPD.png" width="600px" />
</p>
<p><span class="figure-number">Figure 6: </span>A quasi-probability distribution from the results of a <code>BasicSimulator.run()</code> simulation. Quasiprobabilities are not actual probabilities, but rather estimates of probabilites obtained by dividing the number of occurrences of an event by the total number of experiments (shots).</p>
</div>
</div>
</div>

<div id="outline-container-org5da6f5a" class="outline-4">
<h4 id="org5da6f5a"><span class="section-number-4">3.3.3.</span> Inspecting Results from Individual Measurements</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>We can see the results of individual measurements if we use the <code>get_memory()</code> method for a <code>Results</code> object
<ul class="org-ul">
<li>This requires using the <code>memory</code> keyword with a value of <code>True</code> in the
<code>run()</code> method for our basic simulator</li>
</ul></li>
<li>Here, we do this with a fewer number of shots so that we can avoid
overwhelming ourselves with numerous results</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">small_job</span> = simulator_basic.run( qc, shots=8, memory=<span style="color: #BFEBBF;">True</span>)
<span style="color: #DFAF8F;">small_result</span> = small_job.result()
<span style="color: #DFAF8F;">samples</span> = small_result.get_memory()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)
</pre>
</div>

<pre class="example">
['00', '00', '00', '00', '11', '11', '11', '00']
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d67cd1" class="outline-3">
<h3 id="org7d67cd1"><span class="section-number-3">3.4.</span> Handling Complex Circuits</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>The basic simulator cannot handle more complex circuits readily, such as the QFT circuit</li>
<li>To handle complex circuits, we must first transpile our circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit.library <span style="color: #F0DFAF; font-weight: bold;">import</span> QFT

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(3, 3) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">3 qubits, 3 classical bits</span>
qc.append( QFT(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )
qc.measure( <span style="color: #DCDCCC; font-weight: bold;">range</span>(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )

qc.draw()
</pre>
</div>


<div id="org6ace966" class="figure">
<p><img src="./img/BasicSimQFT.png" alt="BasicSimQFT.png" width="480px" />
</p>
<p><span class="figure-number">Figure 7: </span>This is a more complex circuit including a QFT. <code>BasicSimulator</code> cannot handle this unless we first transpile it.</p>
</div>
</div>

<div id="outline-container-org14e731e" class="outline-4">
<h4 id="org14e731e"><span class="section-number-4">3.4.1.</span> Transpilation</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>Circuits may be composed of gates of various types</li>
<li>Some gates may not exist natively on a particular quantum processing unit
(QPU), but may be implemented using the available gates on the QPU
<ul class="org-ul">
<li>The set of available gates is often called the instruction set architecture
(ISA)</li>
</ul></li>
<li>To transpile a circuit is to represent it in the ISA of a particular machine</li>
<li>In this case, we transpile the QFT into gates available within the
<code>BasicSimulator</code> class.</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>This code transpiles the circuit of Figure <a href="#org6ace966">7</a></label><pre class="src src-python" id="orgcd9469e"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile

<span style="color: #DFAF8F;">qc_trans</span> = transpile( qc, backend=simulator_basic)

qc_trans.draw()

</pre>
</div>

<p>
Jupyter output for Listing will resemble Figure <a href="#orgd1ae7ba">8</a>
</p>

<div id="orgd1ae7ba" class="figure">
<p><img src="./img/BasicSimQFTtrans.png" alt="BasicSimQFTtrans.png" width="640px" />
</p>
<p><span class="figure-number">Figure 8: </span>This is a transpiled version of the circuit from Figure <a href="#org6ace966">7</a></p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0bed986" class="outline-3">
<h3 id="org0bed986"><span class="section-number-3">3.5.</span> Conclusion</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>The <code>BasicSimulator()</code> class is useful when we simulate a job where we need to
find counts or samples of a circuit with mid-circuit measurements</li>
<li>The <code>BasicSimulator()</code> class should not be used for:
<ul class="org-ul">
<li>large circuits with many qubits or many gates</li>
<li>circuits where a coherent state is desired (state vector or density matrix)</li>
<li>noisy simulations</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec:QiskitAerSimulator" class="outline-2">
<h2 id="sec:QiskitAerSimulator"><span class="section-number-2">4.</span> The Qiskit <code>AerSimulator</code></h2>
<div class="outline-text-2" id="text-sec:QiskitAerSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-orge6bd683" class="outline-3">
<h3 id="orge6bd683"><span class="section-number-3">4.1.</span> Overview</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>The Qiskit Aer AerSimulator class can be used to simulate complex circuits with mid-circuit measurements</li>
<li>We can obtain unitary results from these simulations.</li>
</ul>
</div>
</div>
<div id="outline-container-org3a0ac9a" class="outline-3">
<h3 id="org3a0ac9a"><span class="section-number-3">4.2.</span> Imports</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>We begin by importing the required packages
<ul class="org-ul">
<li>This introduces the <code>qiskit_aer</code> package and the <code>AerSimulator</code> class</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit, transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> Statevector
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator

<span style="color: #DFAF8F;">simulator_basic</span> = BasicSimulator()
<span style="color: #DFAF8F;">simulator_aer</span> = AerSimulator()
</pre>
</div>
</div>
</div>


<div id="outline-container-org817e7e7" class="outline-3">
<h3 id="org817e7e7"><span class="section-number-3">4.3.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><p>
We define a circuit in Listing <a href="#orgefd83d4">2</a>
</p>
<div class="org-src-container">
<pre class="src src-python" id="orgefd83d4"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 0</span>
qc.h(0).c_if(0,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1</span>
qc.save_statevector()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="orga913208" class="figure">
<p><img src="./img/CktAerSim.png" alt="CktAerSim.png" width="480px" />
</p>
<p><span class="figure-number">Figure 9: </span>This is a two-qubit circuit with a measurement in the middle of the circuit.</p>
</div>

<ul class="org-ul">
<li>Here, the <code>save_statevector()</code> method defines a point in the circuit at
which we wish to knkow the state vector</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org41aa857" class="outline-3">
<h3 id="org41aa857"><span class="section-number-3">4.4.</span> Run the <code>AerSimulator()</code></h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><p>
We first transpile the circuit so it is suitable for our simulator, and then we run it:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968; <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">show the state vector in Jupyter Lab</span>
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle
\end{equation}</li>
</ul>
</div>
</div>
<div id="outline-container-org1d868d5" class="outline-3">
<h3 id="org1d868d5"><span class="section-number-3">4.5.</span> Example 2: Circuit with Statevector in Middle of Circuit</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li><p>
Now, we provide an example where the state vector is saved from a point prior to the end of the circuit.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(4)
qc.h(3)
qc.cx(3,2)
qc.save_statevector()
qc.cx(3,1)
qc.cx(3,0)
qc.measure_all()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="orgc0d7616" class="figure">
<p><img src="./img/AerSimMultiStatevectCkt.png" alt="AerSimMultiStatevectCkt.png" width="640px" />
</p>
<p><span class="figure-number">Figure 10: </span>This circuit saves a <code>Statevector</code> in the middle of the calculation and just prior to measurement.</p>
</div></li>
</ul>
</div>

<div id="outline-container-org9b41151" class="outline-4">
<h4 id="org9b41151"><span class="section-number-4">4.5.1.</span> Transpile and Run the Circuit</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li><p>
Next, we transpile and run the circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968;
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle
\end{equation}</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgbcf5b96" class="outline-3">
<h3 id="orgbcf5b96"><span class="section-number-3">4.6.</span> Efficient Simulation</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>Portions of the <code>AerSimulator</code> code are compiled to <code>C</code>
<ul class="org-ul">
<li>This allows faster and more efficient simulations, which enables simulations
of larger and more complex circuits.</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org686cde5" class="outline-4">
<h4 id="org686cde5"><span class="section-number-4">4.6.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-6-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 24
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-orgad16ed7" class="outline-4">
<h4 id="orgad16ed7"><span class="section-number-4">4.6.2.</span> Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></h4>
<div class="outline-text-4" id="text-4-6-2">
</div>
<ol class="org-ol">
<li><a id="org1a388fe"></a>BasicSimulator<br />
<div class="outline-text-5" id="text-4-6-2-1">
<ul class="org-ul">
<li>In the following code, I simulate and time the circuit</li>
<li>In Jupyter Lab, the time to run a cell can be obtained by adding <code>%%time</code> at
the top of the cell.</li>
<li>These notes are not written in Jupyter Lab, so I use the <code>time</code> module
<ul class="org-ul">
<li>Key instructions:
<ul class="org-ul">
<li><code>import time</code> to access the module</li>
<li>Use <code>time.time()</code> to get the current time</li>
<li>The difference between two <code>time</code> objects can be used to calculate a time
interval in seconds</li>
</ul></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> time
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_basic.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_basic_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_basic_sim ))
</pre>
</div>

<pre class="example">
{'000000000000000000000000': 531, '111111111111111111111111': 493}
Time elapsed: 17.700 s
</pre>
</div>
</li>

<li><a id="org99bddad"></a><code>AerSimulator</code><br />
<div class="outline-text-5" id="text-4-6-2-2">
<ul class="org-ul">
<li>We now run and time the same circuit using the <code>AerSimulator</code>, and we see it
is much faster for larger circuits</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'111111111111111111111111': 537, '000000000000000000000000': 487}
Time elapsed:  0.025 s
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org538fec2" class="outline-3">
<h3 id="org538fec2"><span class="section-number-3">4.7.</span> Simulation Methods</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>Qiskit Aer supports different types of simulation, accessible through the
<code>method</code> keyword argument to the <code>run()</code> command.
<ul class="org-ul">
<li>The default is <code>method</code>'statevector'=
<ul class="org-ul">
<li>The limit here is 24 qubits</li>
</ul></li>
<li>Other methods include <code>'matrix_product_state'</code></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org61d6858" class="outline-4">
<h4 id="org61d6858"><span class="section-number-4">4.7.1.</span> Build a Large Circuit</h4>
<div class="outline-text-4" id="text-4-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 50
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-org1d1ba1d" class="outline-4">
<h4 id="org1d1ba1d"><span class="section-number-4">4.7.2.</span> Run and Time the Simulation</h4>
<div class="outline-text-4" id="text-4-7-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024, method=<span style="color: #CC9393;">'matrix_product_state'</span> ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'11111111111111111111111111111111111111111111111111': 492, '00000000000000000000000000000000000000000000000000': 532}
Time elapsed:  0.081 s
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdbe5d01" class="outline-3">
<h3 id="orgdbe5d01"><span class="section-number-3">4.8.</span> Noisy Simulation</h3>
<div class="outline-text-3" id="text-4-8">
</div>
<div id="outline-container-org72bd844" class="outline-4">
<h4 id="org72bd844"><span class="section-number-4">4.8.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-8-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0])

qc.draw()
</pre>
</div>


<div id="org105350e" class="figure">
<p><img src="./img/noisyCktExample.png" alt="noisyCktExample.png" width="480px" />
</p>
<p><span class="figure-number">Figure 11: </span>This is a small circuit for noisy simulation using the <code>AerSimulator</code>.</p>
</div>
</div>
</div>

<div id="outline-container-org2b2e1ea" class="outline-4">
<h4 id="org2b2e1ea"><span class="section-number-4">4.8.2.</span> Ideal Result</h4>
<div class="outline-text-4" id="text-4-8-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This will throw an error for n &gt; 25 using method='statevector'</span>
<span style="color: #DFAF8F;">qc_aer</span> = transpile( qc, backend=simulator_aer )
<span style="color: #DFAF8F;">result_ideal</span> = simulator_aer.run( qc_aer, shots=1024 ).result()
<span style="color: #DFAF8F;">counts_ideal</span> = result_ideal.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_ideal)
</pre>
</div>

<pre class="example">
{'11': 520, '00': 504}
</pre>
</div>
</div>

<div id="outline-container-orgd522cda" class="outline-4">
<h4 id="orgd522cda"><span class="section-number-4">4.8.3.</span> Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> noise

<span style="color: #DFAF8F;">prob</span> = 0.1
<span style="color: #DFAF8F;">error</span> = noise.depolarizing_error( prob, 2 )

<span style="color: #DFAF8F;">noise_model</span> = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error( error, [<span style="color: #CC9393;">'cx'</span>])
<span style="color: #DFAF8F;">basis_gates</span> = noise_model.basis_gates

<span style="color: #DFAF8F;">result_noisy</span> = simulator_aer.run(qc,
                                shots=1024,
                                noise_model=noise_model,
                                basis_gates=basis_gates).result()

<span style="color: #DFAF8F;">counts_noisy</span> = result_noisy.get_counts()
</pre>
</div>
</div>
</div>

<div id="outline-container-org711e418" class="outline-4">
<h4 id="org711e418"><span class="section-number-4">4.8.4.</span> Compare Ideal Result and Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment this to see the compared distributions</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )</span>
</pre>
</div>


<div id="org1ffcc69" class="figure">
<p><img src="./img/AerSimIdealvsNoisy.png" alt="AerSimIdealvsNoisy.png" width="640px" />
</p>
<p><span class="figure-number">Figure 12: </span>An ideal <code>AerSimulator</code> result is compared to a noisy result.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2da6bbd" class="outline-3">
<h3 id="org2da6bbd"><span class="section-number-3">4.9.</span> Summary</h3>
<div class="outline-text-3" id="text-4-9">
<p>
The <code>AerSimulator()</code> is useful when we want to:
</p>
<ol class="org-ol">
<li>Find counts/samples of large circuits (simulators are efficient)</li>
<li>Find state vector/density matrix of circuits with measurements</li>
<li>Simulate circuits with noise</li>
</ol>

<p>
The AerSimulator() results do not match the output format of Qiskit IBM runtime
(the quantum hardware).
</p>

<p>
Qiskit Aer has its own sampler/estimator, which provide a closer match to the
inputs and outputs of the hardware, but these are being deprecated.
</p>

<p>
In the next section, we explore <a href="https://docs.quantum.ibm.com/api/qiskit/primitives">primitives</a>, which are used
in Qiskit IBM runtime.
</p>
</div>
</div>
</div>

<div id="outline-container-org8bdaef7" class="outline-2">
<h2 id="org8bdaef7"><span class="section-number-2">5.</span> Qiskit Primitives</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org92d8699" class="outline-3">
<h3 id="org92d8699"><span class="section-number-3">5.1.</span> Overview</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>The interface for the various simulators (BasicSimulator, AerSimulator) were
identical to the Qiskit IBM Provider interface to the quantum hardware</li>
<li>The backend was an abstraction for something that was either simulator or an
actual quantum processor.</li>
<li>Primitives abstract the interface between users and backends</li>
<li>There are two available primitives:
<ul class="org-ul">
<li>Sampler - this samples the output state of a circuit</li>
<li>Estimator - this stimates expectation values of a state with respect to
observables</li>
</ul></li>
<li>Qiskit, Qiskit Aer, and Qiskit IBM Runtime each provide different primitives.</li>
<li>Diego recommends starting with the version 2 primitives, which are compatible
with the current hardware:</li>

<li>Qiskit
<ul class="org-ul">
<li>StatevectorSampler</li>
<li>StatevectorEstimator</li>
</ul></li>
<li>Qiskit Aer (none or being deprecated)</li>
<li>Qiskit IBM Runtime
<ul class="org-ul">
<li>SamplerV2</li>
<li>EstimatorV2</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org9123edc" class="outline-3">
<h3 id="org9123edc"><span class="section-number-3">5.2.</span> Primitives</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Qiskit primitives are computational building blocks used in larger applications that require quantum resources to efficiently produce outputs. The inputs to a primitive consists of primitive unified blocs (PUBs).
</p>

<p>
There are two types of primitives:
</p>
<ol class="org-ol">
<li><code>EstimatorV2</code></li>
<li><code>SamplerV2</code></li>
</ol>

<p>
The workflow is as before: build a circuit, and then simulate it (or run it on
hardware).
</p>
</div>

<div id="outline-container-org65c2064" class="outline-4">
<h4 id="org65c2064"><span class="section-number-4">5.2.1.</span> Imports</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorSampler, StatevectorEstimator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print('imports complete') # it's sometimes desirable to check job completion</span>
</pre>
</div>

<pre class="example">
imports complete
</pre>
</div>
</div>

<div id="outline-container-org57830a6" class="outline-4">
<h4 id="org57830a6"><span class="section-number-4">5.2.2.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2, 2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measurement register: c</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org9253a89" class="figure">
<p><img src="./img/qisprimckt01.png" alt="qisprimckt01.png" width="480px" />
</p>
<p><span class="figure-number">Figure 13: </span>This is a circuit for use with the <code>qiskit</code> primitives.</p>
</div>
</div>
</div>

<div id="outline-container-org3dc35eb" class="outline-4">
<h4 id="org3dc35eb"><span class="section-number-4">5.2.3.</span> Run Simulations</h4>
<div class="outline-text-4" id="text-5-2-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">simulator</span> = BasicSimulator()
<span style="color: #DFAF8F;">sampler</span> = StatevectorSampler()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgeb77583"></a>Basic Simulation<br />
<div class="outline-text-5" id="text-5-2-3-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">No transpilation is needed for this simple circuit</span>
<span style="color: #DFAF8F;">job_simulator</span> = simulator.run( qc, shots=1024)
</pre>
</div>
</div>
</li>

<li><a id="org8bfb5f4"></a>Simulation using a Sampler<br />
<div class="outline-text-5" id="text-5-2-3-2">
<ul class="org-ul">
<li>The syntax for a sampler simulation is somewhat different than that of the
<code>BasicSimulator</code> class.
<ul class="org-ul">
<li>Here, inputs are in the form of primitive-unified blocs (PUBS)</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_sampler</span> = sampler.run( [qc], shots=1024)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgfe0eff4" class="outline-4">
<h4 id="orgfe0eff4"><span class="section-number-4">5.2.4.</span> Extracting Results</h4>
<div class="outline-text-4" id="text-5-2-4">
<ul class="org-ul">
<li>We extract results in the same way from both the simulator and the sampler:</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_simulator</span> = job_simulator.result()
<span style="color: #DFAF8F;">result_sampler</span> = job_sampler.result()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org16f944f"></a>Simulator Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-1">
<ul class="org-ul">
<li><p>
We can retrieve counts from the simulator result as before, using the
<code>get_counts()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = result_simulator.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>( counts_simulator )
</pre>
</div>

<pre class="example">
{'11': 522, '00': 502}
</pre></li>
</ul>
</div>
</li>


<li><a id="org866fc8b"></a>Sampler Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-2">
<ul class="org-ul">
<li><p>
Getting counts from the sampler is a bit more involved. Let's eamine the
results we obtained:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(result_sampler))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_sampler)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
PrimitiveResult([SamplerPubResult(data=DataBin(c=BitArray(&lt;shape=(), num_shots=1024, num_bits=2&gt;)), metadata={'shots': 1024, 'circuit_metadata': {}})], metadata={'version': 2})
</pre>


<ul class="org-ul">
<li>The results from the sampler come as an object of class <code>PubResult</code>
object.
<ul class="org-ul">
<li>This class has a <code>get_counts()</code> method.</li>
<li>Since the input PUB for the sampler is a list, we must similarly index the
result to get the result(s)  for a specific PUB item.</li>
<li>If we don't provide an index, get<sub>counts</sub>() will
aggregate the results, which may not be what we want.</li>
</ul></li>
</ul></li>
<li>To get counts, we do the following:</li>
<li>index the PUB result. Here, we call for the zeroth element.</li>
<li>reference the data member data element, and reference the classical register name.</li>
<li><p>
use the <code>get_counts()</code> method.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[0].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 504, '00': 520}
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org9af13e7" class="outline-3">
<h3 id="org9af13e7"><span class="section-number-3">5.3.</span> Example: A Parametrized Circuit</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter
<span style="color: #F0DFAF; font-weight: bold;">from</span> math <span style="color: #F0DFAF; font-weight: bold;">import</span> pi

<span style="color: #DFAF8F;">&#952;</span> = Parameter(<span style="color: #CC9393;">'&#952;'</span>)

<span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">assign a parameter for this rotation</span>
qc2.cx(1, 0)
qc2.measure_all()
qc2.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org4d58876" class="figure">
<p><img src="./img/prametrizedckt.png" alt="prametrizedckt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 14: </span>This circuit has a parameter θ.</p>
</div>
</div>


<div id="outline-container-org450d046" class="outline-4">
<h4 id="org450d046"><span class="section-number-4">5.3.1.</span> <code>BasicSimulator</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Here, we make a list of circuits, each with a specific value of the parameter θ.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">angles</span> = [[pi/4], [pi/3], [pi/2]]

<span style="color: #DFAF8F;">circuits</span> = []
<span style="color: #F0DFAF; font-weight: bold;">for</span> angle <span style="color: #F0DFAF; font-weight: bold;">in</span> angles:
    <span style="color: #DFAF8F;">qc_temp</span> = qc2.assign_parameters({&#952;:angle[0]})
    circuits.append(qc_temp)
</pre>
</div>

<p>
We can draw the different circuits by indexing the list:
</p>
<div class="org-src-container">
<pre class="src src-python">circuits[1].draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org0e93a33" class="figure">
<p><img src="./img/prametrizedckt_ex.png" alt="prametrizedckt_ex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 15: </span>We print a circuit from a list of circuits. Unlike the circuit of Fig. <a href="#org4d58876">14</a>, this circuit has a specific value for θ.</p>
</div>
</div>


<ol class="org-ol">
<li><a id="org27246f4"></a>Transpiling and Running<br />
<div class="outline-text-5" id="text-5-3-1-1">
<ul class="org-ul">
<li>The entire list of circuits can be transpiled in a single call to <code>transpile()</code></li>
<li><p>
The transpiled list can be called using one call to the <code>BasicSimulator.run()</code>
method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">transpile the circuit list</span>
<span style="color: #DFAF8F;">circuits_t</span> = transpile( circuits, backend=simulator )

<span style="color: #DFAF8F;">result_simulator</span> = simulator.run( circuits_t, shots=1024 ).result()
</pre>
</div></li>
<li><p>
We provide an index to <code>get_counts()</code> for the corresponding circuit in
<code>circuits_t</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = []

<span style="color: #F0DFAF; font-weight: bold;">for</span> i, _ <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(angles):
    <span style="color: #DFAF8F;">result_temp</span> = result_simulator.get_counts(i)
    counts_simulator.append(result_temp)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_simulator)
</pre>
</div>

<pre class="example">
[{'00': 875, '11': 149}, {'00': 780, '11': 244}, {'11': 465, '00': 559}]
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org3582a58" class="outline-4">
<h4 id="org3582a58"><span class="section-number-4">5.3.2.</span> <code>StatevectorSampler</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>For a sampler, we pass a list of PUBs. This contains
<ul class="org-ul">
<li>the generic parametrized circuit, along with</li>
<li>the list of parameters</li>
</ul></li>
<li>This makes the <code>run()</code> command very simple.</li>
<li>To get the results, we index the <code>result_sampler</code>, i.e., <code>results_sampler[0]</code>
<ul class="org-ul">
<li>This indexes the zeroth (and only) PUB, with the flexibility to support multiple PUBs</li>
</ul></li>
<li>We iterate over the angles as before to get results for each angles</li>
</ul>
<div class="warning" id="org3b03091">
<p>
Caution: if we simply use <code>result.sampler[0].data.meas.get_counts()</code>, this aggregates the counts by summing them. Often, this is not what we want. 
</p>

</div>
</div>
</div>


<div id="outline-container-orgd742efb" class="outline-4">
<h4 id="orgd742efb"><span class="section-number-4">5.3.3.</span> <code>StatevectorSampler</code> Usage with Multiple PUBs</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
We now pass two PUBs, each with a different circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0], [1,0])

qc.draw()
</pre>
</div>


<div id="org7391eb9" class="figure">
<p><img src="./img/circuit_multiPUBex.png" alt="circuit_multiPUBex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 16: </span>A circuit for use in an example with multiple PUBs.</p>
</div>
</div>

<ol class="org-ol">
<li><a id="orgdee669c"></a>Run the Multi-Pub Basic Sampler<br />
<div class="outline-text-5" id="text-5-3-3-1">
<ul class="org-ul">
<li>Here, we run one job with two different PUBs, each with a different circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_sampler</span> = sampler.run([(qc2, angles), (qc, <span style="color: #BFEBBF;">None</span>)], shots=1024).result()
</pre>
</div>
</div>
</li>

<li><a id="orgcadae7a"></a>Retrieve Data for the Zeroth Circuit<br />
<div class="outline-text-5" id="text-5-3-3-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = [ result_sampler[0].data.meas.get_counts(k) <span style="color: #F0DFAF; font-weight: bold;">for</span> k <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
[{'00': 857, '11': 167}, {'00': 774, '11': 250}, {'00': 501, '11': 523}]
</pre>
</div>
</li>

<li><a id="orgb3ec433"></a>Retrieve Data for the First Circuit<br />
<div class="outline-text-5" id="text-5-3-3-3">
<ul class="org-ul">
<li>Here, we have a non-parametrized circuit, so we don't need to provide an argument to <code>get_counts()</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[1].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 521, '00': 503}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org67ab06c" class="outline-3">
<h3 id="org67ab06c"><span class="section-number-3">5.4.</span> The Estimator Primitive</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>The <code>StatevectorEstimator</code> primitive takes a PUB, but with a slightly different format from <code>BasicSampler</code>.</li>
<li>The circuits cannot have any measurement gates</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1)
qc2.cx(1, 0)

qc2.draw( reverse_bits = <span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org189e789" class="figure">
<p><img src="./img/sample_ckt_for_Estimator.png" alt="sample_ckt_for_Estimator.png" width="480px" />
</p>
<p><span class="figure-number">Figure 17: </span>This circuit was built for use with an <code>Estimator</code> simulation. For this reason, we do not include measurement blocks.</p>
</div>
</div>

<div id="outline-container-org11fd80d" class="outline-4">
<h4 id="org11fd80d"><span class="section-number-4">5.4.1.</span> Observables</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>Since an estimator estimates expectation values \(\left\langle \psi |
  \mathbf{O} | \right\rangle\), we need an observable, \(\mathbf{O}\).</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This is a list of observables. I'm not sure why it's a list of lists.</span>
<span style="color: #DFAF8F;">obsv</span> = [ [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"IY"</span>], [0.5, 0.5] ) ],
         [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>], [1] ) ] ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv)
</pre>
</div>

<pre class="example">
[[SparsePauliOp(['XX', 'IY'],
              coeffs=[0.5+0.j, 0.5+0.j])], [SparsePauliOp(['XX'],
              coeffs=[1.+0.j])]]
</pre>
</div>
</div>

<div id="outline-container-orga071f6f" class="outline-4">
<h4 id="orga071f6f"><span class="section-number-4">5.4.2.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
<span style="color: #DFAF8F;">result_estimator</span> = estimator.run( [(qc2, obsv, angles, 0.1)] ).result()
</pre>
</div>
</div>
</div>

<div id="outline-container-org0489841" class="outline-4">
<h4 id="org0489841"><span class="section-number-4">5.4.3.</span> Extract Expectation Values</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
<li>(optional) we can see some metadata using the <code>.metadata</code> function</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Extract the expectation values (evs) from the result for PUB 0</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].data.evs)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].metadata)
</pre>
</div>

<pre class="example">
[[ 0.05985877  0.14030793  0.18762585]
 [ 0.10722808 -0.04870472  0.15934201]]
{'target_precision': 0.1, 'circuit_metadata': {}}
</pre>


<ul class="org-ul">
<li>This is a list of two observables, with one value for each of the input
parameters.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org52ef8b8" class="outline-3">
<h3 id="org52ef8b8"><span class="section-number-3">5.5.</span> Qiskit Estimator Example</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li><p>
This provides another example from a Qiskit documentation <a href="https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives">tutorial</a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">circuit for which you want to obtain the expected value</span>
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.ry(Parameter(<span style="color: #CC9393;">'theta'</span>), 0)
qc.h(0)
qc.cx(0,1)
qc.draw(<span style="color: #CC9393;">"mpl"</span>, style=<span style="color: #CC9393;">"iqp"</span>)
</pre>
</div>


<div id="orgda7dcef" class="figure">
<p><img src="./img/EstimatorIBMExCkt.png" alt="EstimatorIBMExCkt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 18: </span>This is a simple circuit built for an IBM Quantum tutorial on using the <code>StatevectorEstimator</code>.</p>
</div></li>
</ul>
</div>

<div id="outline-container-orge214bbe" class="outline-4">
<h4 id="orge214bbe"><span class="section-number-4">5.5.1.</span> Build an Operator</h4>
<div class="outline-text-4" id="text-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">observable(s) whose expected values you want to compute</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #DFAF8F;">observable</span> = SparsePauliOp([<span style="color: #CC9393;">"II"</span>, <span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"YY"</span>, <span style="color: #CC9393;">"ZZ"</span>], coeffs=[1, 1, -1, 1])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">value(s) for the circuit parameter(s)</span>
<span style="color: #DFAF8F;">parameter_values</span> = [[0], [np.pi/6], [np.pi/2]]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(parameter_values)
</pre>
</div>

<pre class="example">
[[0], [0.5235987755982988], [1.5707963267948966]]
</pre>
</div>
</div>


<div id="outline-container-org4824695" class="outline-4">
<h4 id="org4824695"><span class="section-number-4">5.5.2.</span> Instantiate a <code>StatevectorEstimator</code></h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorEstimator
<span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
</pre>
</div>
</div>
</div>


<div id="outline-container-org6c71d61" class="outline-4">
<h4 id="org6c71d61"><span class="section-number-4">5.5.3.</span> Transpile the Circuit</h4>
<div class="outline-text-4" id="text-5-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Generate a pass manager without providing a backend</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(optimization_level=1)
<span style="color: #DFAF8F;">isa_circuit</span> = pm.run(qc)
<span style="color: #DFAF8F;">isa_observable</span> = observable.apply_layout(isa_circuit.layout)
</pre>
</div>
</div>
</div>

<div id="outline-container-org04fc17e" class="outline-4">
<h4 id="org04fc17e"><span class="section-number-4">5.5.4.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-5-4">
<ul class="org-ul">
<li>We form a PUB as an argument to the <code>StatevectorEstimator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job</span> = estimator.run([(isa_circuit, isa_observable, parameter_values)])
<span style="color: #DFAF8F;">result</span> = job.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Result class: </span>{<span style="color: #DCDCCC; font-weight: bold;">type</span>(result)}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
&gt; Result class: &lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
</pre>
</div>
</div>

<div id="outline-container-org4abc252" class="outline-4">
<h4 id="org4abc252"><span class="section-number-4">5.5.5.</span> Extract Results</h4>
<div class="outline-text-4" id="text-5-5-5">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the
following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(result)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">len</span>(result))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Expectation value: </span>{result[0].data.evs}<span style="color: #CC9393;">"</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Metadata: </span>{result[0].metadata}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), stds=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), shape=(3,)), metadata={'target_precision': 0.0, 'circuit_metadata': {}})], metadata={'version': 2})
1
 &gt; Expectation value: [4.         3.73205081 2.        ]
 &gt; Metadata: {'target_precision': 0.0, 'circuit_metadata': {}}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orga6a2476" class="outline-2">
<h2 id="orga6a2476"><span class="section-number-2">6.</span> Qiskit IBM Runtime Primitives</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org0c1b90b" class="outline-3">
<h3 id="org0c1b90b"><span class="section-number-3">6.1.</span> Imports</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> math <span style="color: #F0DFAF; font-weight: bold;">import</span> pi <span style="color: #F0DFAF; font-weight: bold;">as</span> &#960;

<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_distribution
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2, EstimatorV2, QiskitRuntimeService
</pre>
</div>
</div>
</div>

<div id="outline-container-org3c9f6c1" class="outline-3">
<h3 id="org3c9f6c1"><span class="section-number-3">6.2.</span> Load a Personal IBM Token</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>You need a personal IBM token to access the hardware.</li>
<li>There are several ways to do this.</li>
<li>The first thing, however, is to get a personal IBM Quantum token</li>
</ul>
</div>
<div id="outline-container-org2d8da26" class="outline-4">
<h4 id="org2d8da26"><span class="section-number-4">6.2.1.</span> Getting Your IBM Quantum Token</h4>
<div class="outline-text-4" id="text-6-2-1">
<ol class="org-ol">
<li>If you don't already have one, use your university e-mail account
(prefferable) to register for an account.</li>
<li>Once logged in, you can get your IBM token in one of two ways:
<ol class="org-ol">
<li>Visit your <a href="https://quantum.ibm.com">IBM Quantum Platform dashboard</a>
<ol class="org-ol">
<li><p>
In the upper right, you'll see a box where you can view or copy your
IBM Quantum API token
</p>

<div id="orgbc19e7c" class="figure">
<p><img src="./img/IBMQuantumDashboard.png" alt="IBMQuantumDashboard.png" width="360px" />
</p>
</div></li>
</ol></li>
<li><p>
Click the "Account" button (it looks like an anonymized profile pic). This
brings up your <i>Profile Settings</i>
</p>

<div id="org8145b27" class="figure">
<p><img src="./img/IBMQuantumAccountIcon.png" alt="IBMQuantumAccountIcon.png" width="360px" />
</p>
</div>
<ol class="org-ol">
<li>Below the <i>Profile Details</i> is an <i>API Token</i>. Click the icon that allows
you to copy you IBM Quantum API token. You will paste this information
elsewhere later.</li>
</ol></li>
</ol></li>
</ol>
</div>
</div>



<div id="outline-container-org8d6c6af" class="outline-4">
<h4 id="org8d6c6af"><span class="section-number-4">6.2.2.</span> The <a href="https://docs.python.org/3/library/getpass.html">getpass</a> Package</h4>
<div class="outline-text-4" id="text-6-2-2">
<ul class="org-ul">
<li>This is a nice Python package that is useful in Jupyter notebooks</li>
<li>It allows you to prompt the user for a password that can be used later in the file.</li>
<li><p>
The basic usage is:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> getpass <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">this comes with standard Python</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This interactively prompts the user for their password</span>
<span style="color: #DFAF8F;">token</span> = getpass.getpass(<span style="color: #CC9393;">'Enter your password: '</span>)
</pre>
</div></li>
<li>You can then use <code>token</code> in an API call</li>
<li>This allows you to share Jupyter notebooks <i>without</i> also sharing your
password/token/API key.</li>
</ul>
</div>
</div>

<div id="outline-container-org60a85fd" class="outline-4">
<h4 id="org60a85fd"><span class="section-number-4">6.2.3.</span> Acessing IBM Quantum Harware Using Your Token</h4>
<div class="outline-text-4" id="text-6-2-3">
<ul class="org-ul">
<li><p>
Once you have a variable <code>token</code> that contains your API key, you can
leverage the <code>QiskitRuntimeService.save_account()</code> to save the token your
computer for future use:
</p>
<div class="org-src-container">
<pre class="src src-python">QiskitRuntimeService.save_account(
    channel=<span style="color: #CC9393;">"ibm_quantum"</span>,
    token=token,
    overwrite=<span style="color: #BFEBBF;">True</span>,
    set_as_default=<span style="color: #BFEBBF;">True</span>)
</pre>
</div></li>
</ul>
<p>
We can then put it all together in the following way:
</p>
<ol class="org-ol">
<li>Check your computer to see if there's a saved IBM quantum token.
<ol class="org-ol">
<li>If yes, use it</li>
<li>If not, prompt the user for the token
<ol class="org-ol">
<li>In this case, we replace the variable <code>token</code> with a call to
<code>getpass.getpass()</code>, which effectively supplies the token to
<code>QiskitRuntimeService()</code></li>
</ol></li>
</ol></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">try</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Load any previously-saved IBM Quantum tokens</span>
    QiskitRuntimeService.saved_accounts()
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">"Found and loaded a previously-saved IBM Quantum API token."</span>)
<span style="color: #F0DFAF; font-weight: bold;">except</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Otherwise, prompt user for token</span>
    QiskitRuntimeService.save_account(
    channel=<span style="color: #CC9393;">"ibm_quantum"</span>,
    token=getpass.getpass(<span style="color: #CC9393;">"No token found. Enter your IBM Quantum API token: "</span>),
    overwrite=<span style="color: #BFEBBF;">True</span>,
    set_as_default=<span style="color: #BFEBBF;">True</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">"Account saved successfully!"</span>)
</pre>
</div>

<pre class="example">
Found and loaded a previously-saved IBM Quantum API token.
</pre>
</div>
</div>


<div id="outline-container-org15633d2" class="outline-4">
<h4 id="org15633d2"><span class="section-number-4">6.2.4.</span> My Approach (not recommended)</h4>
<div class="outline-text-4" id="text-6-2-4">
<ul class="org-ul">
<li>I use this approach because I sometimes run Python code <i>outside</i> of a Jupyter
notebook, so I don't have an opportunity to dynamically input my password
using <code>getpass</code></li>
<li>My approach was to save a file on my computer, say, <code>~/.IBMQpass</code>
<ul class="org-ul">
<li>This is a text file containing only my IBM Quantum token</li>
</ul></li>
<li><p>
Then, I can load the token in a variable called <code>token</code> using code like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Read the token from a secure file</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Expand the '~' to the full path</span>
<span style="color: #DFAF8F;">file_path</span> = os.path.expanduser(<span style="color: #CC9393;">"~/.IBMQpass"</span>)
<span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span>(file_path, <span style="color: #CC9393;">"r"</span>) <span style="color: #F0DFAF; font-weight: bold;">as</span> <span style="color: #DCDCCC; font-weight: bold;">file</span>:
    <span style="color: #DFAF8F;">token</span> = <span style="color: #DCDCCC; font-weight: bold;">file</span>.read().strip()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Loaded IBM Quantum token: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(datetime.now()))
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgde9e4dc" class="outline-3">
<h3 id="orgde9e4dc"><span class="section-number-3">6.3.</span> Establish a Connection</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li><p>
To interface with the IBM cloud resources, we establish as
<code>QiskitRuntimeService</code> object, <code>service</code>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">service</span> = QiskitRuntimeService(channel=<span style="color: #CC9393;">'ibm_quantum'</span>)
</pre>
</div></li>

<li><p>
We can then use the <code>service</code> object to query available QPUs
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(service.backends())
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">in Jupyter notebook, you don't need print() ... just use</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">service.backends() as the last command in your cell.</span>
</pre>
</div>

<pre class="example">
[&lt;IBMBackend('ibm_brisbane')&gt;, &lt;IBMBackend('ibm_kyiv')&gt;, &lt;IBMBackend('ibm_sherbrooke')&gt;]
</pre></li>

<li>This is a list of objects of the <a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend">IBMBackend</a> class
<ul class="org-ul">
<li><p>
We can ask for the least-busy backend using the <code>.least_busy()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">save the least-busy backend as backend</span>
<span style="color: #DFAF8F;">backend</span> = service.least_busy()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(backend)
</pre>
</div>

<pre class="example">
&lt;IBMBackend('ibm_brisbane')&gt;
</pre></li>
</ul></li>

<li><p>
We can get information about a backend using properties such as <code>.name</code>,
<code>.version</code>, and <code>.num_qubits</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(
    f<span style="color: #CC9393;">"Name: </span>{backend.name}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"Version: </span>{backend.version}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"No. of qubits: </span>{backend.num_qubits}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
)
</pre>
</div>

<pre class="example">
Name: ibm_brisbane
Version: 2
No. of qubits: 127
</pre></li>
<li><p>
A backend has more attributes, which we can uncover if we use the <code>.__dict__</code>
property:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(backend.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_options': Options(shots=4000, memory=False, meas_level=&lt;MeasLevel.CLASSIFIED: 2&gt;, meas_return=&lt;MeasReturnType.AVERAGE: 'avg'&gt;, memory_slots=None, memory_slot_size=100, rep_time=None, rep_delay=None, init_qubits=True, use_measure_esp=None, use_fractional_gates=False, noise_model=None, seed_simulator=None), '_provider': None, 'name': 'ibm_brisbane', 'description': None, 'online_date': datetime.datetime(2023, 1, 23, 5, 0, tzinfo=tzutc()), 'backend_version': '1.1.66', '_coupling_map': None, '_instance': 'ibm-q/open/main', '_service': &lt;QiskitRuntimeService&gt;, '_api_client': &lt;qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x122bed850&gt;, '_configuration': &lt;qiskit_ibm_runtime.models.backend_configuration.PulseBackendConfiguration object at 0x122915f90&gt;, '_properties': &lt;qiskit_ibm_runtime.models.backend_properties.BackendProperties object at 0x126f1a9d0&gt;, '_defaults': &lt;qiskit_ibm_runtime.models.pulse_defaults.PulseDefaults object at 0x126ccbdd0&gt;, '_target': &lt;qiskit.transpiler.target.Target object at 0x1206080a0&gt;, '_max_circuits': 300, '_session': None}
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-orga558281" class="outline-3">
<h3 id="orga558281"><span class="section-number-3">6.4.</span> Define Sampler Instances</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li><p>
We will create backends so we can compare a simulation using <code>AerSimulator()</code>
against a calculation on actual quantum hardware
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">backend_aer</span> = AerSimulator() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator backend</span>
<span style="color: #DFAF8F;">backend_qpu</span> = backend <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">hardware backend</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(backend_aer))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(backend_qpu))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit_aer.backends.aer_simulator.AerSimulator'&gt;
&lt;class 'qiskit_ibm_runtime.ibm_backend.IBMBackend'&gt;
</pre></li>

<li><p>
We now use the backends to define samplers
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">sampler_aer</span> = SamplerV2(backend_aer) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for simulator</span>
<span style="color: #DFAF8F;">sampler_qpu</span> = SamplerV2(backend_qpu) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for QPU</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(sampler_aer))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(sampler_qpu))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit_ibm_runtime.sampler.SamplerV2'&gt;
&lt;class 'qiskit_ibm_runtime.sampler.SamplerV2'&gt;
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-orgce144d3" class="outline-3">
<h3 id="orgce144d3"><span class="section-number-3">6.5.</span> Create Some Circuits</h3>
<div class="outline-text-3" id="text-6-5">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1</span> = QuantumCircuit(1)
qc1.h(0)
qc1.measure_all()
qc1.draw()
</pre>
</div>


<div id="orga84403e" class="figure">
<p><img src="./img/simQPUckt.png" alt="simQPUckt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 19: </span>This circuit is designed for simulation and implementation on actual IBM quantum hardware.</p>
</div>

<ul class="org-ul">
<li>A parametrized circuit is create as a second circuit to test</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#952;</span> = Parameter(<span style="color: #CC9393;">'&#952;'</span>)
<span style="color: #DFAF8F;">&#981;</span> = Parameter(<span style="color: #CC9393;">'&#981;'</span>)

<span style="color: #DFAF8F;">qr</span> = QuantumRegister(2, name=<span style="color: #CC9393;">'q'</span>)

<span style="color: #DFAF8F;">cr</span> = ClassicalRegister(2, name=<span style="color: #CC9393;">'SomeName'</span>)

<span style="color: #DFAF8F;">qc2</span> = QuantumCircuit( qr, cr )
qc2.rx(&#952;,1)
qc2.cry(&#981;,1,0)
qc2.measure(qr, cr)
qc2.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org05d78a3" class="figure">
<p><img src="./img/simQPUckt2.png" alt="simQPUckt2.png" width="480px" />
</p>
<p><span class="figure-number">Figure 20: </span>This parameterized circuit provides a second circuit to compare in simulation and on actual hardware.</p>
</div>

<ul class="org-ul">
<li><p>
Next, we define angles for use with circuit 2:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">angles</span> = [[&#960;/4, &#960;/2], [&#960;/3, &#960;], [&#960;/2, &#960;]]
</pre>
</div>

<ul class="org-ul">
<li>The there are three sets of parameters</li>
<li>Each set has two angles, one for each parameter</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org662cb98" class="outline-3">
<h3 id="org662cb98"><span class="section-number-3">6.6.</span> Transpile the Circuits</h3>
<div class="outline-text-3" id="text-6-6">
</div>
<div id="outline-container-org354d8d6" class="outline-4">
<h4 id="org354d8d6"><span class="section-number-4">6.6.1.</span> Circuit 1 (Aer)</h4>
<div class="outline-text-4" id="text-6-6-1">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#orga84403e">19</a> for the <code>AerSimulator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1_aer</span> = transpile( qc1, backend=backend_aer)
qc1_aer.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>

<pre class="example">
#+attr_html: :width 480px
#+caption: The circuit of Figure [[fig:simQPUckt1]] is transpiled for the =AerSimulator=.
[[./img/simQPUckt1trans_aer.png]]
</pre>



<div id="org00de63f" class="figure">
<p><img src="./img/simQPUckt1trans_aer.png" alt="simQPUckt1trans_aer.png" width="480px" />
</p>
<p><span class="figure-number">Figure 21: </span>The circuit of Figure <a href="#orga84403e">19</a> is transpiled for the <code>AerSimulator</code>.</p>
</div>
</div>
</div>

<div id="outline-container-orgdccb6b5" class="outline-4">
<h4 id="orgdccb6b5"><span class="section-number-4">6.6.2.</span> Circuit 2 (Aer)</h4>
<div class="outline-text-4" id="text-6-6-2">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#org05d78a3">20</a> for the <code>AerSimulator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2_aer</span> = transpile( qc2, backend=backend_aer)
qc2_aer.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org9997b1f" class="figure">
<p><img src="./img/simQPUckt2trans_aer.png" alt="simQPUckt2trans_aer.png" width="480px" />
</p>
<p><span class="figure-number">Figure 22: </span>The circuit of Figure <a href="#org05d78a3">20</a> is transpiled for the <code>AerSimulator</code>.</p>
</div>


<ul class="org-ul">
<li>We also transpile and optimize the circuit <code>qc2</code>
<ul class="org-ul">
<li><p>
To do this, we use the <code>generate_preset_pass_manager</code> function
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #DFAF8F;">target</span> = backend_aer.target
<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(target=target, optimization_level=1)
<span style="color: #DFAF8F;">qc2_aer</span> = pm.run(qc2)
qc2_aer.draw( reverse_bits=<span style="color: #BFEBBF;">True</span> )
</pre>
</div>


<div id="org8a56fc6" class="figure">
<p><img src="./img/simQPUckt2trans_aer_pm.png" alt="simQPUckt2trans_aer_pm.png" width="480px" />
</p>
<p><span class="figure-number">Figure 23: </span>Here, the circuit of Figure <a href="#org05d78a3">20</a> is transpiled using a pass manager. It is the same as the result in Figure <a href="#org9997b1f">22</a>.</p>
</div></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1c7d4ca" class="outline-4">
<h4 id="org1c7d4ca"><span class="section-number-4">6.6.3.</span> Circuit 1 (QPU)</h4>
<div class="outline-text-4" id="text-6-6-3">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#orga84403e">19</a> for the quantum hardware</li>
<li>Since the hardware has many more qubits than the circuit, we use
<code>idle_wires=False</code> to suppress the display of idle qubits when we use the
<code>.draw()</code> method</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1_qpu</span> = transpile( qc1, backend=backend_qpu)
qc1_qpu.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>, idle_wires=<span style="color: #BFEBBF;">False</span> )
</pre>
</div>


<div id="org8f0ede1" class="figure">
<p><img src="./img/simQPUckt1trans_qpu.png" alt="simQPUckt1trans_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 24: </span>The circuit of Figure <a href="#orga84403e">19</a> is transpiled for the quantum hardware.</p>
</div>
</div>
</div>
<div id="outline-container-orgacc190e" class="outline-4">
<h4 id="orgacc190e"><span class="section-number-4">6.6.4.</span> Circuit 2 (QPU)</h4>
<div class="outline-text-4" id="text-6-6-4">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#org05d78a3">20</a> for the quantum hardware</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">target</span> = backend_qpu.target
<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(target=target, optimization_level=1)
<span style="color: #DFAF8F;">qc2_qpu</span> = pm.run(qc2)
qc2_qpu.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>, idle_wires=<span style="color: #BFEBBF;">False</span> )
</pre>
</div>


<div id="orgdf1eacc" class="figure">
<p><img src="./img/simQPUckt2trans_qpu.png" alt="simQPUckt2trans_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 25: </span>The circuit of Figure <a href="#org05d78a3">20</a> is transpiled for the quantum hardware.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaa2a1e3" class="outline-3">
<h3 id="orgaa2a1e3"><span class="section-number-3">6.7.</span> Simulate the Circuits</h3>
<div class="outline-text-3" id="text-6-7">
<ul class="org-ul">
<li>The sampler <code>.run()</code> method triggers the simulation</li>
</ul>
</div>
<div id="outline-container-org4a2c2f9" class="outline-4">
<h4 id="org4a2c2f9"><span class="section-number-4">6.7.1.</span> Simulate on the Aer Sampler</h4>
<div class="outline-text-4" id="text-6-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_aer</span> = sampler_aer.run( [ (qc1_aer, <span style="color: #BFEBBF;">None</span>, 100), (qc2_aer, angles, 1000) ] )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Print is not needed in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(job_aer.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_job_id': '9288fdc7-7e26-40d7-b919-d32ca46a577a', 'metadata': {}, '_future': &lt;Future at 0x145e6e6d0 state=running&gt;, '_function': &lt;bound method BackendSamplerV2._run of &lt;qiskit.primitives.backend_sampler_v2.BackendSamplerV2 object at 0x14581b4d0&gt;&gt;, '_args': ([SamplerPub(&lt;()&gt;), SamplerPub(&lt;(3,)&gt;)],), '_kwargs': {}}
</pre>
</div>
</div>

<div id="outline-container-org37fefad" class="outline-4">
<h4 id="org37fefad"><span class="section-number-4">6.7.2.</span> Run on Quantum Hardware</h4>
<div class="outline-text-4" id="text-6-7-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_qpu</span> = sampler_qpu.run( [ (qc1_qpu, <span style="color: #BFEBBF;">None</span>, 100), (qc2_qpu, angles, 1000) ] )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Print is not needed in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(job_qpu)
</pre>
</div>

<pre class="example">
/Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 625.82641167829 quantum seconds, but you only have 565 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
  warnings.warn(warning_message)
&lt;RuntimeJobV2('cya60g201rbg008jq0v0', 'sampler')&gt;
</pre>


<ul class="org-ul">
<li>Once your job is sumbitted, it IBM Quantum will assign it a unique job
ID.</li>
<li>Let's see what information is embedded in the job<sub>qpu</sub> object:</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(job_qpu.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_job_id': 'cya60g201rbg008jq0v0', 'metadata': {}, '_backend': &lt;IBMBackend('ibm_brisbane')&gt;, '_api_client': &lt;qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x14533be50&gt;, '_interim_results': None, '_creation_date': None, '_program_id': 'sampler', '_reason': None, '_reason_code': None, '_error_message': None, '_image': None, '_final_interim_results': False, '_service': &lt;QiskitRuntimeService&gt;, '_session_id': None, '_tags': None, '_usage_estimation': {}, '_version': 2, '_queue_info': None, '_user_callback': None, '_status': 'INITIALIZING', '_interim_result_decoder': &lt;class 'qiskit_ibm_runtime.utils.result_decoder.ResultDecoder'&gt;, '_final_result_decoder': &lt;class 'qiskit_ibm_runtime.utils.sampler_result_decoder.SamplerResultDecoder'&gt;, '_ws_client_future': None, '_result_queue': &lt;queue.Queue object at 0x1401a57d0&gt;, '_ws_client': &lt;qiskit_ibm_runtime.api.clients.runtime_ws.RuntimeWebsocketClient object at 0x1404550d0&gt;}
</pre>

<ul class="org-ul">
<li>We can obtain using the .job<sub>id</sub>() method.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_id</span> = job_qpu.job_id()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">"Your job's identifier is: </span>{job_id}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
Your job's identifier is: cya60g201rbg008jq0v0
</pre>


<ul class="org-ul">
<li><p>
As long as our Juptyer Lab notebook is open, we can access our job through the
<code>job_id</code> object using the <code>result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_qpu</span> = job_qpu.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_qpu)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=100, num_bits=1&gt;)), metadata={'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(&lt;shape=(3,), num_shots=1000, num_bits=2&gt;), shape=(3,)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([SliceSpan(&lt;start='2025-01-25 03:53:39', stop='2025-01-25 03:53:54', size=100&gt;), SliceSpan(&lt;start='2025-01-25 03:53:39', stop='2025-01-25 03:53:52', size=3000&gt;)])}, 'version': 2})
</pre></li>

<li>If we shut down our Jupyter Lab notebook, we clear the memory, and the information stored in job<sub>id</sub> is lost.</li>
<li>The job ID is important because we can retrieve the results from IBM using
this ID.</li>
<li>Thus, it may be helpful to record the job ID somewhere. As a fallback, we can
always go to the IBM Quantum portal and then find the job.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd5bf3a1" class="outline-4">
<h4 id="orgd5bf3a1"><span class="section-number-4">6.7.3.</span> Get Results from the <code>AerSampler</code></h4>
<div class="outline-text-4" id="text-6-7-3">
<ul class="org-ul">
<li><p>
View results:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_aer</span> = job_aer.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_aer)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=100, num_bits=1&gt;)), metadata={'shots': 100, 'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(&lt;shape=(3,), num_shots=1000, num_bits=2&gt;), shape=(3,)), metadata={'shots': 1000, 'circuit_metadata': {}})], metadata={'version': 2})
</pre></li>

<li><p>
We retrieve the counts from the Aer sampler results:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_qc1_aer</span> = result_aer[0].data.meas.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_qc1_aer)
</pre>
</div>

<pre class="example">
{'0': 56, '1': 44}
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org3ba9395" class="outline-4">
<h4 id="org3ba9395"><span class="section-number-4">6.7.4.</span> Comparing Simulation and QPU Results</h4>
<div class="outline-text-4" id="text-6-7-4">
<ul class="org-ul">
<li><p>
When comparing results, it's usually a great idea to make a visualization
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fig</span> = plot_distribution([counts_qc1_aer, counts_qc1_qpu],
                        legend=[<span style="color: #CC9393;">'Simulator'</span>, <span style="color: #CC9393;">'QPU'</span>])
</pre>
</div>

<pre class="example">
Saved figure
</pre>



<div id="org515bfc8" class="figure">
<p><img src="./img/compareCountsAerQPU.png" alt="compareCountsAerQPU.png" width="620px" />
</p>
<p><span class="figure-number">Figure 26: </span>Counts from the QPU are compared against those from the Aer simulator for circuit 1.</p>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1623104" class="outline-3">
<h3 id="org1623104"><span class="section-number-3">6.8.</span> Simulation vs QPU: Estimator</h3>
<div class="outline-text-3" id="text-6-8">
<ul class="org-ul">
<li>Estimators get us not counts, but expectation values for observables.</li>
</ul>
</div>
<div id="outline-container-org37b4bf9" class="outline-4">
<h4 id="org37b4bf9"><span class="section-number-4">6.8.1.</span> Defining Estimator Objects</h4>
<div class="outline-text-4" id="text-6-8-1">
<ul class="org-ul">
<li><p>
Define Aer and QPU estimators:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">estimator_aer</span> = EstimatorV2( backend_aer )
<span style="color: #DFAF8F;">estimator_qpu</span> = EstimatorV2( backend_qpu )
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org273a7c9" class="outline-4">
<h4 id="org273a7c9"><span class="section-number-4">6.8.2.</span> Defining Observable Operators</h4>
<div class="outline-text-4" id="text-6-8-2">
<ul class="org-ul">
<li><p>
We also need observable(s) to supply for the estimators:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">obsv_list</span> = [[SparsePauliOp([<span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"IY"</span>], [0.5, 0.5])],
             [SparsePauliOp([<span style="color: #CC9393;">"XX"</span>], [1])],
             [SparsePauliOp([<span style="color: #CC9393;">"IY"</span>], [1])]]
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orga31be8c" class="outline-4">
<h4 id="orga31be8c"><span class="section-number-4">6.8.3.</span> Layout Mapping</h4>
<div class="outline-text-4" id="text-6-8-3">
<ul class="org-ul">
<li><p>
This observable must be mapped to the circuit of interest.
</p>
<ul class="org-ul">
<li>This is important because the hardware may have many more (idle) qubits than
our circuit does.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">layout</span> = qc2_qpu.layout 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(layout))

<span style="color: #DFAF8F;">obsv_qpu</span> = []

<span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list:
    <span style="color: #DFAF8F;">obsv_temp</span> = obsv[0].apply_layout(layout)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_temp)
    obsv_qpu.append([obsv_temp])
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.transpiler.layout.TranspileLayout'&gt;
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
              coeffs=[0.5+0.j, 0.5+0.j])
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX'],
              coeffs=[1.+0.j])
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
              coeffs=[1.+0.j])
</pre></li>
<li>The simulated estimator does <b>not</b> need the modified observables, and we will run
only one circuit</li>
</ul>
</div>
</div>

<div id="outline-container-orgc04f23f" class="outline-4">
<h4 id="orgc04f23f"><span class="section-number-4">6.8.4.</span> Simulation</h4>
<div class="outline-text-4" id="text-6-8-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job2_aer</span> = estimator_aer.run([(qc2_aer, obsv_list, angles, 0.01)])
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f7005f" class="outline-4">
<h4 id="org1f7005f"><span class="section-number-4">6.8.5.</span> QPU Submission</h4>
<div class="outline-text-4" id="text-6-8-5">
<div class="org-src-container">
<pre class="src src-python" id="org0071b65"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">If you've never submitted the job before, set job2_id to None</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">job2_id = None</span>
<span style="color: #DFAF8F;">job2_id</span> = <span style="color: #CC9393;">'cya6t20nrmz000862cs0'</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span> job2_id <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
    <span style="color: #DFAF8F;">job2_qpu</span> = estimator_qpu.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
    <span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Submitted new job with id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Loads by ID a pre-existing job from IBM Quantum </span>
    <span style="color: #DFAF8F;">job2_gpu</span> = QiskitRuntimeService().job(job2_id)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Loaded old job with id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
</pre>
</div>

<pre class="example">
/Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 647.0957899365619 quantum seconds, but you only have 546 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
  warnings.warn(warning_message)
Submitted new job with id: cya6t20nrmz000862cs0
</pre>



<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(job2_qpu)
<span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Job id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
<span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Status: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.status()) )

<span style="color: #F0DFAF; font-weight: bold;">if</span> job2_qpu.status() == <span style="color: #CC9393;">'DONE'</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(job2_qpu.metrics())
</pre>
</div>

<pre class="example">
&lt;RuntimeJobV2('cya6t20nrmz000862cs0', 'estimator')&gt;
Job id: cya6t20nrmz000862cs0
Status: DONE
{'bss': {'seconds': 18}, 'usage': {'quantum_seconds': 18, 'seconds': 18}, 'timestamps': {'created': '2025-01-25T04:48:08.442Z', 'finished': '2025-01-25T04:48:43.251Z', 'running': '2025-01-25T04:48:11.227Z'}, 'executions': 62144, 'num_circuits': 224, 'num_qubits': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127], 'circuit_depths': [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23], 'qiskit_version': 'qiskit_ibm_runtime-0.33.2,qiskit-1.3.1*,qiskit_aer-0.16.0*', 'estimated_start_time': '2025-01-25T04:48:09.875Z', 'estimated_completion_time': '2025-01-25T04:48:27.875Z', 'position_in_queue': None, 'position_in_provider': None}
</pre>


<ul class="org-ul">
<li>My job submission showed a job ID of <code>cya6t20nrmz000862cs0</code>
<ul class="org-ul">
<li>If we want to shut down or Jupyter notebook, we need to record this job number</li>
<li>Additionally, we want to go back to Listing <a href="#org0071b65">2</a> and comment out
<code>job2_id = None</code>, and uncomment <code>job2_id = 'cya6t20nrmz000862cs0'</code>
<ul class="org-ul">
<li>This will prevent us from running a redundant job, and rather let us use
the results already calculated</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf51b942" class="outline-4">
<h4 id="orgf51b942"><span class="section-number-4">6.8.6.</span> Retrieve Estimator Results</h4>
<div class="outline-text-4" id="text-6-8-6">
<ul class="org-ul">
<li>We get the expectation values by indexing the result and using the <code>.data.evs</code>
member data</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">exp_vals_aer</span> = job2_aer.result()[0].data.evs
<span style="color: #DCDCCC; font-weight: bold;">print</span>(exp_vals_aer)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(angles)
</pre>
</div>

<pre class="example">
[[-0.0055 -0.0028  0.0034]
 [-0.0104 -0.0038  0.0082]
 [-0.0006 -0.0018 -0.0014]]
[[0.7853981633974483, 1.5707963267948966], [1.0471975511965976, 3.141592653589793], [1.5707963267948966, 3.141592653589793]]
</pre>


<p>
The above list of list contains the expectation values.
</p>
<ul class="org-ul">
<li>There are three sublists, each corresponding to one of the three different
parameter sets.</li>
<li>Each sublist is a set of three expectation values corresponding to the three
observables in <code>obs_qpu</code>.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb4f2eed" class="outline-3">
<h3 id="orgb4f2eed"><span class="section-number-3">6.9.</span> Three Runtime Execution Methods</h3>
<div class="outline-text-3" id="text-6-9">
<ol class="org-ol">
<li>Job. Send a list of Pubs, receive PUB results</li>
<li>Session. This is good for hybrid algorithms, such VQE and VAOA. Iterations of
these algorithms depend on one another. Classical processing is done in the
cloud.</li>
<li>Batch. A series of independent jobs may be executed in parallel.</li>
</ol>
</div>
<div id="outline-container-org641c773" class="outline-4">
<h4 id="org641c773"><span class="section-number-4">6.9.1.</span> Sessions</h4>
<div class="outline-text-4" id="text-6-9-1">
<p>
We use context managers, soemthing like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> Session
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime.fake_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> Fake

<span style="color: #DFAF8F;">obsv_qpu</span> = [[obsv[0].apply_laout(qc2_qpu.layout) <span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_qpu)

<span style="color: #F0DFAF; font-weight: bold;">with</span> Session(backend=backend_man) <span style="color: #F0DFAF; font-weight: bold;">as</span> session
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Sampler primitive within the session</span>
    sampler = SamplerV2(session=session)
    job = sampler.run([(qc2_qpu, angles, 1000)])
    pub_result = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'1st Circuit Counts: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.SomeName.get_counts(0)}<span style="color: #CC9393;"> </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">'</span>)

    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Estimator primitive within the session</span>
    estimator = EstimatorV2(session=session)
    job = estimator.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
    pub_result = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Expectation values: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.evs}<span style="color: #CC9393;">'</span>)        
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org46342d7"></a>Session on a Fake Backend<br />
<div class="outline-text-5" id="text-6-9-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> Session
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime.fake_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> FakeManilaV2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">backend_fake</span> = FakeManilaV2()
<span style="color: #DFAF8F;">sampler_fake</span> = SamplerV2( backend_fake )
</pre>
</div>
</div>
</li>

<li><a id="org86e8443"></a>Transpile Circuit for <code>FakeManilaV2</code><br />
<div class="outline-text-5" id="text-6-9-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2_fake</span> = transpile(qc2, backend=backend_fake)
qc2_fake.draw()
</pre>
</div>


<div id="org8d083a1" class="figure">
<p><img src="./img/fakeManillaCkt.png" alt="fakeManillaCkt.png" width="680px" />
</p>
<p><span class="figure-number">Figure 27: </span>A circuit is transpiled for simulation on the <code>FakeManilaV2</code> backend.</p>
</div>
</div>
</li>

<li><a id="org90f0f06"></a>Layout Mapping for Observable<br />
<div class="outline-text-5" id="text-6-9-1-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">obsv_fake</span> = [[obsv[0].apply_layout(qc2_fake.layout) <span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list]]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_fake)
</pre>
</div>

<pre class="example">
[[SparsePauliOp(['XXIII', 'YIIII'],
              coeffs=[0.5+0.j, 0.5+0.j]), SparsePauliOp(['XXIII'],
              coeffs=[1.+0.j]), SparsePauliOp(['YIIII'],
              coeffs=[1.+0.j])]]
</pre>
</div>
</li>


<li><a id="org37516b8"></a>Run a Session<br />
<div class="outline-text-5" id="text-6-9-1-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">with</span> Session(backend=backend_fake) <span style="color: #F0DFAF; font-weight: bold;">as</span> session:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Sampler primitive within the session</span>
    <span style="color: #DFAF8F;">sampler</span> = SamplerV2(session)
    <span style="color: #DFAF8F;">job</span> = sampler.run([(qc2_fake, angles, 1000)])
    <span style="color: #DFAF8F;">pub_result</span> = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'1st Circuit Counts: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.SomeName.get_counts(0)}<span style="color: #CC9393;"> </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">'</span>)

    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Estimator primitive within the session</span>
    <span style="color: #DFAF8F;">estimator</span> = EstimatorV2(session)
    <span style="color: #DFAF8F;">job</span> = estimator.run([(qc2_fake, obsv_fake, angles, 0.01)])
    <span style="color: #DFAF8F;">pub_result</span> = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Expectation values: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.evs}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
1st Circuit Counts: 
 {'10': 72, '00': 854, '11': 62, '01': 12} 

Expectation values: 
 [[ 0.0097 -0.0074  0.022 ]]
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Dr. E.P. Blair</p>
<p class="date">Created: 2025-01-24 Fri 23:22</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
