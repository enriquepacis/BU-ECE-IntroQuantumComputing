<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-03-11 Tue 15:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Qiskit + IBM: Simulation and Calculation</title>
<meta name="author" content="Dr. E.P. Blair" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Qiskit + IBM: Simulation and Calculation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#qinfoOverview">1. Overview</a></li>
<li><a href="#qinfoModule">2. The <code>quantum_info</code> Module</a>
<ul>
<li><a href="#org685e148">2.1. Overview</a></li>
<li><a href="#orgd4766e0">2.2. Make a Quantum Circuit</a></li>
<li><a href="#org4ac5bf2">2.3. Get an Output <code>Statevector()</code> Object</a></li>
<li><a href="#org2927700">2.4. Measurement Probabilities</a></li>
<li><a href="#org8814aa6">2.5. Simulated Experiments</a>
<ul>
<li><a href="#org26d0233">2.5.1. Measurement Outcomes for Each Shot</a></li>
<li><a href="#orgf8cb61d">2.5.2. Cumulative Results over an Ensemble</a></li>
<li><a href="#org3290f7c">2.5.3. Expectation Values</a></li>
<li><a href="#org55a3b98">2.5.4. Bloch Vectors</a></li>
<li><a href="#org87515cf">2.5.5. Density Matrices</a></li>
</ul>
</li>
<li><a href="#org3b7aeb7">2.6. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:BasicSimulator">3. The <code>BasicSimulator</code> Class</a>
<ul>
<li><a href="#org6c084c7">3.1. Build a Circuit</a></li>
<li><a href="#orge374c09">3.2. Simulating the Circuit</a></li>
<li><a href="#orgd4ae4ae">3.3. Getting the Results</a>
<ul>
<li><a href="#orgfe54b61">3.3.1. Simulation Counts</a></li>
<li><a href="#org249bb15">3.3.2. Visualizing the Results</a></li>
<li><a href="#org19a6711">3.3.3. Inspecting Results from Individual Measurements</a></li>
</ul>
</li>
<li><a href="#orgfaf2670">3.4. Handling Complex Circuits</a>
<ul>
<li><a href="#orgee3e0c4">3.4.1. Transpilation</a></li>
</ul>
</li>
<li><a href="#orgefdab82">3.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:QiskitAerSimulator">4. The <code>qiskit_aer.AerSimulator</code> Class</a>
<ul>
<li><a href="#orgf390261">4.1. Overview</a></li>
<li><a href="#orgd645417">4.2. Imports</a></li>
<li><a href="#org6f3a5d3">4.3. Build a Circuit</a></li>
<li><a href="#org812ee26">4.4. Run the <code>AerSimulator()</code></a></li>
<li><a href="#org18af62b">4.5. Example 2: Circuit with Statevector in Middle of Circuit</a>
<ul>
<li><a href="#orgb9df1e0">4.5.1. Transpile and Run the Circuit</a></li>
</ul>
</li>
<li><a href="#orgdd988ff">4.6. Efficient Simulation</a>
<ul>
<li><a href="#orga0ce8a7">4.6.1. Build a Circuit</a></li>
<li><a href="#org108acbf">4.6.2. Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></a></li>
</ul>
</li>
<li><a href="#org576752c">4.7. Simulation Methods</a>
<ul>
<li><a href="#orgb041ddf">4.7.1. Build a Large Circuit</a></li>
<li><a href="#orgf669c01">4.7.2. Run and Time the Simulation</a></li>
</ul>
</li>
<li><a href="#org2d6a14d">4.8. Noisy Simulation</a>
<ul>
<li><a href="#org183666a">4.8.1. Build a Circuit</a></li>
<li><a href="#org4127856">4.8.2. Ideal Result</a></li>
<li><a href="#org67ab38f">4.8.3. Noisy Result</a></li>
<li><a href="#orgc17b8e1">4.8.4. Compare Ideal Result and Noisy Result</a></li>
</ul>
</li>
<li><a href="#orga97c068">4.9. Summary</a></li>
</ul>
</li>
<li><a href="#orgc4a64dd">5. Qiskit Primitives</a>
<ul>
<li><a href="#orgd5d2905">5.1. Overview</a></li>
<li><a href="#orgd630c47">5.2. Primitives</a>
<ul>
<li><a href="#org88941df">5.2.1. Imports</a></li>
<li><a href="#org8dea888">5.2.2. Build a Circuit</a></li>
<li><a href="#orge1433b1">5.2.3. Run Simulations</a></li>
<li><a href="#org65bf87f">5.2.4. Extracting Results</a></li>
</ul>
</li>
<li><a href="#org357d5e3">5.3. Example: A Parametrized Circuit</a>
<ul>
<li><a href="#org07ddd63">5.3.1. <code>BasicSimulator</code> Usage</a></li>
<li><a href="#org3eea180">5.3.2. <code>StatevectorSampler</code> Usage</a></li>
<li><a href="#orgb1f843b">5.3.3. <code>StatevectorSampler</code> Usage with Multiple PUBs</a></li>
</ul>
</li>
<li><a href="#orgb0403bd">5.4. The Estimator Primitive</a>
<ul>
<li><a href="#org17811ac">5.4.1. Observables</a></li>
<li><a href="#orge5c17fd">5.4.2. Run the Estimator</a></li>
<li><a href="#org8030d97">5.4.3. Extract Expectation Values</a></li>
</ul>
</li>
<li><a href="#orgfc08b88">5.5. Qiskit Estimator Example</a>
<ul>
<li><a href="#org247942f">5.5.1. Build an Operator</a></li>
<li><a href="#orgf016b33">5.5.2. Instantiate a <code>StatevectorEstimator</code></a></li>
<li><a href="#orgb064307">5.5.3. Transpile the Circuit</a></li>
<li><a href="#orge4532c2">5.5.4. Run the Estimator</a></li>
<li><a href="#org407248f">5.5.5. Extract Results</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org34759c7">6. <code>qiskit_aer</code> Primitives</a>
<ul>
<li><a href="#org501b305">6.1. Example: Bell Circuits and the <code>SamplerV2</code> Class</a>
<ul>
<li><a href="#org36d4d8a">6.1.1. Imports</a></li>
<li><a href="#orgcad7625">6.1.2. Bell Circuits</a></li>
<li><a href="#org4502ed1">6.1.3. Transpilation</a></li>
<li><a href="#org6cc0665">6.1.4. Forming PUBs</a></li>
<li><a href="#orgc076166">6.1.5. Simulating the Circuits</a></li>
<li><a href="#org1ff91eb">6.1.6. Accessing Results</a></li>
</ul>
</li>
<li><a href="#org2ec6670">6.2. Summary</a></li>
</ul>
</li>
<li><a href="#orgb58bfcd">7. Bell Circuits on IBM Quantum Hardware</a>
<ul>
<li><a href="#org0b25907">7.1. Imports</a></li>
<li><a href="#org80f0b2a">7.2. The Bell Circuits</a></li>
<li><a href="#org62d1818">7.3. Transpilation</a>
<ul>
<li><a href="#orgc02b052">7.3.1. Getting Your IBM Quantum API Token</a></li>
<li><a href="#org961d1bc">7.3.2. The getpass Package</a></li>
<li><a href="#org32da2e8">7.3.3. My Approach to Loading My Token (not recommended)</a></li>
<li><a href="#org07ba7ea">7.3.4. Establish a Connection to IBM Quantum</a></li>
<li><a href="#orgd780987">7.3.5. Transpilation</a></li>
<li><a href="#orge134e18">7.3.6. Forming PUBs</a></li>
</ul>
</li>
<li><a href="#org15a3f12">7.4. Running the Circuits</a></li>
<li><a href="#org43530cb">7.5. Accessing the Results</a></li>
</ul>
</li>
<li><a href="#org1d8701f">8. Qiskit IBM Runtime Primitives</a>
<ul>
<li><a href="#org83ce0b2">8.1. Imports</a></li>
<li><a href="#orgd191730">8.2. Load a Personal IBM Token</a>
<ul>
<li><a href="#orge516632">8.2.1. Getting Your IBM Quantum Token</a></li>
<li><a href="#orga215e01">8.2.2. The getpass Package</a></li>
<li><a href="#orga1cada8">8.2.3. Acessing IBM Quantum Harware Using Your Token</a></li>
<li><a href="#org36a5f72">8.2.4. My Approach (not recommended)</a></li>
</ul>
</li>
<li><a href="#org6b8d93f">8.3. Establish a Connection</a></li>
<li><a href="#orgb7b8024">8.4. Define Sampler Instances</a></li>
<li><a href="#org76b98f3">8.5. Create Some Circuits</a></li>
<li><a href="#org1daed8a">8.6. Transpile the Circuits</a>
<ul>
<li><a href="#org6d34c96">8.6.1. Circuit 1 (Aer)</a></li>
<li><a href="#org2ce4f5d">8.6.2. Circuit 2 (Aer)</a></li>
<li><a href="#orgffb82b6">8.6.3. Circuit 1 (QPU)</a></li>
<li><a href="#orgf1fb013">8.6.4. Circuit 2 (QPU)</a></li>
</ul>
</li>
<li><a href="#org795b27a">8.7. Simulate the Circuits</a>
<ul>
<li><a href="#orgc897000">8.7.1. Simulate on the Aer Sampler</a></li>
<li><a href="#org95bb2c0">8.7.2. Run on Quantum Hardware</a></li>
<li><a href="#orgc6646fc">8.7.3. Get Results from the <code>AerSampler</code></a></li>
<li><a href="#org3c60679">8.7.4. Comparing Simulation and QPU Results</a></li>
</ul>
</li>
<li><a href="#orge4fbe2b">8.8. Simulation vs QPU: Estimator</a>
<ul>
<li><a href="#org0998ed7">8.8.1. Defining Estimator Objects</a></li>
<li><a href="#orga0a3bcb">8.8.2. Defining Observable Operators</a></li>
<li><a href="#org308649e">8.8.3. Layout Mapping</a></li>
<li><a href="#org23ec95a">8.8.4. Simulation</a></li>
<li><a href="#orge73bc0a">8.8.5. QPU Submission</a></li>
<li><a href="#org7a91651">8.8.6. Retrieve Estimator Results</a></li>
</ul>
</li>
<li><a href="#orgc70c73d">8.9. Three Runtime Execution Methods</a>
<ul>
<li><a href="#orgb383b90">8.9.1. Sessions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-qinfoOverview" class="outline-2">
<h2 id="qinfoOverview"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-qinfoOverview">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>This page focuses on quantum computing simulations or job submissions on IBM
hardware
<ul class="org-ul">
<li>There are several ways to simulate quantum computations
<ul class="org-ul">
<li>Statevector simulations</li>
<li>Using SamplerV2 or EstimatorV2</li>
</ul></li>
</ul></li>
</ul>

<p>
The general work-flow is to:
</p>
<ol class="org-ol">
<li>Create a quantum circuit</li>
<li>Decide whether to simulate it or run it on quantum hardware
<ol class="org-ol">
<li>Typically, we simulate it first</li>
<li>We want our simulation syntax to match as closely as possible to the
syntax of job submission.</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-qinfoModule" class="outline-2">
<h2 id="qinfoModule"><span class="section-number-2">2.</span> The <code>quantum_info</code> Module</h2>
<div class="outline-text-2" id="text-qinfoModule">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-org685e148" class="outline-3">
<h3 id="org685e148"><span class="section-number-3">2.1.</span> Overview</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is built into <code>qiskit</code> and provides some basic
simulations
<ul class="org-ul">
<li>This is useful when we want to understand the quantum properties of the
output of a circuit</li>
<li>It provides:
<ul class="org-ul">
<li><code>Statevector</code> simulations</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd4766e0" class="outline-3">
<h3 id="orgd4766e0"><span class="section-number-3">2.2.</span> Make a Quantum Circuit</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In a Jupyter notebook we could make a cell like this:
</p>
<div class="org-src-container">
<pre class="src src-python" id="orga2817b9"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">import</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">as</span> qi

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.x(0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a NOT gate to qubit 0</span>
qc.h([0,1]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a H to both qubits</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter notebook, you can uncomment "qc.draw()"</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">to see your circuit</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">qc.draw()</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<p>
In Jupyter Lab, your result may be displayed automatically and look like Figure
<a href="#org4aaa628">1</a>.
</p>

<div id="org4aaa628" class="figure">
<p><img src="./img/xh2.png" alt="xh2.png" width="300px" />
</p>
<p><span class="figure-number">Figure 1: </span>A simple <code>qiskit</code> quantum circuit.</p>
</div>
</div>
</div>
<div id="outline-container-org4ac5bf2" class="outline-3">
<h3 id="org4ac5bf2"><span class="section-number-3">2.3.</span> Get an Output <code>Statevector()</code> Object</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We can then obtain the circuit output in <code>Statevector</code> form:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#968;</span> = qi.Statevector( qc )

<span style="color: #DCDCCC; font-weight: bold;">print</span>( &#968; )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter Lab notebook, you can see the result using this:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw()</span>
</pre>
</div>

<pre class="example">
Statevector([ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],
            dims=(2, 2))
</pre>


<p>
In a Jupyter notebook, you can comment <code>print( ψ )</code> and uncomment <code>ψ.draw()</code>
to  see a result that's nicer than the one shown here. It may look like this:
</p>

\begin{equation}
\label{org0575a9d}
\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle-
\frac{1}{2} |11\rangle
\end{equation}
</div>
</div>

<div id="outline-container-org2927700" class="outline-3">
<h3 id="org2927700"><span class="section-number-3">2.4.</span> Measurement Probabilities</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Once we have a <code>Statevector</code> object, we can use it to see the probabilities of
measurement, which are the modulii squared of the coefficients:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>( &#968;.probabilities() )
</pre>
</div>

<pre class="example">
[0.25 0.25 0.25 0.25]
</pre>


<p>
In this case, there are four outcomes, each with a 1/4 probability of
occurring.
</p>
</div>
</div>

<div id="outline-container-org8814aa6" class="outline-3">
<h3 id="org8814aa6"><span class="section-number-3">2.5.</span> Simulated Experiments</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Generally, a quantum computing experiment requires establishing a circuit and
performing measurements many times. Each repetition is a <b>shot</b> or a <b>trial</b>,
and a collection of shots is an <b>ensemble</b> of measurements.
</p>
</div>

<div id="outline-container-org26d0233" class="outline-4">
<h4 id="org26d0233"><span class="section-number-4">2.5.1.</span> Measurement Outcomes for Each Shot</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
We can use <code>ψ</code> to simulate circuit measurements using the <code>sample_memory()</code>
method. We specify a number of shots (trials), and we get a histogram of
samples, that is, the number of times each outcome was measured.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">samples</span> = &#968;.sample_memory( shots = 10 )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This lists the outcomes measured for each of the 10 shots</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
['01' '01' '11' '01' '00' '00' '11' '01' '01' '00']

Calculation complete at 2025-02-26 13:41:02.891472
</pre>
</div>
</div>

<div id="outline-container-orgf8cb61d" class="outline-4">
<h4 id="orgf8cb61d"><span class="section-number-4">2.5.2.</span> Cumulative Results over an Ensemble</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>If we don't care about each shot, but rather, we care more about aggregate
data, we can use <code>sample_counts()</code>
<ul class="org-ul">
<li>For a given number of shots, it simulates the set of measurements, returning
a frequency (number of occurrences) for each outcome measured.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = &#968;.sample_counts( shots = 1024 )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
{np.str_('00'): np.int64(247), np.str_('01'): np.int64(253), np.str_('10'): np.int64(261), np.str_('11'): np.int64(263)}

Calculation complete at 2025-02-26 13:41:11.727536
</pre>


<p>
The counts can be visualized in a histogram. In a Jupyter notebook, use the
following, but uncomment the <code>plot_histogram()</code> command:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment in Jupyter to see histogram</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_histogram( counts )</span>
</pre>
</div>

<p>
#+RESULTS
</p>
<pre class="example">
[[./img/basic_hist.png]]

Calculation complete at 2025-02-26 13:41:38.404511
</pre>



<div id="org08f8b5e" class="figure">
<p><img src="./img/basic_hist.png" alt="basic_hist.png" width="480px" />
</p>
<p><span class="figure-number">Figure 2: </span>This is a histogram of simulated measurents based on a <code>Statevector</code> output from a quantum circuit.</p>
</div>

<p>
State vector simulations get us a state vector, and we are using that state
vector object to simulate measurements.
</p>
</div>
</div>

<div id="outline-container-org3290f7c" class="outline-4">
<h4 id="org3290f7c"><span class="section-number-4">2.5.3.</span> Expectation Values</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
State vector simulations also allow us to get expectation values, as defined in
Equation \eqref{orgae33c27}
</p>
\begin{equation}
\label{orgae33c27}
\left\langle \mathbf{O} \right\rangle = \left\langle \psi \left| \mathbf{O} \right| \psi  \right\rangle 
\end{equation}

<p>
First, we form an operator:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O</span> = qi.SparsePauliOp([<span style="color: #CC9393;">'ZZ'</span>, <span style="color: #CC9393;">'XX'</span>, <span style="color: #CC9393;">'II'</span>], [0.2, -0.3, 0.4])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment this in Jupyter</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">display(O.to_operator())</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment/omit this in Jupyter</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(O.to_operator())

</pre>
</div>

<pre class="example">
Operator([[ 0.6+0.j,  0. +0.j,  0. +0.j, -0.3+0.j],
          [ 0. +0.j,  0.2+0.j, -0.3+0.j,  0. +0.j],
          [ 0. +0.j, -0.3+0.j,  0.2+0.j,  0. +0.j],
          [-0.3+0.j,  0. +0.j,  0. +0.j,  0.6+0.j]],
         input_dims=(2, 2), output_dims=(2, 2))
</pre>


<p>
Next, we supply \(\mathbf{O}\) to the <code>ψ</code> (a <code>Statevector</code> object) in its
<code>expectation_value()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O_exp</span> = &#968;.expectation_value( O )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(O_exp)
</pre>
</div>

<pre class="example">
(0.6999999999999997+0j)
</pre>
</div>
</div>

<div id="outline-container-org55a3b98" class="outline-4">
<h4 id="org55a3b98"><span class="section-number-4">2.5.4.</span> Bloch Vectors</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
We can ask Python to draw the Bloch vector for ψ:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Use this in Jupyter:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw('bloch')</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment this out or omit the following in Jupyter</span>
p
<span style="color: #DFAF8F;">fname</span> = os.join(<span style="color: #CC9393;">'html'</span>, <span style="color: #CC9393;">'img'</span>, <span style="color: #CC9393;">'basicBlochVect.png'</span>)
&#968;.draw(<span style="color: #CC9393;">'bloch'</span>, filename=fname)
<span style="color: #F0DFAF; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #F0DFAF; font-weight: bold;">as</span> plt
plt.savefig( fname )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'[[./</span>{fname[5:]}<span style="color: #CC9393;">]]'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">ls *.png
</pre>
</div>


<div id="orgb042b4c" class="figure">
<p><img src="./img/basicBlochVect.png" alt="basicBlochVect.png" width="480px" />
</p>
<p><span class="figure-number">Figure 3: </span>Bloch vectors for the two qubits in ψ.</p>
</div>
</div>
</div>


<div id="outline-container-org87515cf" class="outline-4">
<h4 id="org87515cf"><span class="section-number-4">2.5.5.</span> Density Matrices</h4>
<div class="outline-text-4" id="text-2-5-5">
<p>
Similar to a <code>Statevector</code>, we can also get a <code>DensityMarix</code> from a
circuit. Recall that a density matrix \(\rho\) may be obtained from a state
vector:
</p>
\begin{equation}
\rho = \ket{\psi} \bra{\psi}
\end{equation}
</div>

<ol class="org-ol">
<li><a id="org8ec4a77"></a>Matrix Output<br />
<div class="outline-text-5" id="text-2-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;</span> = qi.DensityMatrix( qc )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, you may use</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">display( &#961; )</span>
</pre>
</div>

<pre class="example">
DensityMatrix([[ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j],
               [ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j]],
              dims=(2, 2))
</pre>



<p>
In Jupyter, you may see output like this from the <code>display()</code> command:
</p>
\begin{equation}
\begin{bmatrix}
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\end{bmatrix}
\end{equation}
</div>
</li>



<li><a id="org35254bb"></a>The City Plot<br />
<div class="outline-text-5" id="text-2-5-5-2">
<p>
In Jupyter, we can plot the elements of the density matrix:
</p>

<div id="orga83aa94" class="figure">
<p><img src="./img/dmCityScape.png" alt="dmCityScape.png" width="600px" />
</p>
</div>
</div>
</li>

<li><a id="org35ed5bb"></a>Partial Trace<br />
<div class="outline-text-5" id="text-2-5-5-3">
<p>
Given a multi-qubit density matrix, we can get a reduced density matrix for any
subset of qubits.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;1</span> = qi.partial_trace( &#961;, [0] )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;1)
</pre>
</div>

<pre class="example">
DensityMatrix([[0.5+0.j, 0.5+0.j],
               [0.5+0.j, 0.5+0.j]],
              dims=(2,))
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org3b7aeb7" class="outline-3">
<h3 id="org3b7aeb7"><span class="section-number-3">2.6.</span> Conclusion</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is useful for:
<ul class="org-ul">
<li>very basic simulations</li>
<li>exploring the quantum output of a circuit</li>
</ul></li>
<li>The <code>quantum_info</code> module does not handle circuit simulations that:
<ul class="org-ul">
<li>are too large</li>
<li>involve any measurement gates</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec:BasicSimulator" class="outline-2">
<h2 id="sec:BasicSimulator"><span class="section-number-2">3.</span> The <code>BasicSimulator</code> Class</h2>
<div class="outline-text-2" id="text-sec:BasicSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>We need the <code>BasicSimulator</code> class to perform simulations for circuits that
include measurement gates</li>
</ul>
</div>
<div id="outline-container-org6c084c7" class="outline-3">
<h3 id="org6c084c7"><span class="section-number-3">3.1.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Following Diego Serrano's tutorial, I build a circuit which includes
measurement gates
<ul class="org-ul">
<li><p>
Start by importing required code
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #DFAF8F;">simulator_basic</span> = BasicSimulator()
</pre>
</div>

<ul class="org-ul">
<li>The main things we've accomplished in this code are:
<ul class="org-ul">
<li>We have imported the <code>BasicSimulator</code> class</li>
<li>We have created <code>simulator_basic</code> as a <code>BasicSimulator</code> object.</li>
</ul></li>
</ul></li>
<li><p>
Build the circuit with two quantum bits and two classical bits
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 1</span>
qc.x(0).c_if(1,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1 </span>
qc.measure(0, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 0, record its result to classical bit 0</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>

<pre class="example">
/var/folders/88/d26ncvp97zg50164_cmmlyf511m8tn/T/babel-bmQJhU/python-AGP0D6:5: DeprecationWarning: The method ``qiskit.circuit.instructionset.InstructionSet.c_if()`` is deprecated as of qiskit 1.3.0. It will be removed in 2.0.0.
  qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1
</pre></li>
</ul></li>
</ul>



<div id="org9d10470" class="figure">
<p><img src="./img/QCwithMeas.png" alt="QCwithMeas.png" width="525px" />
</p>
<p><span class="figure-number">Figure 4: </span>This circuit has two qubits and two classical bits. The classical bits are required for measuremnt.</p>
</div>

<p>
In a Jupyter notebook, the output of <code>qc.draw()</code> will resemble Figure
<a href="#org9d10470">4</a>.
</p>
</div>
</div>
<div id="outline-container-orge374c09" class="outline-3">
<h3 id="orge374c09"><span class="section-number-3">3.2.</span> Simulating the Circuit</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
To run the circuit, we use the BasicSimulator.run() method, and we supply the
desired circuit, and we can specify the number of shots for our simulation:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">The .run() method performs the simulation, and and the run is</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">saved as job</span>
<span style="color: #DFAF8F;">job</span> = simulator_basic.run( qc, shots=1024 )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(job))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.providers.basic_provider.basic_provider_job.BasicProviderJob'&gt;
</pre>

<ul class="org-ul">
<li>This <code>run()</code> method returns a <code>BasicProviderJob</code> object
<ul class="org-ul">
<li>This has a <code>result()</code> method that returns a <code>Result()</code> object contains our
simulation results</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgd4ae4ae" class="outline-3">
<h3 id="orgd4ae4ae"><span class="section-number-3">3.3.</span> Getting the Results</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li><p>
We save the results as <code>results</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results</span> = job.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(results))

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.result.result.Result'&gt;
Result(backend_name='basic_simulator', backend_version='0.1', qobj_id='5fa46fbe-251b-4733-b29c-6cd05bb52024', job_id='5abb07aa-3a06-4ff7-94e5-a27a9e678d07', success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 519, '0x3': 505}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['c', 0], ['c', 1]], memory_slots=2, creg_sizes=[['c', 2]], name='circuit-160', global_phase=0.0, metadata={}), status=DONE, name='circuit-160', seed_simulator=np.int32(1719395928), time_taken=0.07600593566894531)], date=None, status=COMPLETED, header=QobjHeader(backend_name='basic_simulator', backend_version='0.1'), time_taken=0.0760350227355957)
</pre></li>

<li>The results object has lots of information about our quantum experiment
simulation</li>
</ul>
</div>

<div id="outline-container-orgfe54b61" class="outline-4">
<h4 id="orgfe54b61"><span class="section-number-4">3.3.1.</span> Simulation Counts</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li><p>
A <code>get_counts()</code> method helps us retrieve the outcomes and their frequencies.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = results.get_counts()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)
</pre>
</div>

<pre class="example">
{'00': 519, '11': 505}
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org249bb15" class="outline-4">
<h4 id="org249bb15"><span class="section-number-4">3.3.2.</span> Visualizing the Results</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>We can plot the measurement results in two ways:
<ul class="org-ul">
<li>as a histogram (counts) using <code>plot_histogram()</code>, or</li>
<li>as a probability distribution using <code>plot_distribution()</code>.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

display( plot_distribution( counts ) )

display( plot_histogram( counts ) )
</pre>
</div>


<div id="org2ef60c2" class="figure">
<p><img src="./img/basicSimHist.png" alt="basicSimHist.png" width="600px" />
</p>
<p><span class="figure-number">Figure 5: </span>A histogram from the results of a <code>BasicSimulator.run()</code> simulation.</p>
</div>


<div id="orgf838447" class="figure">
<p><img src="./img/basicSimPD.png" alt="basicSimPD.png" width="600px" />
</p>
<p><span class="figure-number">Figure 6: </span>A quasi-probability distribution from the results of a <code>BasicSimulator.run()</code> simulation. Quasiprobabilities are not actual probabilities, but rather estimates of probabilites obtained by dividing the number of occurrences of an event by the total number of experiments (shots).</p>
</div>
</div>
</div>

<div id="outline-container-org19a6711" class="outline-4">
<h4 id="org19a6711"><span class="section-number-4">3.3.3.</span> Inspecting Results from Individual Measurements</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>We can see the results of individual measurements if we use the <code>get_memory()</code> method for a <code>Results</code> object
<ul class="org-ul">
<li>This requires using the <code>memory</code> keyword with a value of <code>True</code> in the
<code>run()</code> method for our basic simulator</li>
</ul></li>
<li>Here, we do this with a fewer number of shots so that we can avoid
overwhelming ourselves with numerous results</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">small_job</span> = simulator_basic.run( qc, shots=8, memory=<span style="color: #BFEBBF;">True</span>)
<span style="color: #DFAF8F;">small_result</span> = small_job.result()
<span style="color: #DFAF8F;">samples</span> = small_result.get_memory()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)
</pre>
</div>

<pre class="example">
['00', '00', '00', '00', '11', '11', '11', '00']
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfaf2670" class="outline-3">
<h3 id="orgfaf2670"><span class="section-number-3">3.4.</span> Handling Complex Circuits</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>The basic simulator cannot handle more complex circuits readily, such as the QFT circuit</li>
<li>To handle complex circuits, we must first transpile our circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit.library <span style="color: #F0DFAF; font-weight: bold;">import</span> QFT

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(3, 3) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">3 qubits, 3 classical bits</span>
qc.append( QFT(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )
qc.measure( <span style="color: #DCDCCC; font-weight: bold;">range</span>(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )

qc.draw()
</pre>
</div>


<div id="org24852bd" class="figure">
<p><img src="./img/BasicSimQFT.png" alt="BasicSimQFT.png" width="480px" />
</p>
<p><span class="figure-number">Figure 7: </span>This is a more complex circuit including a QFT. <code>BasicSimulator</code> cannot handle this unless we first transpile it.</p>
</div>
</div>

<div id="outline-container-orgee3e0c4" class="outline-4">
<h4 id="orgee3e0c4"><span class="section-number-4">3.4.1.</span> Transpilation</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>Circuits may be composed of gates of various types</li>
<li>Some gates may not exist natively on a particular quantum processing unit
(QPU), but may be implemented using the available gates on the QPU
<ul class="org-ul">
<li>The set of available gates is often called the instruction set architecture
(ISA)</li>
</ul></li>
<li>To transpile a circuit is to represent it in the ISA of a particular machine</li>
<li>In this case, we transpile the QFT into gates available within the
<code>BasicSimulator</code> class.</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>This code transpiles the circuit of Figure <a href="#org24852bd">7</a></label><pre class="src src-python" id="orgff7af16"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile

<span style="color: #DFAF8F;">qc_trans</span> = transpile( qc, backend=simulator_basic)

qc_trans.draw()

</pre>
</div>

<p>
Jupyter output for Listing will resemble Figure <a href="#org42ca46e">8</a>
</p>

<div id="org42ca46e" class="figure">
<p><img src="./img/BasicSimQFTtrans.png" alt="BasicSimQFTtrans.png" width="640px" />
</p>
<p><span class="figure-number">Figure 8: </span>This is a transpiled version of the circuit from Figure <a href="#org24852bd">7</a></p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgefdab82" class="outline-3">
<h3 id="orgefdab82"><span class="section-number-3">3.5.</span> Conclusion</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>The <code>BasicSimulator()</code> class is useful when we simulate a job where we need to
find counts or samples of a circuit with mid-circuit measurements</li>
<li>The <code>BasicSimulator()</code> class should not be used for:
<ul class="org-ul">
<li>large circuits with many qubits or many gates</li>
<li>circuits where a coherent state is desired (state vector or density matrix)</li>
<li>noisy simulations</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec:QiskitAerSimulator" class="outline-2">
<h2 id="sec:QiskitAerSimulator"><span class="section-number-2">4.</span> The <code>qiskit_aer.AerSimulator</code> Class</h2>
<div class="outline-text-2" id="text-sec:QiskitAerSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-orgf390261" class="outline-3">
<h3 id="orgf390261"><span class="section-number-3">4.1.</span> Overview</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>The Qiskit Aer AerSimulator class can be used to simulate complex circuits with mid-circuit measurements</li>
<li>We can obtain unitary results from these simulations.</li>
<li>Qiskit Aer supports both noise-free and noisy simulations</li>
<li>The Qiskit <code>AerSimulator</code> class has a <code>run()</code> method that is simple and
straightforward to use; however, its syntax is notably different from the
tools used to launch calculations on actual quantum hardware (quantum
processing units).</li>
<li>The <code>qiskit_ibm_runtime</code> package provides interfaces called <b>primitives</b> to
run jobs on QPUs. These primitives include:
<ul class="org-ul">
<li><code>SamplerV2</code> for obtaining counts for an ensemble of measurements on a circuit</li>
<li><code>EstimatorV2</code> for obtaining expectation values from the output of a circuit</li>
</ul></li>
<li>To simulate circuits in a way as closely as possible to the
<code>qiskit_ibm_runtime</code> primitives, <code>qiskit_aer</code> also provides <code>SamplerV2</code> and
<code>EstimatorV2</code> primitives
<ul class="org-ul">
<li>The <code>qiskit_aer</code> primitives are designed for similarity with
the <code>qiskit_ibm_runtime</code> primitives</li>
</ul></li>
<li>In summary:
<ul class="org-ul">
<li><code>qiskit_aer.AerSimulator</code> has a <code>run()</code> method for simulating quantum circuits
<ul class="org-ul">
<li>This is notably different from primitives used to run jobs on quantum hardware</li>
</ul></li>
<li><code>qiskit_aer.primitives</code> has <code>SamplerV2</code> and <code>EstimatorV2</code> classes, which may
be used to simulate circuits in a way very similar to the primitives used
for running jobs on QPUs using <code>qiskit_ibm_runtime</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgd645417" class="outline-3">
<h3 id="orgd645417"><span class="section-number-3">4.2.</span> Imports</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>We begin by importing the required packages
<ul class="org-ul">
<li>This introduces the <code>qiskit_aer</code> package and the <code>AerSimulator</code> class</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit <span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">, transpile</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit.quantum_info import Statevector</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit.providers.basic_provider import BasicSimulator</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit_aer import AerSimulator</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator_basic = BasicSimulator()</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator_aer = AerSimulator()</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'test'</span>)
</pre>
</div>

<pre class="example">
test
</pre>
</div>
</div>


<div id="outline-container-org6f3a5d3" class="outline-3">
<h3 id="org6f3a5d3"><span class="section-number-3">4.3.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><p>
We define a circuit in Listing <a href="#org6fb1d29">1</a>
</p>
<div class="org-src-container">
<pre class="src src-python" id="orgd339078"><span style="color: #F0DFAF; font-weight: bold;">import</span> qiskit
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 0</span>
qc.h(0).c_if(0,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1</span>
qc.save_statevector()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(qiskit.__version__)
</pre>
</div>

<pre class="example">
1.3.1
</pre></li>
</ul>




<div id="org641428a" class="figure">
<p><img src="./img/CktAerSim.png" alt="CktAerSim.png" width="480px" />
</p>
<p><span class="figure-number">Figure 9: </span>This is a two-qubit circuit with a measurement in the middle of the circuit.</p>
</div>

<ul class="org-ul">
<li>Here, the <code>save_statevector()</code> method defines a point in the circuit at
which we wish to knkow the state vector</li>
</ul>
</div>
</div>
<div id="outline-container-org812ee26" class="outline-3">
<h3 id="org812ee26"><span class="section-number-3">4.4.</span> Run the <code>AerSimulator()</code></h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><p>
We first transpile the circuit so it is suitable for our simulator, and then we run it:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968; <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">show the state vector in Jupyter Lab</span>
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle
\end{equation}</li>
</ul>
</div>
</div>
<div id="outline-container-org18af62b" class="outline-3">
<h3 id="org18af62b"><span class="section-number-3">4.5.</span> Example 2: Circuit with Statevector in Middle of Circuit</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li><p>
Now, we provide an example where the state vector is saved from a point prior to the end of the circuit.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(4)
qc.h(3)
qc.cx(3,2)
qc.save_statevector()
qc.cx(3,1)
qc.cx(3,0)
qc.measure_all()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="orgc601a4e" class="figure">
<p><img src="./img/AerSimMultiStatevectCkt.png" alt="AerSimMultiStatevectCkt.png" width="640px" />
</p>
<p><span class="figure-number">Figure 10: </span>This circuit saves a <code>Statevector</code> in the middle of the calculation and just prior to measurement.</p>
</div></li>
</ul>
</div>

<div id="outline-container-orgb9df1e0" class="outline-4">
<h4 id="orgb9df1e0"><span class="section-number-4">4.5.1.</span> Transpile and Run the Circuit</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li><p>
Next, we transpile and run the circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968;
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle
\end{equation}</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdd988ff" class="outline-3">
<h3 id="orgdd988ff"><span class="section-number-3">4.6.</span> Efficient Simulation</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>Portions of the <code>AerSimulator</code> code are compiled to <code>C</code>
<ul class="org-ul">
<li>This allows faster and more efficient simulations, which enables simulations
of larger and more complex circuits.</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orga0ce8a7" class="outline-4">
<h4 id="orga0ce8a7"><span class="section-number-4">4.6.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-6-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 24
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-org108acbf" class="outline-4">
<h4 id="org108acbf"><span class="section-number-4">4.6.2.</span> Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></h4>
<div class="outline-text-4" id="text-4-6-2">
</div>
<ol class="org-ol">
<li><a id="orga69d678"></a>BasicSimulator<br />
<div class="outline-text-5" id="text-4-6-2-1">
<ul class="org-ul">
<li>In the following code, I simulate and time the circuit</li>
<li>In Jupyter Lab, the time to run a cell can be obtained by adding <code>%%time</code> at
the top of the cell.</li>
<li>These notes are not written in Jupyter Lab, so I use the <code>time</code> module
<ul class="org-ul">
<li>Key instructions:
<ul class="org-ul">
<li><code>import time</code> to access the module</li>
<li>Use <code>time.time()</code> to get the current time</li>
<li>The difference between two <code>time</code> objects can be used to calculate a time
interval in seconds</li>
</ul></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> time
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_basic.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_basic_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_basic_sim ))
</pre>
</div>

<pre class="example">
{'000000000000000000000000': 531, '111111111111111111111111': 493}
Time elapsed: 17.700 s
</pre>
</div>
</li>

<li><a id="org9754f05"></a><code>AerSimulator</code><br />
<div class="outline-text-5" id="text-4-6-2-2">
<ul class="org-ul">
<li>We now run and time the same circuit using the <code>AerSimulator</code>, and we see it
is much faster for larger circuits</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'111111111111111111111111': 537, '000000000000000000000000': 487}
Time elapsed:  0.025 s
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org576752c" class="outline-3">
<h3 id="org576752c"><span class="section-number-3">4.7.</span> Simulation Methods</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>Qiskit Aer supports different types of simulation, accessible through the
<code>method</code> keyword argument to the <code>run()</code> command.
<ul class="org-ul">
<li>The default is <code>method</code>'statevector'=
<ul class="org-ul">
<li>The limit here is 24 qubits</li>
</ul></li>
<li>Other methods include <code>'matrix_product_state'</code></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb041ddf" class="outline-4">
<h4 id="orgb041ddf"><span class="section-number-4">4.7.1.</span> Build a Large Circuit</h4>
<div class="outline-text-4" id="text-4-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 50
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-orgf669c01" class="outline-4">
<h4 id="orgf669c01"><span class="section-number-4">4.7.2.</span> Run and Time the Simulation</h4>
<div class="outline-text-4" id="text-4-7-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024, method=<span style="color: #CC9393;">'matrix_product_state'</span> ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'11111111111111111111111111111111111111111111111111': 492, '00000000000000000000000000000000000000000000000000': 532}
Time elapsed:  0.081 s
</pre>
</div>
</div>
</div>

<div id="outline-container-org2d6a14d" class="outline-3">
<h3 id="org2d6a14d"><span class="section-number-3">4.8.</span> Noisy Simulation</h3>
<div class="outline-text-3" id="text-4-8">
</div>
<div id="outline-container-org183666a" class="outline-4">
<h4 id="org183666a"><span class="section-number-4">4.8.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-8-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0])

qc.draw()
</pre>
</div>


<div id="org660ba79" class="figure">
<p><img src="./img/noisyCktExample.png" alt="noisyCktExample.png" width="480px" />
</p>
<p><span class="figure-number">Figure 11: </span>This is a small circuit for noisy simulation using the <code>AerSimulator</code>.</p>
</div>
</div>
</div>

<div id="outline-container-org4127856" class="outline-4">
<h4 id="org4127856"><span class="section-number-4">4.8.2.</span> Ideal Result</h4>
<div class="outline-text-4" id="text-4-8-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This will throw an error for n &gt; 25 using method='statevector'</span>
<span style="color: #DFAF8F;">qc_aer</span> = transpile( qc, backend=simulator_aer )
<span style="color: #DFAF8F;">result_ideal</span> = simulator_aer.run( qc_aer, shots=1024 ).result()
<span style="color: #DFAF8F;">counts_ideal</span> = result_ideal.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_ideal)
</pre>
</div>

<pre class="example">
{'11': 520, '00': 504}
</pre>
</div>
</div>

<div id="outline-container-org67ab38f" class="outline-4">
<h4 id="org67ab38f"><span class="section-number-4">4.8.3.</span> Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> noise

<span style="color: #DFAF8F;">prob</span> = 0.1
<span style="color: #DFAF8F;">error</span> = noise.depolarizing_error( prob, 2 )

<span style="color: #DFAF8F;">noise_model</span> = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error( error, [<span style="color: #CC9393;">'cx'</span>])
<span style="color: #DFAF8F;">basis_gates</span> = noise_model.basis_gates

<span style="color: #DFAF8F;">result_noisy</span> = simulator_aer.run(qc,
                                shots=1024,
                                noise_model=noise_model,
                                basis_gates=basis_gates).result()

<span style="color: #DFAF8F;">counts_noisy</span> = result_noisy.get_counts()
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc17b8e1" class="outline-4">
<h4 id="orgc17b8e1"><span class="section-number-4">4.8.4.</span> Compare Ideal Result and Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment this to see the compared distributions</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )</span>
</pre>
</div>


<div id="orgfc7c042" class="figure">
<p><img src="./img/AerSimIdealvsNoisy.png" alt="AerSimIdealvsNoisy.png" width="640px" />
</p>
<p><span class="figure-number">Figure 12: </span>An ideal <code>AerSimulator</code> result is compared to a noisy result.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga97c068" class="outline-3">
<h3 id="orga97c068"><span class="section-number-3">4.9.</span> Summary</h3>
<div class="outline-text-3" id="text-4-9">
<p>
The <code>AerSimulator()</code> is useful when we want to:
</p>
<ol class="org-ol">
<li>Find counts/samples of large circuits (simulators are efficient)</li>
<li>Find state vector/density matrix of circuits with measurements</li>
<li>Simulate circuits with noise</li>
</ol>

<p>
The AerSimulator() results do not match the output format of Qiskit IBM runtime
(the quantum hardware).
</p>

<p>
Qiskit Aer has its own sampler/estimator, which provide a closer match to the
inputs and outputs of the hardware, but these are being deprecated.
</p>

<p>
In the next section, we explore <a href="https://docs.quantum.ibm.com/api/qiskit/primitives">primitives</a>, which are used
in Qiskit IBM runtime.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc4a64dd" class="outline-2">
<h2 id="orgc4a64dd"><span class="section-number-2">5.</span> Qiskit Primitives</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgd5d2905" class="outline-3">
<h3 id="orgd5d2905"><span class="section-number-3">5.1.</span> Overview</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>The interface for the various simulators (BasicSimulator, AerSimulator) were
identical to the Qiskit IBM Provider interface to the quantum hardware</li>
<li>The backend was an abstraction for something that was either simulator or an
actual quantum processor.</li>
<li>Primitives abstract the interface between users and backends</li>
<li>There are two available primitives:
<ul class="org-ul">
<li>Sampler - this samples the output state of a circuit</li>
<li>Estimator - this stimates expectation values of a state with respect to
observables</li>
</ul></li>
<li>Qiskit, Qiskit Aer, and Qiskit IBM Runtime each provide different primitives.</li>
<li>Diego recommends starting with the version 2 primitives, which are compatible
with the current hardware:</li>

<li>Qiskit
<ul class="org-ul">
<li>StatevectorSampler</li>
<li>StatevectorEstimator</li>
</ul></li>
<li><code>qiskit_aer</code>
<ul class="org-ul">
<li><code>primitives.SamplerV2</code></li>
<li><code>primitives.EstimatorV2</code></li>
</ul></li>
<li><code>qiskit_ibm_runtime</code>
<ul class="org-ul">
<li><code>SamplerV2</code></li>
<li><code>EstimatorV2</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgd630c47" class="outline-3">
<h3 id="orgd630c47"><span class="section-number-3">5.2.</span> Primitives</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Qiskit primitives are computational building blocks used in larger applications that require quantum resources to efficiently produce outputs. The inputs to a primitive consists of primitive unified blocs (PUBs).
</p>

<p>
There are two types of primitives:
</p>
<ol class="org-ol">
<li><code>EstimatorV2</code></li>
<li><code>SamplerV2</code></li>
</ol>

<p>
The workflow is as before: build a circuit, and then simulate it (or run it on
hardware).
</p>
</div>

<div id="outline-container-org88941df" class="outline-4">
<h4 id="org88941df"><span class="section-number-4">5.2.1.</span> Imports</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorSampler, StatevectorEstimator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'imports complete'</span>) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">it's sometimes desirable to check job completion</span>
</pre>
</div>

<pre class="example">
imports complete
</pre>
</div>
</div>

<div id="outline-container-org8dea888" class="outline-4">
<h4 id="org8dea888"><span class="section-number-4">5.2.2.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2, 2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measurement register: c</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org2b62a06" class="figure">
<p><img src="./img/qisprimckt01.png" alt="qisprimckt01.png" width="480px" />
</p>
<p><span class="figure-number">Figure 13: </span>This is a circuit for use with the <code>qiskit</code> primitives.</p>
</div>
</div>
</div>

<div id="outline-container-orge1433b1" class="outline-4">
<h4 id="orge1433b1"><span class="section-number-4">5.2.3.</span> Run Simulations</h4>
<div class="outline-text-4" id="text-5-2-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">simulator</span> = BasicSimulator()
<span style="color: #DFAF8F;">sampler</span> = StatevectorSampler()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org06c4d84"></a>Basic Simulation<br />
<div class="outline-text-5" id="text-5-2-3-1">
<p>
This simulates the circuit using ~qiskit.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">No transpilation is needed for this simple circuit</span>
<span style="color: #DFAF8F;">job_simulator</span> = simulator.run( qc, shots=1024)
</pre>
</div>
</div>
</li>

<li><a id="org425d49a"></a>Simulation using a Sampler<br />
<div class="outline-text-5" id="text-5-2-3-2">
<ul class="org-ul">
<li>The syntax for a sampler simulation is somewhat different than that of the
<code>BasicSimulator</code> class.
<ul class="org-ul">
<li>Here, inputs are in the form of primitive-unified blocs (PUBS)</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_sampler</span> = sampler.run( [qc], shots=1024)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org65bf87f" class="outline-4">
<h4 id="org65bf87f"><span class="section-number-4">5.2.4.</span> Extracting Results</h4>
<div class="outline-text-4" id="text-5-2-4">
<ul class="org-ul">
<li>We extract results in the same way from both the simulator and the sampler:</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_simulator</span> = job_simulator.result()
<span style="color: #DFAF8F;">result_sampler</span> = job_sampler.result()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org837a61b"></a>Simulator Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-1">
<ul class="org-ul">
<li><p>
We can retrieve counts from the simulator result as before, using the
<code>get_counts()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = result_simulator.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>( counts_simulator )
</pre>
</div>

<pre class="example">
{'11': 522, '00': 502}
</pre></li>
</ul>
</div>
</li>


<li><a id="orgad2e9a2"></a>Sampler Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-2">
<ul class="org-ul">
<li><p>
Getting counts from the sampler is a bit more involved. Let's eamine the
results we obtained:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(result_sampler))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_sampler)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
PrimitiveResult([SamplerPubResult(data=DataBin(c=BitArray(&lt;shape=(), num_shots=1024, num_bits=2&gt;)), metadata={'shots': 1024, 'circuit_metadata': {}})], metadata={'version': 2})
</pre>


<ul class="org-ul">
<li>The results from the sampler come as an object of class <code>PubResult</code>
object.
<ul class="org-ul">
<li>This class has a <code>get_counts()</code> method.</li>
<li>Since the input PUB for the sampler is a list, we must similarly index the
result to get the result(s)  for a specific PUB item.</li>
<li>If we don't provide an index, get<sub>counts</sub>() will
aggregate the results, which may not be what we want.</li>
</ul></li>
</ul></li>
<li>To get counts, we do the following:</li>
<li>index the PUB result. Here, we call for the zeroth element.</li>
<li>reference the data member data element, and reference the classical register name.</li>
<li><p>
use the <code>get_counts()</code> method.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[0].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 504, '00': 520}
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org357d5e3" class="outline-3">
<h3 id="org357d5e3"><span class="section-number-3">5.3.</span> Example: A Parametrized Circuit</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter
<span style="color: #F0DFAF; font-weight: bold;">from</span> math <span style="color: #F0DFAF; font-weight: bold;">import</span> pi

<span style="color: #DFAF8F;">&#952;</span> = Parameter(<span style="color: #CC9393;">'&#952;'</span>)

<span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">assign a parameter for this rotation</span>
qc2.cx(1, 0)
qc2.measure_all()
qc2.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org68bcfe2" class="figure">
<p><img src="./img/prametrizedckt.png" alt="prametrizedckt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 14: </span>This circuit has a parameter θ.</p>
</div>
</div>


<div id="outline-container-org07ddd63" class="outline-4">
<h4 id="org07ddd63"><span class="section-number-4">5.3.1.</span> <code>BasicSimulator</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Here, we make a list of circuits, each with a specific value of the parameter θ.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">angles</span> = [[pi/4], [pi/3], [pi/2]]

<span style="color: #DFAF8F;">circuits</span> = []
<span style="color: #F0DFAF; font-weight: bold;">for</span> angle <span style="color: #F0DFAF; font-weight: bold;">in</span> angles:
    <span style="color: #DFAF8F;">qc_temp</span> = qc2.assign_parameters({&#952;:angle[0]})
    circuits.append(qc_temp)
</pre>
</div>

<p>
We can draw the different circuits by indexing the list:
</p>
<div class="org-src-container">
<pre class="src src-python">circuits[1].draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="orga63186f" class="figure">
<p><img src="./img/prametrizedckt_ex.png" alt="prametrizedckt_ex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 15: </span>We print a circuit from a list of circuits. Unlike the circuit of Fig. <a href="#org68bcfe2">14</a>, this circuit has a specific value for θ.</p>
</div>
</div>


<ol class="org-ol">
<li><a id="org89de564"></a>Transpiling and Running<br />
<div class="outline-text-5" id="text-5-3-1-1">
<ul class="org-ul">
<li>The entire list of circuits can be transpiled in a single call to <code>transpile()</code></li>
<li><p>
The transpiled list can be called using one call to the <code>BasicSimulator.run()</code>
method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">transpile the circuit list</span>
<span style="color: #DFAF8F;">circuits_t</span> = transpile( circuits, backend=simulator )

<span style="color: #DFAF8F;">result_simulator</span> = simulator.run( circuits_t, shots=1024 ).result()
</pre>
</div></li>
<li><p>
We provide an index to <code>get_counts()</code> for the corresponding circuit in
<code>circuits_t</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = []

<span style="color: #F0DFAF; font-weight: bold;">for</span> i, _ <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(angles):
    <span style="color: #DFAF8F;">result_temp</span> = result_simulator.get_counts(i)
    counts_simulator.append(result_temp)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_simulator)
</pre>
</div>

<pre class="example">
[{'00': 875, '11': 149}, {'00': 780, '11': 244}, {'11': 465, '00': 559}]
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org3eea180" class="outline-4">
<h4 id="org3eea180"><span class="section-number-4">5.3.2.</span> <code>StatevectorSampler</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>For a sampler, we pass a list of PUBs. This contains
<ul class="org-ul">
<li>the generic parametrized circuit, along with</li>
<li>the list of parameters</li>
</ul></li>
<li>This makes the <code>run()</code> command very simple.</li>
<li>To get the results, we index the <code>result_sampler</code>, i.e., <code>results_sampler[0]</code>
<ul class="org-ul">
<li>This indexes the zeroth (and only) PUB, with the flexibility to support multiple PUBs</li>
</ul></li>
<li>We iterate over the angles as before to get results for each angles</li>
</ul>
<div class="warning" id="org3142c5e">
<p>
Caution: if we simply use <code>result.sampler[0].data.meas.get_counts()</code>, this aggregates the counts by summing them. Often, this is not what we want. 
</p>

</div>
</div>
</div>


<div id="outline-container-orgb1f843b" class="outline-4">
<h4 id="orgb1f843b"><span class="section-number-4">5.3.3.</span> <code>StatevectorSampler</code> Usage with Multiple PUBs</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
We now pass two PUBs, each with a different circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0], [1,0])

qc.draw()
</pre>
</div>


<div id="orgf81fc82" class="figure">
<p><img src="./img/circuit_multiPUBex.png" alt="circuit_multiPUBex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 16: </span>A circuit for use in an example with multiple PUBs.</p>
</div>
</div>

<ol class="org-ol">
<li><a id="orgd408edc"></a>Run the Multi-Pub Basic Sampler<br />
<div class="outline-text-5" id="text-5-3-3-1">
<ul class="org-ul">
<li>Here, we run one job with two different PUBs, each with a different circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_sampler</span> = sampler.run([(qc2, angles), (qc, <span style="color: #BFEBBF;">None</span>)], shots=1024).result()
</pre>
</div>
</div>
</li>

<li><a id="orgbe965e4"></a>Retrieve Data for the Zeroth Circuit<br />
<div class="outline-text-5" id="text-5-3-3-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = [ result_sampler[0].data.meas.get_counts(k) <span style="color: #F0DFAF; font-weight: bold;">for</span> k <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
[{'00': 857, '11': 167}, {'00': 774, '11': 250}, {'00': 501, '11': 523}]
</pre>
</div>
</li>

<li><a id="org4368830"></a>Retrieve Data for the First Circuit<br />
<div class="outline-text-5" id="text-5-3-3-3">
<ul class="org-ul">
<li>Here, we have a non-parametrized circuit, so we don't need to provide an argument to <code>get_counts()</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[1].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 521, '00': 503}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgb0403bd" class="outline-3">
<h3 id="orgb0403bd"><span class="section-number-3">5.4.</span> The Estimator Primitive</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>The <code>StatevectorEstimator</code> primitive takes a PUB, but with a slightly different format from <code>BasicSampler</code>.</li>
<li>The circuits cannot have any measurement gates</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1)
qc2.cx(1, 0)

qc2.draw( reverse_bits = <span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org1207f89" class="figure">
<p><img src="./img/sample_ckt_for_Estimator.png" alt="sample_ckt_for_Estimator.png" width="480px" />
</p>
<p><span class="figure-number">Figure 17: </span>This circuit was built for use with an <code>Estimator</code> simulation. For this reason, we do not include measurement blocks.</p>
</div>
</div>

<div id="outline-container-org17811ac" class="outline-4">
<h4 id="org17811ac"><span class="section-number-4">5.4.1.</span> Observables</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>Since an estimator estimates expectation values \(\left\langle \psi |
  \mathbf{O} | \right\rangle\), we need an observable, \(\mathbf{O}\).</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This is a list of observables. I'm not sure why it's a list of lists.</span>
<span style="color: #DFAF8F;">obsv</span> = [ [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"IY"</span>], [0.5, 0.5] ) ],
         [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>], [1] ) ] ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv)
</pre>
</div>

<pre class="example">
[[SparsePauliOp(['XX', 'IY'],
              coeffs=[0.5+0.j, 0.5+0.j])], [SparsePauliOp(['XX'],
              coeffs=[1.+0.j])]]
</pre>
</div>
</div>

<div id="outline-container-orge5c17fd" class="outline-4">
<h4 id="orge5c17fd"><span class="section-number-4">5.4.2.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
<span style="color: #DFAF8F;">result_estimator</span> = estimator.run( [(qc2, obsv, angles, 0.1)] ).result()
</pre>
</div>
</div>
</div>

<div id="outline-container-org8030d97" class="outline-4">
<h4 id="org8030d97"><span class="section-number-4">5.4.3.</span> Extract Expectation Values</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
<li>(optional) we can see some metadata using the <code>.metadata</code> function</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Extract the expectation values (evs) from the result for PUB 0</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].data.evs)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].metadata)
</pre>
</div>

<pre class="example">
[[ 0.05985877  0.14030793  0.18762585]
 [ 0.10722808 -0.04870472  0.15934201]]
{'target_precision': 0.1, 'circuit_metadata': {}}
</pre>


<ul class="org-ul">
<li>This is a list of two observables, with one value for each of the input
parameters.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfc08b88" class="outline-3">
<h3 id="orgfc08b88"><span class="section-number-3">5.5.</span> Qiskit Estimator Example</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li><p>
This provides another example from a Qiskit documentation <a href="https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives">tutorial</a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">circuit for which you want to obtain the expected value</span>
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.ry(Parameter(<span style="color: #CC9393;">'theta'</span>), 0)
qc.h(0)
qc.cx(0,1)
qc.draw(<span style="color: #CC9393;">"mpl"</span>, style=<span style="color: #CC9393;">"iqp"</span>)
</pre>
</div>


<div id="org07b32d0" class="figure">
<p><img src="./img/EstimatorIBMExCkt.png" alt="EstimatorIBMExCkt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 18: </span>This is a simple circuit built for an IBM Quantum tutorial on using the <code>StatevectorEstimator</code>.</p>
</div></li>
</ul>
</div>

<div id="outline-container-org247942f" class="outline-4">
<h4 id="org247942f"><span class="section-number-4">5.5.1.</span> Build an Operator</h4>
<div class="outline-text-4" id="text-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">observable(s) whose expected values you want to compute</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #DFAF8F;">observable</span> = SparsePauliOp([<span style="color: #CC9393;">"II"</span>, <span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"YY"</span>, <span style="color: #CC9393;">"ZZ"</span>], coeffs=[1, 1, -1, 1])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">value(s) for the circuit parameter(s)</span>
<span style="color: #DFAF8F;">parameter_values</span> = [[0], [np.pi/6], [np.pi/2]]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(parameter_values)
</pre>
</div>

<pre class="example">
[[0], [0.5235987755982988], [1.5707963267948966]]
</pre>
</div>
</div>


<div id="outline-container-orgf016b33" class="outline-4">
<h4 id="orgf016b33"><span class="section-number-4">5.5.2.</span> Instantiate a <code>StatevectorEstimator</code></h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorEstimator
<span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb064307" class="outline-4">
<h4 id="orgb064307"><span class="section-number-4">5.5.3.</span> Transpile the Circuit</h4>
<div class="outline-text-4" id="text-5-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Generate a pass manager without providing a backend</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(optimization_level=1)
<span style="color: #DFAF8F;">isa_circuit</span> = pm.run(qc)
<span style="color: #DFAF8F;">isa_observable</span> = observable.apply_layout(isa_circuit.layout)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge4532c2" class="outline-4">
<h4 id="orge4532c2"><span class="section-number-4">5.5.4.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-5-4">
<ul class="org-ul">
<li>We form a PUB as an argument to the <code>StatevectorEstimator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job</span> = estimator.run([(isa_circuit, isa_observable, parameter_values)])
<span style="color: #DFAF8F;">result</span> = job.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Result class: </span>{<span style="color: #DCDCCC; font-weight: bold;">type</span>(result)}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
&gt; Result class: &lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
</pre>
</div>
</div>

<div id="outline-container-org407248f" class="outline-4">
<h4 id="org407248f"><span class="section-number-4">5.5.5.</span> Extract Results</h4>
<div class="outline-text-4" id="text-5-5-5">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the
following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(result)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">len</span>(result))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Expectation value: </span>{result[0].data.evs}<span style="color: #CC9393;">"</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Metadata: </span>{result[0].metadata}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), stds=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), shape=(3,)), metadata={'target_precision': 0.0, 'circuit_metadata': {}})], metadata={'version': 2})
1
 &gt; Expectation value: [4.         3.73205081 2.        ]
 &gt; Metadata: {'target_precision': 0.0, 'circuit_metadata': {}}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org34759c7" class="outline-2">
<h2 id="org34759c7"><span class="section-number-2">6.</span> <code>qiskit_aer</code> Primitives</h2>
<div class="outline-text-2" id="text-6">
<p>
We demonstrate the use of <code>qiskit_aer</code> primitives.
</p>
</div>

<div id="outline-container-org501b305" class="outline-3">
<h3 id="org501b305"><span class="section-number-3">6.1.</span> Example: Bell Circuits and the <code>SamplerV2</code> Class</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Bell circuits are used to create entangled pairs of qubits. We will simulate two
of the four Bell circuits using the <code>SamplerV2</code> class provided in
<code>qiskit_aer.primitives</code>.
</p>
</div>

<div id="outline-container-org36d4d8a" class="outline-4">
<h4 id="org36d4d8a"><span class="section-number-4">6.1.1.</span> Imports</h4>
<div class="outline-text-4" id="text-6-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2

<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Optional</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Imports complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Imports complete at 2025-03-11 11:41:07.824550
</pre>


<div class="note" id="orgf18ca1b">
<p>
<b>Note</b>
</p>

<p>
If you are using Jupyter Lab, you need not use <code>dateime</code> and <code>print()</code> to
indicate completion.
</p>

<p>
Here, I'm using <code>datetime</code> and <code>print()</code> because I'm developing these notes in
Emacs org mode. Here, Python code blocks in session mode often do not indicate
errors, and completion messages help me know the code block has executed
properly.
</p>

</div>
</div>
</div>

<div id="outline-container-orgcad7625" class="outline-4">
<h4 id="orgcad7625"><span class="section-number-4">6.1.2.</span> Bell Circuits</h4>
<div class="outline-text-4" id="text-6-1-2">
</div>
<ol class="org-ol">
<li><a id="org0eb1f92"></a>First Case<br />
<div class="outline-text-5" id="text-6-1-2-1">
<p>
Not only must we form a Bell circuit, but we must also add measurement
gates. The measurement gates are required if we wish to obtain circuit counts.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">Bell00</span> = QuantumCircuit(2)
Bell00.h(0)
Bell00.cx(0,1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure_all() adds a classical register named "meas"</span>
Bell00.measure_all()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(Bell00)
</pre>
</div>

<pre class="example">
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
</pre>




<div id="org4aead68" class="figure">
<p><img src="./img/Bell00ckt.png" alt="Bell00ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 19: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 00 \right\rangle + \left|11  \right\rangle \right)/\sqrt{2} \).</p>
</div>
</div>
</li>

<li><a id="orga05353d"></a>A Second Circuit<br />
<div class="outline-text-5" id="text-6-1-2-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">Bell01</span> = QuantumCircuit(2)
Bell01.h(0)
Bell01.x(1)
Bell01.cx(0,1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure_all() adds a classical register named "meas"</span>
Bell01.measure_all()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(Bell01)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 11:41:33.493997
</pre>




<div id="org6503698" class="figure">
<p><img src="./img/Bell01ckt.png" alt="Bell01ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 20: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 01 \right\rangle + \left|10  \right\rangle \right)/\sqrt{2} \).</p>
</div>
</div>
</li>



<li><a id="orgb8d637f"></a>Join Circuits into a List<br />
<div class="outline-text-5" id="text-6-1-2-3">
<p>
Now, we form a list of circuits.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Form a list of Bell circuits</span>
<span style="color: #DFAF8F;">BellCkts</span> = [Bell00, Bell01]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 11:37:43.001165
</pre>
</div>
</li>
</ol>
</div>

<div id="outline-container-org4502ed1" class="outline-4">
<h4 id="org4502ed1"><span class="section-number-4">6.1.3.</span> Transpilation</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
We can now transpile our list of circuits. To <b>transpile</b> a circuit is to form
an equivalent circuit using a set of gates (instruction set architecture, or
ISA) that is supported on a specific quantum processing unit (QPU).
</p>

<p>
To transpile, we tools called <code>pass_managers</code>. <code>qiskit</code> has some preset pass
managers, which make it more convenient.
</p>

<p>
One other piece of information we must provide is the target backend. The target
backend could be an <code>AerSimulator()</code>, a local model of a QPU (<code>FakeBackend</code>), or
an actual QPU. Different resources may have different ISAs, so it is important
to specify your transpilation target.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> sys
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">create a backend</span>
<span style="color: #DFAF8F;">backend_aer</span> = AerSimulator()

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Specify the target backend for transpilation</span>
<span style="color: #DFAF8F;">target_aer</span> = backend_aer.target

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Create a pass manager object to perform the transpilation</span>
<span style="color: #DFAF8F;">pm_aer</span> = generate_preset_pass_manager(target=target_aer, optimization_level=1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Want to know more about the pass manager? Start printing things about it.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'Class of pm_aer: {type(pm_aer)}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer: {pm_aer}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer attributes: {pm_aer.__dict__}')</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 11:43:31.984413
</pre>



<p>
Next, we can transpile our circuits for the desired backend:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">BellCkts_aer</span> = pm_aer.run( BellCkts ) 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Code block complete at 2025-03-11 11:45:38.043943
</pre>


<p>
We may wish to compare our transpiled circuit to our original circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx, ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(BellCkts):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'='</span>*70 + f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">idx = </span>{idx}<span style="color: #CC9393;">'</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Original'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(ckt)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Transpiled'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(BellCkts_aer[idx])      

</pre>
</div>

<pre class="example" id="org57c9aa3">
======================================================================
idx = 0
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
======================================================================
idx = 1
Original
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
Transpiled
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
</pre>

<p>
In this case, both the original circuit and the transpiled circuit are the
same. When we try to use a <code>FakeBackend</code> or a real QPU, however, the transpiled
circuit may look quite different from the origial circuit you designed.
</p>
</div>
</div>

<div id="outline-container-org6cc0665" class="outline-4">
<h4 id="org6cc0665"><span class="section-number-4">6.1.4.</span> Forming PUBs</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
Now that we have transpiled circuits that we can run on a simulator&#x2013;or, if
transpiled properly, on actual hardware&#x2013;we can form a list of PUBs as a batch
of subtasks forming a job. A PUB is a "primitive unified bloc." Each PUB is a
tuple containing a circuit and circuit parameters, as in <code>(circ, params)</code>. Here,
the circuits we are dealing with are simple and do not require parameters. Thus,
they are said to be non-parameterized circuits, and we use <code>None</code> for <code>params</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">PUBs_aer</span> = [ (ckt, <span style="color: #BFEBBF;">None</span>) <span style="color: #F0DFAF; font-weight: bold;">for</span> ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> BellCkts_aer ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a list of PUBs for the Aer SamplerV2 at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Your list of PUBs contains </span>{<span style="color: #DCDCCC; font-weight: bold;">len</span>(PUBs_aer)}<span style="color: #CC9393;"> PUBs.'</span>)
</pre>
</div>

<pre class="example">
Created a list of PUBs for the Aer SamplerV2 at 2025-03-11 11:45:59.322433
Your list of PUBs contains 2 PUBs.
</pre>
</div>
</div>

<div id="outline-container-orgc076166" class="outline-4">
<h4 id="orgc076166"><span class="section-number-4">6.1.5.</span> Simulating the Circuits</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
Here, we will use <code>qiskit_aer.primitives.SamplerV2()</code> as our simulation
platform. First, we instantiate a <code>SamplerV2</code> object. Note: we import
`qiskit<sub>aer.primitives.SamplerV2</sub>~ as <code>Sampler</code> to distinguish it from the
<code>qiskit_ibm_runtime.SamplerV2</code> which we will use later.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Instantiate a sampler</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2 <span style="color: #F0DFAF; font-weight: bold;">as</span> Sampler

<span style="color: #DFAF8F;">sampler_aer</span> = Sampler() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for simulator, no arguments</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Run the `SamplerV2` simulation</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a SamplerV2 at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)

</pre>
</div>

<pre class="example">
Created a SamplerV2 at 2025-03-11 11:46:33.385617
</pre>


<p>
Finally, we use the <code>run()</code> method of our sampler. We will specify a shot count
of 4096, since we may wish to compare with results from actual hardware using a
<code>qiskit_ibm_runtime.SamplerV2</code> object. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Instantiate a sampler</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2 <span style="color: #F0DFAF; font-weight: bold;">as</span> Sampler

<span style="color: #DFAF8F;">job_sim</span> = sampler_aer.run( PUBs_aer, shots=4092 ) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulated job with 4092 shots</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Run the `SamplerV2` simulation</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Simulated the SamplerV2 at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)

</pre>
</div>

<pre class="example">
Simulated the SamplerV2 at 2025-03-11 11:46:43.562745
</pre>
</div>
</div>

<div id="outline-container-org1ff91eb" class="outline-4">
<h4 id="org1ff91eb"><span class="section-number-4">6.1.6.</span> Accessing Results</h4>
<div class="outline-text-4" id="text-6-1-6">
<p>
We can extract results from our job using its <code>.result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results_sim</span> = job_sim.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results_sim)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'shots': 4092, 'circuit_metadata': {}, 'simulator_metadata': {'time_taken_parameter_binding': 0.000403083, 'max_memory_mb': 36864, 'time_taken_execute': 0.018819333, 'omp_enabled': True, 'max_gpu_memory_mb': 0, 'parallel_experiments': 1}}), SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'shots': 4092, 'circuit_metadata': {}, 'simulator_metadata': {'time_taken_parameter_binding': 0.000403083, 'max_memory_mb': 36864, 'time_taken_execute': 0.018819333, 'omp_enabled': True, 'max_gpu_memory_mb': 0, 'parallel_experiments': 1}})], metadata={'version': 2})
</pre>


<p>
Since the list of PUBs contained two PUBs, our job has two results embedded in
it. We access them using an index, as in <code>job_sim[0]</code> and
<code>job_sim[1]</code>. Furthermore, to extract counts, we use the <code>.data</code> property for
each PUB result. We also must specify the name of the classical register on
which measurement results are stored. In this case, we used <code>.measure_all()</code> to
add measurement gates, so this creates a classical register named
<code>meas</code>. Finally, for our classical register, we use the <code>get_counts()</code> method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(results_sim[idx].data.meas.get_counts())
</pre>
</div>

<pre class="example">
{'00': 2081, '11': 2011}
{'10': 2095, '01': 1997}
</pre>


<p>
Indeed, we can print our results, but it is much nicer to plot them using a
histogram.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram

<span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Bell circuit </span>{idx}<span style="color: #CC9393;">'</span>)
    display(plot_histogram(results_sim[idx].data.meas.get_counts()))
</pre>
</div>

<p>
A histgoram for the results of Bell circuit 0 are shown here:
</p>

<div id="org869290e" class="figure">
<p><img src="./img/bell_ckt_results00.png" alt="bell_ckt_results00.png" width="480px" />
</p>
<p><span class="figure-number">Figure 21: </span>The measured  result is consistent with Bell circuit 0, which produces \(\left(\left|00 \right\rangle + \left|11 \right\rangle\right)/\sqrt{2}\).</p>
</div>


<p>
A similar histogram for measurements on Bell circuit 1 are shown here:
</p>

<div id="org5ca52fa" class="figure">
<p><img src="./img/bell_ckt_results01.png" alt="bell_ckt_results01.png" width="480px" />
</p>
<p><span class="figure-number">Figure 22: </span>The measured  result is consistent with Bell circuit 0, which produces \(\left(\left|01 \right\rangle + \left|10 \right\rangle\right)/\sqrt{2}\).</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2ec6670" class="outline-3">
<h3 id="org2ec6670"><span class="section-number-3">6.2.</span> Summary</h3>
<div class="outline-text-3" id="text-6-2">
<p>
We have used a <code>qiskit_aer.primitives.SamplerV2</code> object to perform noise-free
simulations of quantum circuits.
</p>

<p>
A next step will be to perform similar computations on actual quantum hardware,
and then to compare the results.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb58bfcd" class="outline-2">
<h2 id="orgb58bfcd"><span class="section-number-2">7.</span> Bell Circuits on IBM Quantum Hardware</h2>
<div class="outline-text-2" id="text-7">
<p>
To run the same Bell circuits on IBM hardware, we require the
<code>qiskit_ibm_runtime</code> package. For an equivalent to our previous simulation of
Bell circuits, we will also use the <code>SamplerV2</code> class.
</p>
</div>

<div id="outline-container-org0b25907" class="outline-3">
<h3 id="org0b25907"><span class="section-number-3">7.1.</span> Imports</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Let's begin by importing some tools we need from <code>qiskit_ibm_runtime</code>. We will
import the <code>SamplerV2</code> for getting measurement counts on actual hardware, and
<code>QiskitRuntimeService</code> for making a connection to IBM Quantum.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2, QiskitRuntimeService

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 13:38:02.145513
</pre>
</div>
</div>

<div id="outline-container-org80f0b2a" class="outline-3">
<h3 id="org80f0b2a"><span class="section-number-3">7.2.</span> The Bell Circuits</h3>
<div class="outline-text-3" id="text-7-2">
<p>
We do not recreate the Bell circuits here, since we already have created them.
Instead, we show them here once again.
</p>


<div id="org53523db" class="figure">
<p><img src="./img/Bell00ckt.png" alt="Bell00ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 23: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 00 \right\rangle + \left|11  \right\rangle \right)/\sqrt{2} \).</p>
</div>


<div id="org3caa615" class="figure">
<p><img src="./img/Bell01ckt.png" alt="Bell01ckt.png" width="380px" />
</p>
<p><span class="figure-number">Figure 24: </span>This bell circuit produces the state \(\left|\Psi \right\rangle = \left( \left| 01 \right\rangle + \left|10  \right\rangle \right)/\sqrt{2} \).</p>
</div>
</div>
</div>

<div id="outline-container-org62d1818" class="outline-3">
<h3 id="org62d1818"><span class="section-number-3">7.3.</span> Transpilation</h3>
<div class="outline-text-3" id="text-7-3">
<p>
To transpile our circuits, we first require a backend, which is the target ISA
for the transpilation process. To obtain a backend, we must use our IBM Quantum
API token. To do this, you need to create an IBM Quantum account if you don't
already have one; and you need to find your IBM Quantum API token.
</p>

<p>
We will take the following steps:
</p>
<ol class="org-ol">
<li>Register for an IBM Quantum account if you don't already have one.</li>
<li>Find your IBM Quantum API token</li>
<li>Load your token in Python for programmatic access to IBM Quantum.</li>
<li>Establish a connection to IBM Quantum using your API token.</li>
<li>Select a backend QPU</li>
<li>Transpile your circuits for the target backend</li>
</ol>
</div>

<div id="outline-container-orgc02b052" class="outline-4">
<h4 id="orgc02b052"><span class="section-number-4">7.3.1.</span> Getting Your IBM Quantum API Token</h4>
<div class="outline-text-4" id="text-7-3-1">
<ol class="org-ol">
<li>If you don't already have one, use your university e-mail account
(prefferable) to register for an account.</li>
<li>Once logged in, you can get your IBM token in one of two ways:
<ol class="org-ol">
<li>Visit your <a href="https://quantum.ibm.com">IBM Quantum Platform dashboard</a>
<ol class="org-ol">
<li><p>
In the upper right, you'll see a box where you can view or copy your
IBM Quantum API token
</p>

<div id="orgf888470" class="figure">
<p><img src="./img/IBMQuantumDashboard.png" alt="IBMQuantumDashboard.png" width="360px" />
</p>
</div></li>
</ol></li>
<li><p>
Click the "Account" button (by default, it looks like an anonymized
profile pic). This brings up your <i>Profile Settings</i>
</p>

<div id="org52be938" class="figure">
<p><img src="./img/IBMQuantumAccountIcon.png" alt="IBMQuantumAccountIcon.png" width="360px" />
</p>
</div>
<ol class="org-ol">
<li>Below the <i>Profile Details</i> is an <i>API Token</i>. Click the icon that allows
you to copy you IBM Quantum API token. You will paste this information
elsewhere later.</li>
</ol></li>
</ol></li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> sys
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">create a backend</span>
<span style="color: #DFAF8F;">backend_aer</span> = AerSimulator()

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Specify the target backend for transpilation</span>
<span style="color: #DFAF8F;">target_aer</span> = backend_aer.target

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Create a pass manager object to perform the transpilation</span>
<span style="color: #DFAF8F;">pm_aer</span> = generate_preset_pass_manager(target=target_aer, optimization_level=1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Want to know more about the pass manager? Start printing things about it.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'Class of pm_aer: {type(pm_aer)}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer: {pm_aer}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer attributes: {pm_aer.__dict__}')</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">

Code block complete at 2025-03-11 11:43:31.984413
</pre>
</div>
</div>


<div id="outline-container-org961d1bc" class="outline-4">
<h4 id="org961d1bc"><span class="section-number-4">7.3.2.</span> The <a href="https://docs.python.org/3/library/getpass.html">getpass</a> Package</h4>
<div class="outline-text-4" id="text-7-3-2">
<ul class="org-ul">
<li>This is a nice Python package that is useful in Jupyter notebooks</li>
<li>It allows you to prompt the user for a password that can be used later in the file.</li>
<li><p>
The basic usage is:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> getpass <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">this comes with standard Python</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This interactively prompts the user for their password</span>
<span style="color: #DFAF8F;">token</span> = getpass.getpass(<span style="color: #CC9393;">'Enter your password: '</span>)
</pre>
</div></li>
<li>You can then use <code>token</code> in an API call</li>
<li>This allows you to share Jupyter notebooks <i>without</i> also sharing your
password/token/API key.</li>
</ul>
</div>
</div>

<div id="outline-container-org32da2e8" class="outline-4">
<h4 id="org32da2e8"><span class="section-number-4">7.3.3.</span> My Approach to Loading My Token (not recommended)</h4>
<div class="outline-text-4" id="text-7-3-3">
<div class="note" id="orgca64914">
<p>
If you are using a Jupyter Lab notebook, please ignore this section. This is
useful for me, since I'm coding in Emacs Org mode.
</p>

</div>
<ul class="org-ul">
<li>I use this approach because I sometimes run Python code <i>outside</i> of a Jupyter
notebook, so I don't have an opportunity to dynamically input my password
using <code>getpass</code></li>
<li>My approach was to save a file on my computer, say, <code>~/.IBMQpass</code>
<ul class="org-ul">
<li>This is a text file containing only my IBM Quantum token</li>
</ul></li>
<li><p>
Then, I can load the token in a variable called <code>token</code> using code like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Read the token from a secure file</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Expand the '~' to the full path</span>
<span style="color: #DFAF8F;">file_path</span> = os.path.expanduser(<span style="color: #CC9393;">"~/.IBMQpass"</span>)
<span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span>(file_path, <span style="color: #CC9393;">"r"</span>) <span style="color: #F0DFAF; font-weight: bold;">as</span> <span style="color: #DCDCCC; font-weight: bold;">file</span>:
    <span style="color: #DFAF8F;">token</span> = <span style="color: #DCDCCC; font-weight: bold;">file</span>.read().strip()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Loaded IBM Quantum token: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(datetime.now()))
</pre>
</div>

<pre class="example">

Loaded IBM Quantum token: 2025-03-11 13:23:35.985776
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org07ba7ea" class="outline-4">
<h4 id="org07ba7ea"><span class="section-number-4">7.3.4.</span> Establish a Connection to IBM Quantum</h4>
<div class="outline-text-4" id="text-7-3-4">
<ul class="org-ul">
<li><p>
To interface with the IBM cloud resources, we establish a
<code>QiskitRuntimeService</code> object, <code>service</code>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">service</span> = QiskitRuntimeService(channel=<span style="color: #CC9393;">'ibm_quantum'</span>)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Established a service at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Established a service at 2025-03-11 13:38:33.591301
</pre></li>

<li><p>
We can then use the <code>service</code> object to query available QPUs
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(service.backends())
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">in Jupyter notebook, you don't need print() ... just use</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">service.backends() as the last command in your cell.</span>
</pre>
</div>

<pre class="example">
[&lt;IBMBackend('ibm_brisbane')&gt;, &lt;IBMBackend('ibm_kyiv')&gt;, &lt;IBMBackend('ibm_sherbrooke')&gt;]
</pre></li>

<li>This is a list of objects of the <a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend">IBMBackend</a> class
<ul class="org-ul">
<li><p>
We can ask for the least-busy backend using the <code>.least_busy()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">save the least-busy backend as backend</span>
<span style="color: #DFAF8F;">backend_qpu</span> = service.least_busy()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Least busy QPU: </span>{backend_qpu}<span style="color: #CC9393;"> (</span>{datetime.now()}<span style="color: #CC9393;">)'</span>)
</pre>
</div>

<pre class="example">
Least busy QPU: &lt;IBMBackend('ibm_kyiv')&gt; (2025-03-11 13:50:36.850750)
</pre></li>
</ul></li>

<li><p>
We can get information about a backend using properties such as <code>.name</code>,
<code>.version</code>, and <code>.num_qubits</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(
    f<span style="color: #CC9393;">"Name: </span>{backend_qpu.name}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"Version: </span>{backend_qpu.version}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"No. of qubits: </span>{backend_qpu.num_qubits}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
)
</pre>
</div>

<pre class="example">
Name: ibm_kyiv
Version: 2
No. of qubits: 127
</pre></li>

<li>Now that we've picked a backend, we can transpile our circuits for that
backend.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd780987" class="outline-4">
<h4 id="orgd780987"><span class="section-number-4">7.3.5.</span> Transpilation</h4>
<div class="outline-text-4" id="text-7-3-5">
<p>
Now that we have a backend in mind, we can transpile our circuits for the
desired backend:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Specify the target backend for transpilation</span>
<span style="color: #DFAF8F;">target_qpu</span> = backend_qpu.target

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Create a pass manager object to perform the transpilation</span>
<span style="color: #DFAF8F;">pm_qpu</span> = generate_preset_pass_manager(target=target_qpu, optimization_level=1)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Want to know more about the pass manager? Start printing things about it.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'Class of pm_aer: {type(pm_aer)}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer: {pm_aer}')</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print(f'pm_aer attributes: {pm_aer.__dict__}')</span>

<span style="color: #DFAF8F;">BellCkts_qpu</span> = pm_qpu.run( BellCkts ) 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Code block complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Code block complete at 2025-03-11 14:06:37.004840
</pre>


<p>
We can see the transpiled version of our circuits if we print them.
</p>

<p>
In Jupyter Lab, something like the following may be used to display the
circuits:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx, ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(BellCkts):
    display(BellCkts_qpu[idx].draw(idle_wires=<span style="color: #BFEBBF;">False</span>))
</pre>
</div>


<div id="orgf84bbb6" class="figure">
<p><img src="./img/BellCkt0_qpu.png" alt="BellCkt0_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 25: </span>The first Bell circuit is transpiled for the selected backend, <code>backend_qpu</code>.</p>
</div>


<div id="org32e31fe" class="figure">
<p><img src="./img/BellCkt1_qpu.png" alt="BellCkt1_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 26: </span>The first Bell circuit is transpiled for the selected backend, <code>backend_qpu</code>.</p>
</div>


<p>
We may wish to compare our transpiled circuit to our original circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx, ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(BellCkts):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'='</span>*70 + f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">idx = </span>{idx}<span style="color: #CC9393;">'</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Original circuit design:'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(ckt)

</pre>
</div>

<pre class="example" id="org7733cca">
======================================================================
idx = 0
Original circuit design:
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
======================================================================
idx = 1
Original circuit design:
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        ├───┤┌─┴─┐ ░ └╥┘┌─┐
   q_1: ┤ X ├┤ X ├─░──╫─┤M├
        └───┘└───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1
</pre>

<p>
Now, we can clearly see that the transpiled circuit looks rather different from
the original design. The transpiled circuit may have many more qubits than the
original design; however, extra qubits are suppressed from our drawings by using
the keyword <code>idle_qubits=False</code> in the <code>draw()</code> method for a circuit.
</p>
</div>
</div>

<div id="outline-container-orge134e18" class="outline-4">
<h4 id="orge134e18"><span class="section-number-4">7.3.6.</span> Forming PUBs</h4>
<div class="outline-text-4" id="text-7-3-6">
<p>
Now that we have transpiled circuits for the QPU, we must form a list of PUBs:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">PUBs_qpu</span> = [ (ckt, <span style="color: #BFEBBF;">None</span>) <span style="color: #F0DFAF; font-weight: bold;">for</span> ckt <span style="color: #F0DFAF; font-weight: bold;">in</span> BellCkts_qpu ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a list of PUBs for the QPU at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Your list of PUBs contains </span>{<span style="color: #DCDCCC; font-weight: bold;">len</span>(PUBs_qpu)}<span style="color: #CC9393;"> PUBs.'</span>)
</pre>
</div>

<pre class="example">
Created a list of PUBs for the QPU at 2025-03-11 14:24:10.350039
Your list of PUBs contains 2 PUBs.
</pre>


<p>
Next, we will run our jobs by submittin the PUBs.
</p>
</div>
</div>
</div>

<div id="outline-container-org15a3f12" class="outline-3">
<h3 id="org15a3f12"><span class="section-number-3">7.4.</span> Running the Circuits</h3>
<div class="outline-text-3" id="text-7-4">
<p>
Here, we will use <code>qiskit_aer.primitives.SamplerV2()</code> as our simulation
platform. First, we instantiate a <code>SamplerV2</code> object. Note: we import
`qiskit<sub>aer.primitives.SamplerV2</sub>~ as <code>Sampler</code> to distinguish it from the
<code>qiskit_ibm_runtime.SamplerV2</code> which we will use later.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Instantiate a sampler</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2

<span style="color: #DFAF8F;">sampler_qpu</span> = SamplerV2( backend_qpu )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Created a SamplerV2 for use with a QPU at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Created a SamplerV2 for use with a QPU at 2025-03-11 14:26:32.622540
</pre>


<p>
Finally, we use the <code>run()</code> method of our sampler. We will specify a shot count
of 4096, since we may wish to compare with results from actual hardware using a
<code>qiskit_ibm_runtime.SamplerV2</code> object. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">We specify the same number of shots as in our simulated run</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">use None to launch a new calculation.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">use an actual job_id to retrieve an existing calculation.</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">job_id = None</span>
<span style="color: #DFAF8F;">job_id</span> = <span style="color: #CC9393;">'cz890patp60g008grx9g'</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span> job_id <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
    <span style="color: #DFAF8F;">job_qpu</span> = sampler_qpu.run( PUBs_qpu, shots=4092 ) 
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Submitted the QPU job at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
    <span style="color: #DFAF8F;">job_id</span> = job_qpu.job_id()
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'   Job ID: </span>{job_id}<span style="color: #CC9393;">'</span>)

<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DFAF8F;">job_qpu</span> = service.job( job_id )
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Retrieved existing job (</span>{datetime.now()}<span style="color: #CC9393;">).'</span>)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'   Job ID: </span>{job_id}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
Retrieved existing job (2025-03-11 14:35:30.892405).
   Job ID: cz890patp60g008grx9g
</pre>


<p>
We can check the status of our job:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'The status of our job is: </span>{job_qpu.status()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
The status of our job is: DONE
</pre>
</div>
</div>

<div id="outline-container-org43530cb" class="outline-3">
<h3 id="org43530cb"><span class="section-number-3">7.5.</span> Accessing the Results</h3>
<div class="outline-text-3" id="text-7-5">
<p>
We can extract results from our job using its <code>.result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results_qpu</span> = job_qpu.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results_qpu)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'circuit_metadata': {}}), SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=4092, num_bits=2&gt;)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([DoubleSliceSpan(&lt;start='2025-03-11 19:34:53', stop='2025-03-11 19:34:56', size=8184&gt;)])}, 'version': 2})
</pre>


<p>
We can plot the results, just as before:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(results_qpu[idx].data.meas.get_counts())
</pre>
</div>

<pre class="example">
{'00': 1961, '11': 2065, '01': 36, '10': 30}
{'10': 2058, '01': 1964, '00': 22, '11': 48}
</pre>


<p>
Indeed, we can print our results, but it is much nicer to plot them using a
histogram.
</p>

<p>
Unlike in the simulation, which was noise-free, we now have noise. Bell circuit
0 should not produce states \(\left| 01 \right \rangle\) nor
\(\left| 10 \right \rangle\), yet, they are listed in the measurement results,
indicating that they have a non-zero probability of occurring. Similarly,
circuit 1 should not produce \(\left| 00 \right \rangle\) nor
\(\left| 11 \right \rangle\).
</p>

<p>
For a better comparison between our noise-free simulation and QPU results, we
plot the counts on the same histogram. We can do this using the
<code>plot_histogram()</code> method if we provide a list the counts we want to appear on
the same plot:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span style="color: #F0DFAF; font-weight: bold;">for</span> idx <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(2):
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Bell circuit </span>{idx}<span style="color: #CC9393;">'</span>)
    display(plot_histogram([results_sim[idx].data.meas.get_counts()),
                           results_qpu[idx].data.meas.get_counts())])
</pre>
</div>


<div id="org348c7d3" class="figure">
<p><img src="./img/bell_ckt_results00_compare.png" alt="bell_ckt_results00_compare.png" width="480px" />
</p>
<p><span class="figure-number">Figure 27: </span>QPU results are compared with noise-free simulation results for Bell circuit 0.</p>
</div>

<p>
Bell circuit 1:
</p>


<div id="org1faac90" class="figure">
<p><img src="./img/bell_ckt_results01_compare.png" alt="bell_ckt_results01_compare.png" width="480px" />
</p>
<p><span class="figure-number">Figure 28: </span>QPU results are compared with noise-free simulation results for Bell circuit 1.</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org1d8701f" class="outline-2">
<h2 id="org1d8701f"><span class="section-number-2">8.</span> Qiskit IBM Runtime Primitives</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org83ce0b2" class="outline-3">
<h3 id="org83ce0b2"><span class="section-number-3">8.1.</span> Imports</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> math <span style="color: #F0DFAF; font-weight: bold;">import</span> pi <span style="color: #F0DFAF; font-weight: bold;">as</span> &#960;

<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_distribution
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> AerSimulator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> SamplerV2, EstimatorV2, QiskitRuntimeService
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd191730" class="outline-3">
<h3 id="orgd191730"><span class="section-number-3">8.2.</span> Load a Personal IBM Token</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>You need a personal IBM token to access the hardware.</li>
<li>There are several ways to do this.</li>
<li>The first thing, however, is to get a personal IBM Quantum token</li>
</ul>
</div>
<div id="outline-container-orge516632" class="outline-4">
<h4 id="orge516632"><span class="section-number-4">8.2.1.</span> Getting Your IBM Quantum Token</h4>
<div class="outline-text-4" id="text-8-2-1">
<ol class="org-ol">
<li>If you don't already have one, use your university e-mail account
(prefferable) to register for an account.</li>
<li>Once logged in, you can get your IBM token in one of two ways:
<ol class="org-ol">
<li>Visit your <a href="https://quantum.ibm.com">IBM Quantum Platform dashboard</a>
<ol class="org-ol">
<li><p>
In the upper right, you'll see a box where you can view or copy your
IBM Quantum API token
</p>

<div id="orge1abc87" class="figure">
<p><img src="./img/IBMQuantumDashboard.png" alt="IBMQuantumDashboard.png" width="360px" />
</p>
</div></li>
</ol></li>
<li><p>
Click the "Account" button (it looks like an anonymized profile pic). This
brings up your <i>Profile Settings</i>
</p>

<div id="org79ece7b" class="figure">
<p><img src="./img/IBMQuantumAccountIcon.png" alt="IBMQuantumAccountIcon.png" width="360px" />
</p>
</div>
<ol class="org-ol">
<li>Below the <i>Profile Details</i> is an <i>API Token</i>. Click the icon that allows
you to copy you IBM Quantum API token. You will paste this information
elsewhere later.</li>
</ol></li>
</ol></li>
</ol>
</div>
</div>



<div id="outline-container-orga215e01" class="outline-4">
<h4 id="orga215e01"><span class="section-number-4">8.2.2.</span> The <a href="https://docs.python.org/3/library/getpass.html">getpass</a> Package</h4>
<div class="outline-text-4" id="text-8-2-2">
<ul class="org-ul">
<li>This is a nice Python package that is useful in Jupyter notebooks</li>
<li>It allows you to prompt the user for a password that can be used later in the file.</li>
<li><p>
The basic usage is:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> getpass <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">this comes with standard Python</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This interactively prompts the user for their password</span>
<span style="color: #DFAF8F;">token</span> = getpass.getpass(<span style="color: #CC9393;">'Enter your password: '</span>)
</pre>
</div></li>
<li>You can then use <code>token</code> in an API call</li>
<li>This allows you to share Jupyter notebooks <i>without</i> also sharing your
password/token/API key.</li>
</ul>
</div>
</div>

<div id="outline-container-orga1cada8" class="outline-4">
<h4 id="orga1cada8"><span class="section-number-4">8.2.3.</span> Acessing IBM Quantum Harware Using Your Token</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li><p>
Once you have a variable <code>token</code> that contains your API key, you can
leverage the <code>QiskitRuntimeService.save_account()</code> to save the token your
computer for future use:
</p>
<div class="org-src-container">
<pre class="src src-python">QiskitRuntimeService.save_account(
    channel=<span style="color: #CC9393;">"ibm_quantum"</span>,
    token=token,
    overwrite=<span style="color: #BFEBBF;">True</span>,
    set_as_default=<span style="color: #BFEBBF;">True</span>)
</pre>
</div></li>
</ul>
<p>
We can then put it all together in the following way:
</p>
<ol class="org-ol">
<li>Check your computer to see if there's a saved IBM quantum token.
<ol class="org-ol">
<li>If yes, use it</li>
<li>If not, prompt the user for the token
<ol class="org-ol">
<li>In this case, we replace the variable <code>token</code> with a call to
<code>getpass.getpass()</code>, which effectively supplies the token to
<code>QiskitRuntimeService()</code></li>
</ol></li>
</ol></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">try</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Load any previously-saved IBM Quantum tokens</span>
    QiskitRuntimeService.saved_accounts()
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">"Found and loaded a previously-saved IBM Quantum API token."</span>)
<span style="color: #F0DFAF; font-weight: bold;">except</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Otherwise, prompt user for token</span>
    QiskitRuntimeService.save_account(
    channel=<span style="color: #CC9393;">"ibm_quantum"</span>,
    token=getpass.getpass(<span style="color: #CC9393;">"No token found. Enter your IBM Quantum API token: "</span>),
    overwrite=<span style="color: #BFEBBF;">True</span>,
    set_as_default=<span style="color: #BFEBBF;">True</span>)

    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">"Account saved successfully!"</span>)
</pre>
</div>

<pre class="example">
Found and loaded a previously-saved IBM Quantum API token.
</pre>
</div>
</div>


<div id="outline-container-org36a5f72" class="outline-4">
<h4 id="org36a5f72"><span class="section-number-4">8.2.4.</span> My Approach (not recommended)</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>I use this approach because I sometimes run Python code <i>outside</i> of a Jupyter
notebook, so I don't have an opportunity to dynamically input my password
using <code>getpass</code></li>
<li>My approach was to save a file on my computer, say, <code>~/.IBMQpass</code>
<ul class="org-ul">
<li>This is a text file containing only my IBM Quantum token</li>
</ul></li>
<li><p>
Then, I can load the token in a variable called <code>token</code> using code like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Read the token from a secure file</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Expand the '~' to the full path</span>
<span style="color: #DFAF8F;">file_path</span> = os.path.expanduser(<span style="color: #CC9393;">"~/.IBMQpass"</span>)
<span style="color: #F0DFAF; font-weight: bold;">with</span> <span style="color: #DCDCCC; font-weight: bold;">open</span>(file_path, <span style="color: #CC9393;">"r"</span>) <span style="color: #F0DFAF; font-weight: bold;">as</span> <span style="color: #DCDCCC; font-weight: bold;">file</span>:
    <span style="color: #DFAF8F;">token</span> = <span style="color: #DCDCCC; font-weight: bold;">file</span>.read().strip()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Loaded IBM Quantum token: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(datetime.now()))
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6b8d93f" class="outline-3">
<h3 id="org6b8d93f"><span class="section-number-3">8.3.</span> Establish a Connection</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li><p>
To interface with the IBM cloud resources, we establish as
<code>QiskitRuntimeService</code> object, <code>service</code>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">service</span> = QiskitRuntimeService(channel=<span style="color: #CC9393;">'ibm_quantum'</span>)
</pre>
</div></li>

<li><p>
We can then use the <code>service</code> object to query available QPUs
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(service.backends())
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">in Jupyter notebook, you don't need print() ... just use</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">service.backends() as the last command in your cell.</span>
</pre>
</div>

<pre class="example">
[&lt;IBMBackend('ibm_brisbane')&gt;, &lt;IBMBackend('ibm_kyiv')&gt;, &lt;IBMBackend('ibm_sherbrooke')&gt;]
</pre></li>

<li>This is a list of objects of the <a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend">IBMBackend</a> class
<ul class="org-ul">
<li><p>
We can ask for the least-busy backend using the <code>.least_busy()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">save the least-busy backend as backend</span>
<span style="color: #DFAF8F;">backend</span> = service.least_busy()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(backend)
</pre>
</div>

<pre class="example">
&lt;IBMBackend('ibm_brisbane')&gt;
</pre></li>
</ul></li>

<li><p>
We can get information about a backend using properties such as <code>.name</code>,
<code>.version</code>, and <code>.num_qubits</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(
    f<span style="color: #CC9393;">"Name: </span>{backend.name}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"Version: </span>{backend.version}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
    f<span style="color: #CC9393;">"No. of qubits: </span>{backend.num_qubits}<span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">"</span>
)
</pre>
</div>

<pre class="example">
Name: ibm_brisbane
Version: 2
No. of qubits: 127
</pre></li>
<li><p>
A backend has more attributes, which we can uncover if we use the <code>.__dict__</code>
property:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(backend.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_options': Options(shots=4000, memory=False, meas_level=&lt;MeasLevel.CLASSIFIED: 2&gt;, meas_return=&lt;MeasReturnType.AVERAGE: 'avg'&gt;, memory_slots=None, memory_slot_size=100, rep_time=None, rep_delay=None, init_qubits=True, use_measure_esp=None, use_fractional_gates=False, noise_model=None, seed_simulator=None), '_provider': None, 'name': 'ibm_brisbane', 'description': None, 'online_date': datetime.datetime(2023, 1, 23, 5, 0, tzinfo=tzutc()), 'backend_version': '1.1.66', '_coupling_map': None, '_instance': 'ibm-q/open/main', '_service': &lt;QiskitRuntimeService&gt;, '_api_client': &lt;qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x122bed850&gt;, '_configuration': &lt;qiskit_ibm_runtime.models.backend_configuration.PulseBackendConfiguration object at 0x122915f90&gt;, '_properties': &lt;qiskit_ibm_runtime.models.backend_properties.BackendProperties object at 0x126f1a9d0&gt;, '_defaults': &lt;qiskit_ibm_runtime.models.pulse_defaults.PulseDefaults object at 0x126ccbdd0&gt;, '_target': &lt;qiskit.transpiler.target.Target object at 0x1206080a0&gt;, '_max_circuits': 300, '_session': None}
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-orgb7b8024" class="outline-3">
<h3 id="orgb7b8024"><span class="section-number-3">8.4.</span> Define Sampler Instances</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li><p>
We will create backends so we can compare a simulation using <code>AerSimulator()</code>
against a calculation on actual quantum hardware
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">backend_aer</span> = AerSimulator() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator backend</span>
<span style="color: #DFAF8F;">backend_qpu</span> = backend <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">hardware backend</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(backend_aer))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(backend_qpu))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit_aer.backends.aer_simulator.AerSimulator'&gt;
&lt;class 'qiskit_ibm_runtime.ibm_backend.IBMBackend'&gt;
</pre></li>

<li><p>
We now use the backends to define samplers
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">sampler_aer</span> = SamplerV2(backend_aer) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for simulator</span>
<span style="color: #DFAF8F;">sampler_qpu</span> = SamplerV2(backend_qpu) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">sampler for QPU</span>

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(sampler_aer))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(sampler_qpu))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit_ibm_runtime.sampler.SamplerV2'&gt;
&lt;class 'qiskit_ibm_runtime.sampler.SamplerV2'&gt;
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org76b98f3" class="outline-3">
<h3 id="org76b98f3"><span class="section-number-3">8.5.</span> Create Some Circuits</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1</span> = QuantumCircuit(1)
qc1.h(0)
qc1.measure_all()
qc1.draw()
</pre>
</div>


<div id="org3ba84be" class="figure">
<p><img src="./img/simQPUckt.png" alt="simQPUckt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 29: </span>This circuit is designed for simulation and implementation on actual IBM quantum hardware.</p>
</div>

<ul class="org-ul">
<li>A parametrized circuit is create as a second circuit to test</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#952;</span> = Parameter(<span style="color: #CC9393;">'&#952;'</span>)
<span style="color: #DFAF8F;">&#981;</span> = Parameter(<span style="color: #CC9393;">'&#981;'</span>)

<span style="color: #DFAF8F;">qr</span> = QuantumRegister(2, name=<span style="color: #CC9393;">'q'</span>)

<span style="color: #DFAF8F;">cr</span> = ClassicalRegister(2, name=<span style="color: #CC9393;">'SomeName'</span>)

<span style="color: #DFAF8F;">qc2</span> = QuantumCircuit( qr, cr )
qc2.rx(&#952;,1)
qc2.cry(&#981;,1,0)
qc2.measure(qr, cr)
qc2.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org9182c10" class="figure">
<p><img src="./img/simQPUckt2.png" alt="simQPUckt2.png" width="480px" />
</p>
<p><span class="figure-number">Figure 30: </span>This parameterized circuit provides a second circuit to compare in simulation and on actual hardware.</p>
</div>

<ul class="org-ul">
<li><p>
Next, we define angles for use with circuit 2:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">angles</span> = [[&#960;/4, &#960;/2], [&#960;/3, &#960;], [&#960;/2, &#960;]]
</pre>
</div>

<ul class="org-ul">
<li>The there are three sets of parameters</li>
<li>Each set has two angles, one for each parameter</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1daed8a" class="outline-3">
<h3 id="org1daed8a"><span class="section-number-3">8.6.</span> Transpile the Circuits</h3>
<div class="outline-text-3" id="text-8-6">
</div>
<div id="outline-container-org6d34c96" class="outline-4">
<h4 id="org6d34c96"><span class="section-number-4">8.6.1.</span> Circuit 1 (Aer)</h4>
<div class="outline-text-4" id="text-8-6-1">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#org3ba84be">29</a> for the <code>AerSimulator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1_aer</span> = transpile( qc1, backend=backend_aer)
qc1_aer.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>

<pre class="example">
#+attr_html: :width 480px
#+caption: The circuit of Figure [[fig:simQPUckt1]] is transpiled for the =AerSimulator=.
[[./img/simQPUckt1trans_aer.png]]
</pre>



<div id="orgb729ae9" class="figure">
<p><img src="./img/simQPUckt1trans_aer.png" alt="simQPUckt1trans_aer.png" width="480px" />
</p>
<p><span class="figure-number">Figure 31: </span>The circuit of Figure <a href="#org3ba84be">29</a> is transpiled for the <code>AerSimulator</code>.</p>
</div>
</div>
</div>

<div id="outline-container-org2ce4f5d" class="outline-4">
<h4 id="org2ce4f5d"><span class="section-number-4">8.6.2.</span> Circuit 2 (Aer)</h4>
<div class="outline-text-4" id="text-8-6-2">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#org9182c10">30</a> for the <code>AerSimulator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2_aer</span> = transpile( qc2, backend=backend_aer)
qc2_aer.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org90d3bc4" class="figure">
<p><img src="./img/simQPUckt2trans_aer.png" alt="simQPUckt2trans_aer.png" width="480px" />
</p>
<p><span class="figure-number">Figure 32: </span>The circuit of Figure <a href="#org9182c10">30</a> is transpiled for the <code>AerSimulator</code>.</p>
</div>


<ul class="org-ul">
<li>We also transpile and optimize the circuit <code>qc2</code>
<ul class="org-ul">
<li><p>
To do this, we use the <code>generate_preset_pass_manager</code> function
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #DFAF8F;">target</span> = backend_aer.target
<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(target=target, optimization_level=1)
<span style="color: #DFAF8F;">qc2_aer</span> = pm.run(qc2)
qc2_aer.draw( reverse_bits=<span style="color: #BFEBBF;">True</span> )
</pre>
</div>


<div id="orga815486" class="figure">
<p><img src="./img/simQPUckt2trans_aer_pm.png" alt="simQPUckt2trans_aer_pm.png" width="480px" />
</p>
<p><span class="figure-number">Figure 33: </span>Here, the circuit of Figure <a href="#org9182c10">30</a> is transpiled using a pass manager. It is the same as the result in Figure <a href="#org90d3bc4">32</a>.</p>
</div></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgffb82b6" class="outline-4">
<h4 id="orgffb82b6"><span class="section-number-4">8.6.3.</span> Circuit 1 (QPU)</h4>
<div class="outline-text-4" id="text-8-6-3">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#org3ba84be">29</a> for the quantum hardware</li>
<li>Since the hardware has many more qubits than the circuit, we use
<code>idle_wires=False</code> to suppress the display of idle qubits when we use the
<code>.draw()</code> method</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc1_qpu</span> = transpile( qc1, backend=backend_qpu)
qc1_qpu.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>, idle_wires=<span style="color: #BFEBBF;">False</span> )
</pre>
</div>


<div id="orgba76b72" class="figure">
<p><img src="./img/simQPUckt1trans_qpu.png" alt="simQPUckt1trans_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 34: </span>The circuit of Figure <a href="#org3ba84be">29</a> is transpiled for the quantum hardware.</p>
</div>
</div>
</div>
<div id="outline-container-orgf1fb013" class="outline-4">
<h4 id="orgf1fb013"><span class="section-number-4">8.6.4.</span> Circuit 2 (QPU)</h4>
<div class="outline-text-4" id="text-8-6-4">
<ul class="org-ul">
<li>We transpile the circuit of Figure <a href="#org9182c10">30</a> for the quantum hardware</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">target</span> = backend_qpu.target
<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(target=target, optimization_level=1)
<span style="color: #DFAF8F;">qc2_qpu</span> = pm.run(qc2)
qc2_qpu.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>, idle_wires=<span style="color: #BFEBBF;">False</span> )
</pre>
</div>


<div id="orgd679101" class="figure">
<p><img src="./img/simQPUckt2trans_qpu.png" alt="simQPUckt2trans_qpu.png" width="480px" />
</p>
<p><span class="figure-number">Figure 35: </span>The circuit of Figure <a href="#org9182c10">30</a> is transpiled for the quantum hardware.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org795b27a" class="outline-3">
<h3 id="org795b27a"><span class="section-number-3">8.7.</span> Simulate the Circuits</h3>
<div class="outline-text-3" id="text-8-7">
<ul class="org-ul">
<li>The sampler <code>.run()</code> method triggers the simulation</li>
</ul>
</div>
<div id="outline-container-orgc897000" class="outline-4">
<h4 id="orgc897000"><span class="section-number-4">8.7.1.</span> Simulate on the Aer Sampler</h4>
<div class="outline-text-4" id="text-8-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_aer</span> = sampler_aer.run( [ (qc1_aer, <span style="color: #BFEBBF;">None</span>, 100), (qc2_aer, angles, 1000) ] )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Print is not needed in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(job_aer.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_job_id': '9288fdc7-7e26-40d7-b919-d32ca46a577a', 'metadata': {}, '_future': &lt;Future at 0x145e6e6d0 state=running&gt;, '_function': &lt;bound method BackendSamplerV2._run of &lt;qiskit.primitives.backend_sampler_v2.BackendSamplerV2 object at 0x14581b4d0&gt;&gt;, '_args': ([SamplerPub(&lt;()&gt;), SamplerPub(&lt;(3,)&gt;)],), '_kwargs': {}}
</pre>
</div>
</div>

<div id="outline-container-org95bb2c0" class="outline-4">
<h4 id="org95bb2c0"><span class="section-number-4">8.7.2.</span> Run on Quantum Hardware</h4>
<div class="outline-text-4" id="text-8-7-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_qpu</span> = sampler_qpu.run( [ (qc1_qpu, <span style="color: #BFEBBF;">None</span>, 100), (qc2_qpu, angles, 1000) ] )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Print is not needed in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(job_qpu)
</pre>
</div>

<pre class="example">
/Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 625.82641167829 quantum seconds, but you only have 565 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
  warnings.warn(warning_message)
&lt;RuntimeJobV2('cya60g201rbg008jq0v0', 'sampler')&gt;
</pre>


<ul class="org-ul">
<li>Once your job is sumbitted, it IBM Quantum will assign it a unique job
ID.</li>
<li>Let's see what information is embedded in the job<sub>qpu</sub> object:</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(job_qpu.<span style="color: #DCDCCC; font-weight: bold;">__dict__</span>)
</pre>
</div>

<pre class="example">
{'_job_id': 'cya60g201rbg008jq0v0', 'metadata': {}, '_backend': &lt;IBMBackend('ibm_brisbane')&gt;, '_api_client': &lt;qiskit_ibm_runtime.api.clients.runtime.RuntimeClient object at 0x14533be50&gt;, '_interim_results': None, '_creation_date': None, '_program_id': 'sampler', '_reason': None, '_reason_code': None, '_error_message': None, '_image': None, '_final_interim_results': False, '_service': &lt;QiskitRuntimeService&gt;, '_session_id': None, '_tags': None, '_usage_estimation': {}, '_version': 2, '_queue_info': None, '_user_callback': None, '_status': 'INITIALIZING', '_interim_result_decoder': &lt;class 'qiskit_ibm_runtime.utils.result_decoder.ResultDecoder'&gt;, '_final_result_decoder': &lt;class 'qiskit_ibm_runtime.utils.sampler_result_decoder.SamplerResultDecoder'&gt;, '_ws_client_future': None, '_result_queue': &lt;queue.Queue object at 0x1401a57d0&gt;, '_ws_client': &lt;qiskit_ibm_runtime.api.clients.runtime_ws.RuntimeWebsocketClient object at 0x1404550d0&gt;}
</pre>

<ul class="org-ul">
<li>We can obtain using the .job<sub>id</sub>() method.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_id</span> = job_qpu.job_id()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">"Your job's identifier is: </span>{job_id}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
Your job's identifier is: cya60g201rbg008jq0v0
</pre>


<ul class="org-ul">
<li><p>
As long as our Juptyer Lab notebook is open, we can access our job through the
<code>job_id</code> object using the <code>result()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_qpu</span> = job_qpu.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_qpu)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=100, num_bits=1&gt;)), metadata={'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(&lt;shape=(3,), num_shots=1000, num_bits=2&gt;), shape=(3,)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([SliceSpan(&lt;start='2025-01-25 03:53:39', stop='2025-01-25 03:53:54', size=100&gt;), SliceSpan(&lt;start='2025-01-25 03:53:39', stop='2025-01-25 03:53:52', size=3000&gt;)])}, 'version': 2})
</pre></li>

<li>If we shut down our Jupyter Lab notebook, we clear the memory, and the information stored in job<sub>id</sub> is lost.</li>
<li>The job ID is important because we can retrieve the results from IBM using
this ID.</li>
<li>Thus, it may be helpful to record the job ID somewhere. As a fallback, we can
always go to the IBM Quantum portal and then find the job.</li>
</ul>
</div>
</div>
<div id="outline-container-orgc6646fc" class="outline-4">
<h4 id="orgc6646fc"><span class="section-number-4">8.7.3.</span> Get Results from the <code>AerSampler</code></h4>
<div class="outline-text-4" id="text-8-7-3">
<ul class="org-ul">
<li><p>
View results:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_aer</span> = job_aer.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_aer)
</pre>
</div>

<pre class="example">
PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(&lt;shape=(), num_shots=100, num_bits=1&gt;)), metadata={'shots': 100, 'circuit_metadata': {}}), SamplerPubResult(data=DataBin(SomeName=BitArray(&lt;shape=(3,), num_shots=1000, num_bits=2&gt;), shape=(3,)), metadata={'shots': 1000, 'circuit_metadata': {}})], metadata={'version': 2})
</pre></li>

<li><p>
We retrieve the counts from the Aer sampler results:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_qc1_aer</span> = result_aer[0].data.meas.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_qc1_aer)
</pre>
</div>

<pre class="example">
{'0': 56, '1': 44}
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org3c60679" class="outline-4">
<h4 id="org3c60679"><span class="section-number-4">8.7.4.</span> Comparing Simulation and QPU Results</h4>
<div class="outline-text-4" id="text-8-7-4">
<ul class="org-ul">
<li><p>
When comparing results, it's usually a great idea to make a visualization
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fig</span> = plot_distribution([counts_qc1_aer, counts_qc1_qpu],
                        legend=[<span style="color: #CC9393;">'Simulator'</span>, <span style="color: #CC9393;">'QPU'</span>])
</pre>
</div>

<pre class="example">
Saved figure
</pre>



<div id="org4a1846d" class="figure">
<p><img src="./img/compareCountsAerQPU.png" alt="compareCountsAerQPU.png" width="620px" />
</p>
<p><span class="figure-number">Figure 36: </span>Counts from the QPU are compared against those from the Aer simulator for circuit 1.</p>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orge4fbe2b" class="outline-3">
<h3 id="orge4fbe2b"><span class="section-number-3">8.8.</span> Simulation vs QPU: Estimator</h3>
<div class="outline-text-3" id="text-8-8">
<ul class="org-ul">
<li>Estimators get us not counts, but expectation values for observables.</li>
</ul>
</div>
<div id="outline-container-org0998ed7" class="outline-4">
<h4 id="org0998ed7"><span class="section-number-4">8.8.1.</span> Defining Estimator Objects</h4>
<div class="outline-text-4" id="text-8-8-1">
<ul class="org-ul">
<li><p>
Define Aer and QPU estimators:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">estimator_aer</span> = EstimatorV2( backend_aer )
<span style="color: #DFAF8F;">estimator_qpu</span> = EstimatorV2( backend_qpu )
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orga0a3bcb" class="outline-4">
<h4 id="orga0a3bcb"><span class="section-number-4">8.8.2.</span> Defining Observable Operators</h4>
<div class="outline-text-4" id="text-8-8-2">
<ul class="org-ul">
<li><p>
We also need observable(s) to supply for the estimators:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">obsv_list</span> = [[SparsePauliOp([<span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"IY"</span>], [0.5, 0.5])],
             [SparsePauliOp([<span style="color: #CC9393;">"XX"</span>], [1])],
             [SparsePauliOp([<span style="color: #CC9393;">"IY"</span>], [1])]]
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org308649e" class="outline-4">
<h4 id="org308649e"><span class="section-number-4">8.8.3.</span> Layout Mapping</h4>
<div class="outline-text-4" id="text-8-8-3">
<ul class="org-ul">
<li><p>
This observable must be mapped to the circuit of interest.
</p>
<ul class="org-ul">
<li>This is important because the hardware may have many more (idle) qubits than
our circuit does.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">layout</span> = qc2_qpu.layout 

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(layout))

<span style="color: #DFAF8F;">obsv_qpu</span> = []

<span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list:
    <span style="color: #DFAF8F;">obsv_temp</span> = obsv[0].apply_layout(layout)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_temp)
    obsv_qpu.append([obsv_temp])
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.transpiler.layout.TranspileLayout'&gt;
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
              coeffs=[0.5+0.j, 0.5+0.j])
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX'],
              coeffs=[1.+0.j])
SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIY'],
              coeffs=[1.+0.j])
</pre></li>
<li>The simulated estimator does <b>not</b> need the modified observables, and we will run
only one circuit</li>
</ul>
</div>
</div>

<div id="outline-container-org23ec95a" class="outline-4">
<h4 id="org23ec95a"><span class="section-number-4">8.8.4.</span> Simulation</h4>
<div class="outline-text-4" id="text-8-8-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job2_aer</span> = estimator_aer.run([(qc2_aer, obsv_list, angles, 0.01)])
</pre>
</div>
</div>
</div>

<div id="outline-container-orge73bc0a" class="outline-4">
<h4 id="orge73bc0a"><span class="section-number-4">8.8.5.</span> QPU Submission</h4>
<div class="outline-text-4" id="text-8-8-5">
<div class="org-src-container">
<pre class="src src-python" id="org0d7981e"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">If you've never submitted the job before, set job2_id to None</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">job2_id = None</span>
<span style="color: #DFAF8F;">job2_id</span> = <span style="color: #CC9393;">'cya6t20nrmz000862cs0'</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span> job2_id <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #BFEBBF;">None</span>:
    <span style="color: #DFAF8F;">job2_qpu</span> = estimator_qpu.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
    <span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Submitted new job with id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Loads by ID a pre-existing job from IBM Quantum </span>
    <span style="color: #DFAF8F;">job2_gpu</span> = QiskitRuntimeService().job(job2_id)
    <span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Loaded old job with id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
</pre>
</div>

<pre class="example">
/Users/enrique_blair/Library/CloudStorage/Box-Box/Teaching/GitHub/BU-ECE-IntroQuantumComputing/.direnv/python-3.11/lib/python3.11/site-packages/qiskit_ibm_runtime/qiskit_runtime_service.py:849: UserWarning: Your current pending jobs are estimated to consume 647.0957899365619 quantum seconds, but you only have 546 quantum seconds left in your monthly quota; therefore, it is likely this job will be canceled
  warnings.warn(warning_message)
Submitted new job with id: cya6t20nrmz000862cs0
</pre>



<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(job2_qpu)
<span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Job id: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.job_id()) )
<span style="color: #DCDCCC; font-weight: bold;">print</span>( <span style="color: #CC9393;">'Status: {0}'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(job2_qpu.status()) )

<span style="color: #F0DFAF; font-weight: bold;">if</span> job2_qpu.status() == <span style="color: #CC9393;">'DONE'</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(job2_qpu.metrics())
</pre>
</div>

<pre class="example">
&lt;RuntimeJobV2('cya6t20nrmz000862cs0', 'estimator')&gt;
Job id: cya6t20nrmz000862cs0
Status: DONE
{'bss': {'seconds': 18}, 'usage': {'quantum_seconds': 18, 'seconds': 18}, 'timestamps': {'created': '2025-01-25T04:48:08.442Z', 'finished': '2025-01-25T04:48:43.251Z', 'running': '2025-01-25T04:48:11.227Z'}, 'executions': 62144, 'num_circuits': 224, 'num_qubits': [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127], 'circuit_depths': [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23], 'qiskit_version': 'qiskit_ibm_runtime-0.33.2,qiskit-1.3.1*,qiskit_aer-0.16.0*', 'estimated_start_time': '2025-01-25T04:48:09.875Z', 'estimated_completion_time': '2025-01-25T04:48:27.875Z', 'position_in_queue': None, 'position_in_provider': None}
</pre>


<ul class="org-ul">
<li>My job submission showed a job ID of <code>cya6t20nrmz000862cs0</code>
<ul class="org-ul">
<li>If we want to shut down or Jupyter notebook, we need to record this job number</li>
<li>Additionally, we want to go back to Listing <a href="#org0d7981e">2</a> and comment out
<code>job2_id = None</code>, and uncomment <code>job2_id = 'cya6t20nrmz000862cs0'</code>
<ul class="org-ul">
<li>This will prevent us from running a redundant job, and rather let us use
the results already calculated</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7a91651" class="outline-4">
<h4 id="org7a91651"><span class="section-number-4">8.8.6.</span> Retrieve Estimator Results</h4>
<div class="outline-text-4" id="text-8-8-6">
<ul class="org-ul">
<li>We get the expectation values by indexing the result and using the <code>.data.evs</code>
member data</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">exp_vals_aer</span> = job2_aer.result()[0].data.evs
<span style="color: #DCDCCC; font-weight: bold;">print</span>(exp_vals_aer)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(angles)
</pre>
</div>

<pre class="example">
[[-0.0055 -0.0028  0.0034]
 [-0.0104 -0.0038  0.0082]
 [-0.0006 -0.0018 -0.0014]]
[[0.7853981633974483, 1.5707963267948966], [1.0471975511965976, 3.141592653589793], [1.5707963267948966, 3.141592653589793]]
</pre>


<p>
The above list of list contains the expectation values.
</p>
<ul class="org-ul">
<li>There are three sublists, each corresponding to one of the three different
parameter sets.</li>
<li>Each sublist is a set of three expectation values corresponding to the three
observables in <code>obs_qpu</code>.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc70c73d" class="outline-3">
<h3 id="orgc70c73d"><span class="section-number-3">8.9.</span> Three Runtime Execution Methods</h3>
<div class="outline-text-3" id="text-8-9">
<ol class="org-ol">
<li>Job. Send a list of Pubs, receive PUB results</li>
<li>Session. This is good for hybrid algorithms, such VQE and VAOA. Iterations of
these algorithms depend on one another. Classical processing is done in the
cloud.</li>
<li>Batch. A series of independent jobs may be executed in parallel.</li>
</ol>
</div>
<div id="outline-container-orgb383b90" class="outline-4">
<h4 id="orgb383b90"><span class="section-number-4">8.9.1.</span> Sessions</h4>
<div class="outline-text-4" id="text-8-9-1">
<p>
We use context managers, soemthing like this:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> Session
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime.fake_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> Fake

<span style="color: #DFAF8F;">obsv_qpu</span> = [[obsv[0].apply_laout(qc2_qpu.layout) <span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_qpu)

<span style="color: #F0DFAF; font-weight: bold;">with</span> Session(backend=backend_man) <span style="color: #F0DFAF; font-weight: bold;">as</span> session
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Sampler primitive within the session</span>
    sampler = SamplerV2(session=session)
    job = sampler.run([(qc2_qpu, angles, 1000)])
    pub_result = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'1st Circuit Counts: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.SomeName.get_counts(0)}<span style="color: #CC9393;"> </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">'</span>)

    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Estimator primitive within the session</span>
    estimator = EstimatorV2(session=session)
    job = estimator.run([(qc2_qpu, obsv_qpu, angles, 0.01)])
    pub_result = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Expectation values: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.evs}<span style="color: #CC9393;">'</span>)        
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org78d9e4b"></a>Session on a Fake Backend<br />
<div class="outline-text-5" id="text-8-9-1-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime <span style="color: #F0DFAF; font-weight: bold;">import</span> Session
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_ibm_runtime.fake_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> FakeManilaV2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">backend_fake</span> = FakeManilaV2()
<span style="color: #DFAF8F;">sampler_fake</span> = SamplerV2( backend_fake )
</pre>
</div>
</div>
</li>

<li><a id="orgeb89012"></a>Transpile Circuit for <code>FakeManilaV2</code><br />
<div class="outline-text-5" id="text-8-9-1-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2_fake</span> = transpile(qc2, backend=backend_fake)
qc2_fake.draw()
</pre>
</div>


<div id="org8eb5eef" class="figure">
<p><img src="./img/fakeManillaCkt.png" alt="fakeManillaCkt.png" width="680px" />
</p>
<p><span class="figure-number">Figure 37: </span>A circuit is transpiled for simulation on the <code>FakeManilaV2</code> backend.</p>
</div>
</div>
</li>

<li><a id="orgeca408a"></a>Layout Mapping for Observable<br />
<div class="outline-text-5" id="text-8-9-1-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">obsv_fake</span> = [[obsv[0].apply_layout(qc2_fake.layout) <span style="color: #F0DFAF; font-weight: bold;">for</span> obsv <span style="color: #F0DFAF; font-weight: bold;">in</span> obsv_list]]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv_fake)
</pre>
</div>

<pre class="example">
[[SparsePauliOp(['XXIII', 'YIIII'],
              coeffs=[0.5+0.j, 0.5+0.j]), SparsePauliOp(['XXIII'],
              coeffs=[1.+0.j]), SparsePauliOp(['YIIII'],
              coeffs=[1.+0.j])]]
</pre>
</div>
</li>


<li><a id="org150da39"></a>Run a Session<br />
<div class="outline-text-5" id="text-8-9-1-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">with</span> Session(backend=backend_fake) <span style="color: #F0DFAF; font-weight: bold;">as</span> session:
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Sampler primitive within the session</span>
    <span style="color: #DFAF8F;">sampler</span> = SamplerV2(session)
    <span style="color: #DFAF8F;">job</span> = sampler.run([(qc2_fake, angles, 1000)])
    <span style="color: #DFAF8F;">pub_result</span> = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'1st Circuit Counts: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.SomeName.get_counts(0)}<span style="color: #CC9393;"> </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">'</span>)

    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Submit a request to the Estimator primitive within the session</span>
    <span style="color: #DFAF8F;">estimator</span> = EstimatorV2(session)
    <span style="color: #DFAF8F;">job</span> = estimator.run([(qc2_fake, obsv_fake, angles, 0.01)])
    <span style="color: #DFAF8F;">pub_result</span> = job.result()[0]
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Expectation values: </span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;"> </span>{pub_result.data.evs}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
1st Circuit Counts: 
 {'10': 72, '00': 854, '11': 62, '01': 12} 

Expectation values: 
 [[ 0.0097 -0.0074  0.022 ]]
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Dr. E.P. Blair</p>
<p class="date">Created: 2025-03-11 Tue 15:27</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
