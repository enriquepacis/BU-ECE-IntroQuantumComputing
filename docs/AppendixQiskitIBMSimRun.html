<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-03-11 Tue 20:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Qiskit + IBM: Simulation and Calculation</title>
<meta name="author" content="Dr. E.P. Blair" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Qiskit + IBM: Simulation and Calculation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#qinfoOverview">1. Overview</a></li>
<li><a href="#qinfoModule">2. The <code>quantum_info</code> Module</a>
<ul>
<li><a href="#orgbaca3a4">2.1. Overview</a></li>
<li><a href="#org25740ff">2.2. Make a Quantum Circuit</a></li>
<li><a href="#org6f06456">2.3. Get an Output <code>Statevector()</code> Object</a></li>
<li><a href="#orgdc0babc">2.4. Measurement Probabilities</a></li>
<li><a href="#org60e58cf">2.5. Simulated Experiments</a>
<ul>
<li><a href="#org8b61c7a">2.5.1. Measurement Outcomes for Each Shot</a></li>
<li><a href="#orgfcdb888">2.5.2. Cumulative Results over an Ensemble</a></li>
<li><a href="#org330374e">2.5.3. Expectation Values</a></li>
<li><a href="#org646bca7">2.5.4. Bloch Vectors</a></li>
<li><a href="#orge0997d1">2.5.5. Density Matrices</a></li>
</ul>
</li>
<li><a href="#org3e281b8">2.6. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:BasicSimulator">3. The <code>BasicSimulator</code> Class</a>
<ul>
<li><a href="#org3940eb9">3.1. Build a Circuit</a></li>
<li><a href="#org46826ef">3.2. Simulating the Circuit</a></li>
<li><a href="#orgf51296a">3.3. Getting the Results</a>
<ul>
<li><a href="#orgc4e2b2b">3.3.1. Simulation Counts</a></li>
<li><a href="#org8b508f9">3.3.2. Visualizing the Results</a></li>
<li><a href="#orgd6f3cda">3.3.3. Inspecting Results from Individual Measurements</a></li>
</ul>
</li>
<li><a href="#orgf70d140">3.4. Handling Complex Circuits</a>
<ul>
<li><a href="#org4c83ef7">3.4.1. Transpilation</a></li>
</ul>
</li>
<li><a href="#org5ea8824">3.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#sec:QiskitAerSimulator">4. The <code>qiskit_aer.AerSimulator</code> Class</a>
<ul>
<li><a href="#org10607c1">4.1. Overview</a></li>
<li><a href="#org14e1f1d">4.2. Imports</a></li>
<li><a href="#org7df2934">4.3. Build a Circuit</a></li>
<li><a href="#org3295c4a">4.4. Run the <code>AerSimulator()</code></a></li>
<li><a href="#orgdf9b48d">4.5. Example 2: Circuit with Statevector in Middle of Circuit</a>
<ul>
<li><a href="#orgfb272c9">4.5.1. Transpile and Run the Circuit</a></li>
</ul>
</li>
<li><a href="#orgbe7881a">4.6. Efficient Simulation</a>
<ul>
<li><a href="#org1cdd55b">4.6.1. Build a Circuit</a></li>
<li><a href="#org26b7cc3">4.6.2. Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></a></li>
</ul>
</li>
<li><a href="#org95ca613">4.7. Simulation Methods</a>
<ul>
<li><a href="#org4fa8fed">4.7.1. Build a Large Circuit</a></li>
<li><a href="#org9670756">4.7.2. Run and Time the Simulation</a></li>
</ul>
</li>
<li><a href="#org2511993">4.8. Noisy Simulation</a>
<ul>
<li><a href="#orgd4c65d4">4.8.1. Build a Circuit</a></li>
<li><a href="#org5900ef2">4.8.2. Ideal Result</a></li>
<li><a href="#orge0c8b0a">4.8.3. Noisy Result</a></li>
<li><a href="#orgb127039">4.8.4. Compare Ideal Result and Noisy Result</a></li>
</ul>
</li>
<li><a href="#orgfd5b309">4.9. Summary</a></li>
</ul>
</li>
<li><a href="#org64eeefa">5. Qiskit Primitives</a>
<ul>
<li><a href="#orgdb72294">5.1. Overview</a></li>
<li><a href="#orgda4373f">5.2. Primitives</a>
<ul>
<li><a href="#orga27e328">5.2.1. Imports</a></li>
<li><a href="#orgc49b66b">5.2.2. Build a Circuit</a></li>
<li><a href="#org463507f">5.2.3. Run Simulations</a></li>
<li><a href="#org21278c0">5.2.4. Extracting Results</a></li>
</ul>
</li>
<li><a href="#org4344055">5.3. Example: A Parametrized Circuit</a>
<ul>
<li><a href="#org23f3606">5.3.1. <code>BasicSimulator</code> Usage</a></li>
<li><a href="#org21e9bba">5.3.2. <code>StatevectorSampler</code> Usage</a></li>
<li><a href="#org3f8fcc0">5.3.3. <code>StatevectorSampler</code> Usage with Multiple PUBs</a></li>
</ul>
</li>
<li><a href="#orgc1c7409">5.4. The Estimator Primitive</a>
<ul>
<li><a href="#org8cb5cfe">5.4.1. Observables</a></li>
<li><a href="#org68551be">5.4.2. Run the Estimator</a></li>
<li><a href="#org047e043">5.4.3. Extract Expectation Values</a></li>
</ul>
</li>
<li><a href="#orgfa82c12">5.5. Qiskit Estimator Example</a>
<ul>
<li><a href="#org472d1f9">5.5.1. Build an Operator</a></li>
<li><a href="#org69f6caf">5.5.2. Instantiate a <code>StatevectorEstimator</code></a></li>
<li><a href="#org32a0914">5.5.3. Transpile the Circuit</a></li>
<li><a href="#org7e9e34d">5.5.4. Run the Estimator</a></li>
<li><a href="#org1052f5e">5.5.5. Extract Results</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-qinfoOverview" class="outline-2">
<h2 id="qinfoOverview"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-qinfoOverview">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>This page focuses on quantum computing simulations or job submissions on IBM
hardware
<ul class="org-ul">
<li>There are several ways to simulate quantum computations
<ul class="org-ul">
<li>Statevector simulations</li>
<li>Using SamplerV2 or EstimatorV2</li>
</ul></li>
</ul></li>
</ul>

<p>
The general work-flow is to:
</p>
<ol class="org-ol">
<li>Create a quantum circuit</li>
<li>Decide whether to simulate it or run it on quantum hardware
<ol class="org-ol">
<li>Typically, we simulate it first</li>
<li>We want our simulation syntax to match as closely as possible to the
syntax of job submission.</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-qinfoModule" class="outline-2">
<h2 id="qinfoModule"><span class="section-number-2">2.</span> The <code>quantum_info</code> Module</h2>
<div class="outline-text-2" id="text-qinfoModule">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-orgbaca3a4" class="outline-3">
<h3 id="orgbaca3a4"><span class="section-number-3">2.1.</span> Overview</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is built into <code>qiskit</code> and provides some basic
simulations
<ul class="org-ul">
<li>This is useful when we want to understand the quantum properties of the
output of a circuit</li>
<li>It provides:
<ul class="org-ul">
<li><code>Statevector</code> simulations</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org25740ff" class="outline-3">
<h3 id="org25740ff"><span class="section-number-3">2.2.</span> Make a Quantum Circuit</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In a Jupyter notebook we could make a cell like this:
</p>
<div class="org-src-container">
<pre class="src src-python" id="orgc403b35"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">import</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">as</span> qi

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.x(0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a NOT gate to qubit 0</span>
qc.h([0,1]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">add a H to both qubits</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter notebook, you can uncomment "qc.draw()"</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">to see your circuit</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">qc.draw()</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> datetime <span style="color: #F0DFAF; font-weight: bold;">import</span> datetime
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<p>
In Jupyter Lab, your result may be displayed automatically and look like Figure
<a href="#orge3e4058">1</a>.
</p>

<div id="orge3e4058" class="figure">
<p><img src="./img/xh2.png" alt="xh2.png" width="300px" />
</p>
<p><span class="figure-number">Figure 1: </span>A simple <code>qiskit</code> quantum circuit.</p>
</div>
</div>
</div>
<div id="outline-container-org6f06456" class="outline-3">
<h3 id="org6f06456"><span class="section-number-3">2.3.</span> Get an Output <code>Statevector()</code> Object</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We can then obtain the circuit output in <code>Statevector</code> form:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#968;</span> = qi.Statevector( qc )

<span style="color: #DCDCCC; font-weight: bold;">print</span>( &#968; )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In a Jupyter Lab notebook, you can see the result using this:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw()</span>
</pre>
</div>

<pre class="example">
Statevector([ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],
            dims=(2, 2))
</pre>


<p>
In a Jupyter notebook, you can comment <code>print( ψ )</code> and uncomment <code>ψ.draw()</code>
to  see a result that's nicer than the one shown here. It may look like this:
</p>

\begin{equation}
\label{orgc94d1bb}
\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle-
\frac{1}{2} |11\rangle
\end{equation}
</div>
</div>

<div id="outline-container-orgdc0babc" class="outline-3">
<h3 id="orgdc0babc"><span class="section-number-3">2.4.</span> Measurement Probabilities</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Once we have a <code>Statevector</code> object, we can use it to see the probabilities of
measurement, which are the modulii squared of the coefficients:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>( &#968;.probabilities() )
</pre>
</div>

<pre class="example">
[0.25 0.25 0.25 0.25]
</pre>


<p>
In this case, there are four outcomes, each with a 1/4 probability of
occurring.
</p>
</div>
</div>

<div id="outline-container-org60e58cf" class="outline-3">
<h3 id="org60e58cf"><span class="section-number-3">2.5.</span> Simulated Experiments</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Generally, a quantum computing experiment requires establishing a circuit and
performing measurements many times. Each repetition is a <b>shot</b> or a <b>trial</b>,
and a collection of shots is an <b>ensemble</b> of measurements.
</p>
</div>

<div id="outline-container-org8b61c7a" class="outline-4">
<h4 id="org8b61c7a"><span class="section-number-4">2.5.1.</span> Measurement Outcomes for Each Shot</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
We can use <code>ψ</code> to simulate circuit measurements using the <code>sample_memory()</code>
method. We specify a number of shots (trials), and we get a histogram of
samples, that is, the number of times each outcome was measured.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">samples</span> = &#968;.sample_memory( shots = 10 )

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This lists the outcomes measured for each of the 10 shots</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
['01' '01' '11' '01' '00' '00' '11' '01' '01' '00']

Calculation complete at 2025-02-26 13:41:02.891472
</pre>
</div>
</div>

<div id="outline-container-orgfcdb888" class="outline-4">
<h4 id="orgfcdb888"><span class="section-number-4">2.5.2.</span> Cumulative Results over an Ensemble</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>If we don't care about each shot, but rather, we care more about aggregate
data, we can use <code>sample_counts()</code>
<ul class="org-ul">
<li>For a given number of shots, it simulates the set of measurements, returning
a frequency (number of occurrences) for each outcome measured.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = &#968;.sample_counts( shots = 1024 )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'</span><span style="color: #BFEBBF;">\n</span><span style="color: #CC9393;">Calculation complete at </span>{datetime.now()}<span style="color: #CC9393;">'</span>)
</pre>
</div>

<pre class="example">
{np.str_('00'): np.int64(247), np.str_('01'): np.int64(253), np.str_('10'): np.int64(261), np.str_('11'): np.int64(263)}

Calculation complete at 2025-02-26 13:41:11.727536
</pre>


<p>
The counts can be visualized in a histogram. In a Jupyter notebook, use the
following, but uncomment the <code>plot_histogram()</code> command:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment in Jupyter to see histogram</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_histogram( counts )</span>
</pre>
</div>

<p>
#+RESULTS
</p>
<pre class="example">
[[./img/basic_hist.png]]

Calculation complete at 2025-02-26 13:41:38.404511
</pre>



<div id="orgd8e1473" class="figure">
<p><img src="./img/basic_hist.png" alt="basic_hist.png" width="480px" />
</p>
<p><span class="figure-number">Figure 2: </span>This is a histogram of simulated measurents based on a <code>Statevector</code> output from a quantum circuit.</p>
</div>

<p>
State vector simulations get us a state vector, and we are using that state
vector object to simulate measurements.
</p>
</div>
</div>

<div id="outline-container-org330374e" class="outline-4">
<h4 id="org330374e"><span class="section-number-4">2.5.3.</span> Expectation Values</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
State vector simulations also allow us to get expectation values, as defined in
Equation \eqref{orgfa61021}
</p>
\begin{equation}
\label{orgfa61021}
\left\langle \mathbf{O} \right\rangle = \left\langle \psi \left| \mathbf{O} \right| \psi  \right\rangle 
\end{equation}

<p>
First, we form an operator:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O</span> = qi.SparsePauliOp([<span style="color: #CC9393;">'ZZ'</span>, <span style="color: #CC9393;">'XX'</span>, <span style="color: #CC9393;">'II'</span>], [0.2, -0.3, 0.4])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Uncomment this in Jupyter</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">display(O.to_operator())</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment/omit this in Jupyter</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(O.to_operator())

</pre>
</div>

<pre class="example">
Operator([[ 0.6+0.j,  0. +0.j,  0. +0.j, -0.3+0.j],
          [ 0. +0.j,  0.2+0.j, -0.3+0.j,  0. +0.j],
          [ 0. +0.j, -0.3+0.j,  0.2+0.j,  0. +0.j],
          [-0.3+0.j,  0. +0.j,  0. +0.j,  0.6+0.j]],
         input_dims=(2, 2), output_dims=(2, 2))
</pre>


<p>
Next, we supply \(\mathbf{O}\) to the <code>ψ</code> (a <code>Statevector</code> object) in its
<code>expectation_value()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">O_exp</span> = &#968;.expectation_value( O )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(O_exp)
</pre>
</div>

<pre class="example">
(0.6999999999999997+0j)
</pre>
</div>
</div>

<div id="outline-container-org646bca7" class="outline-4">
<h4 id="org646bca7"><span class="section-number-4">2.5.4.</span> Bloch Vectors</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
We can ask Python to draw the Bloch vector for ψ:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Use this in Jupyter:</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#968;.draw('bloch')</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Comment this out or omit the following in Jupyter</span>
p
<span style="color: #DFAF8F;">fname</span> = os.join(<span style="color: #CC9393;">'html'</span>, <span style="color: #CC9393;">'img'</span>, <span style="color: #CC9393;">'basicBlochVect.png'</span>)
&#968;.draw(<span style="color: #CC9393;">'bloch'</span>, filename=fname)
<span style="color: #F0DFAF; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #F0DFAF; font-weight: bold;">as</span> plt
plt.savefig( fname )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">'[[./</span>{fname[5:]}<span style="color: #CC9393;">]]'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">ls *.png
</pre>
</div>


<div id="orgc9e908b" class="figure">
<p><img src="./img/basicBlochVect.png" alt="basicBlochVect.png" width="480px" />
</p>
<p><span class="figure-number">Figure 3: </span>Bloch vectors for the two qubits in ψ.</p>
</div>
</div>
</div>


<div id="outline-container-orge0997d1" class="outline-4">
<h4 id="orge0997d1"><span class="section-number-4">2.5.5.</span> Density Matrices</h4>
<div class="outline-text-4" id="text-2-5-5">
<p>
Similar to a <code>Statevector</code>, we can also get a <code>DensityMarix</code> from a
circuit. Recall that a density matrix \(\rho\) may be obtained from a state
vector:
</p>
\begin{equation}
\rho = \ket{\psi} \bra{\psi}
\end{equation}
</div>

<ol class="org-ol">
<li><a id="org6fd085a"></a>Matrix Output<br />
<div class="outline-text-5" id="text-2-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;</span> = qi.DensityMatrix( qc )
<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, you may use</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">display( &#961; )</span>
</pre>
</div>

<pre class="example">
DensityMatrix([[ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j],
               [ 0.25+0.j, -0.25+0.j,  0.25+0.j, -0.25+0.j],
               [-0.25+0.j,  0.25+0.j, -0.25+0.j,  0.25+0.j]],
              dims=(2, 2))
</pre>



<p>
In Jupyter, you may see output like this from the <code>display()</code> command:
</p>
\begin{equation}
\begin{bmatrix}
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\frac{1}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}  \\
- \frac{1}{4} & \frac{1}{4} & - \frac{1}{4} & \frac{1}{4}  \\
\end{bmatrix}
\end{equation}
</div>
</li>



<li><a id="org66a0cd5"></a>The City Plot<br />
<div class="outline-text-5" id="text-2-5-5-2">
<p>
In Jupyter, we can plot the elements of the density matrix:
</p>

<div id="org2b463c3" class="figure">
<p><img src="./img/dmCityScape.png" alt="dmCityScape.png" width="600px" />
</p>
</div>
</div>
</li>

<li><a id="org503319a"></a>Partial Trace<br />
<div class="outline-text-5" id="text-2-5-5-3">
<p>
Given a multi-qubit density matrix, we can get a reduced density matrix for any
subset of qubits.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">&#961;1</span> = qi.partial_trace( &#961;, [0] )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(&#961;1)
</pre>
</div>

<pre class="example">
DensityMatrix([[0.5+0.j, 0.5+0.j],
               [0.5+0.j, 0.5+0.j]],
              dims=(2,))
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org3e281b8" class="outline-3">
<h3 id="org3e281b8"><span class="section-number-3">2.6.</span> Conclusion</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>The <code>quantum_info</code> module is useful for:
<ul class="org-ul">
<li>very basic simulations</li>
<li>exploring the quantum output of a circuit</li>
</ul></li>
<li>The <code>quantum_info</code> module does not handle circuit simulations that:
<ul class="org-ul">
<li>are too large</li>
<li>involve any measurement gates</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec:BasicSimulator" class="outline-2">
<h2 id="sec:BasicSimulator"><span class="section-number-2">3.</span> The <code>BasicSimulator</code> Class</h2>
<div class="outline-text-2" id="text-sec:BasicSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>

<ul class="org-ul">
<li>We need the <code>BasicSimulator</code> class to perform simulations for circuits that
include measurement gates</li>
</ul>
</div>
<div id="outline-container-org3940eb9" class="outline-3">
<h3 id="org3940eb9"><span class="section-number-3">3.1.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Following Diego Serrano's tutorial, I build a circuit which includes
measurement gates
<ul class="org-ul">
<li><p>
Start by importing required code
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #DFAF8F;">simulator_basic</span> = BasicSimulator()
</pre>
</div>

<ul class="org-ul">
<li>The main things we've accomplished in this code are:
<ul class="org-ul">
<li>We have imported the <code>BasicSimulator</code> class</li>
<li>We have created <code>simulator_basic</code> as a <code>BasicSimulator</code> object.</li>
</ul></li>
</ul></li>
<li><p>
Build the circuit with two quantum bits and two classical bits
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 1</span>
qc.x(0).c_if(1,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1 </span>
qc.measure(0, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 0, record its result to classical bit 0</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>

<pre class="example">
/var/folders/88/d26ncvp97zg50164_cmmlyf511m8tn/T/babel-bmQJhU/python-AGP0D6:5: DeprecationWarning: The method ``qiskit.circuit.instructionset.InstructionSet.c_if()`` is deprecated as of qiskit 1.3.0. It will be removed in 2.0.0.
  qc.x(0).c_if(1,1) # apply a X gate to qubit 0 if classical bit 1 is 1
</pre></li>
</ul></li>
</ul>



<div id="org1b6c5a2" class="figure">
<p><img src="./img/QCwithMeas.png" alt="QCwithMeas.png" width="525px" />
</p>
<p><span class="figure-number">Figure 4: </span>This circuit has two qubits and two classical bits. The classical bits are required for measuremnt.</p>
</div>

<p>
In a Jupyter notebook, the output of <code>qc.draw()</code> will resemble Figure
<a href="#org1b6c5a2">4</a>.
</p>
</div>
</div>
<div id="outline-container-org46826ef" class="outline-3">
<h3 id="org46826ef"><span class="section-number-3">3.2.</span> Simulating the Circuit</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
To run the circuit, we use the BasicSimulator.run() method, and we supply the
desired circuit, and we can specify the number of shots for our simulation:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">The .run() method performs the simulation, and and the run is</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">saved as job</span>
<span style="color: #DFAF8F;">job</span> = simulator_basic.run( qc, shots=1024 )

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(job))
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.providers.basic_provider.basic_provider_job.BasicProviderJob'&gt;
</pre>

<ul class="org-ul">
<li>This <code>run()</code> method returns a <code>BasicProviderJob</code> object
<ul class="org-ul">
<li>This has a <code>result()</code> method that returns a <code>Result()</code> object contains our
simulation results</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf51296a" class="outline-3">
<h3 id="orgf51296a"><span class="section-number-3">3.3.</span> Getting the Results</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li><p>
We save the results as <code>results</code>:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">results</span> = job.result()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(results))

<span style="color: #DCDCCC; font-weight: bold;">print</span>(results)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.result.result.Result'&gt;
Result(backend_name='basic_simulator', backend_version='0.1', qobj_id='5fa46fbe-251b-4733-b29c-6cd05bb52024', job_id='5abb07aa-3a06-4ff7-94e5-a27a9e678d07', success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 519, '0x3': 505}), header=QobjExperimentHeader(qubit_labels=[['q', 0], ['q', 1]], n_qubits=2, qreg_sizes=[['q', 2]], clbit_labels=[['c', 0], ['c', 1]], memory_slots=2, creg_sizes=[['c', 2]], name='circuit-160', global_phase=0.0, metadata={}), status=DONE, name='circuit-160', seed_simulator=np.int32(1719395928), time_taken=0.07600593566894531)], date=None, status=COMPLETED, header=QobjHeader(backend_name='basic_simulator', backend_version='0.1'), time_taken=0.0760350227355957)
</pre></li>

<li>The results object has lots of information about our quantum experiment
simulation</li>
</ul>
</div>

<div id="outline-container-orgc4e2b2b" class="outline-4">
<h4 id="orgc4e2b2b"><span class="section-number-4">3.3.1.</span> Simulation Counts</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li><p>
A <code>get_counts()</code> method helps us retrieve the outcomes and their frequencies.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts</span> = results.get_counts()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)
</pre>
</div>

<pre class="example">
{'00': 519, '11': 505}
</pre></li>
</ul>
</div>
</div>

<div id="outline-container-org8b508f9" class="outline-4">
<h4 id="org8b508f9"><span class="section-number-4">3.3.2.</span> Visualizing the Results</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>We can plot the measurement results in two ways:
<ul class="org-ul">
<li>as a histogram (counts) using <code>plot_histogram()</code>, or</li>
<li>as a probability distribution using <code>plot_distribution()</code>.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

display( plot_distribution( counts ) )

display( plot_histogram( counts ) )
</pre>
</div>


<div id="org66b2f20" class="figure">
<p><img src="./img/basicSimHist.png" alt="basicSimHist.png" width="600px" />
</p>
<p><span class="figure-number">Figure 5: </span>A histogram from the results of a <code>BasicSimulator.run()</code> simulation.</p>
</div>


<div id="org4027d26" class="figure">
<p><img src="./img/basicSimPD.png" alt="basicSimPD.png" width="600px" />
</p>
<p><span class="figure-number">Figure 6: </span>A quasi-probability distribution from the results of a <code>BasicSimulator.run()</code> simulation. Quasiprobabilities are not actual probabilities, but rather estimates of probabilites obtained by dividing the number of occurrences of an event by the total number of experiments (shots).</p>
</div>
</div>
</div>

<div id="outline-container-orgd6f3cda" class="outline-4">
<h4 id="orgd6f3cda"><span class="section-number-4">3.3.3.</span> Inspecting Results from Individual Measurements</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>We can see the results of individual measurements if we use the <code>get_memory()</code> method for a <code>Results</code> object
<ul class="org-ul">
<li>This requires using the <code>memory</code> keyword with a value of <code>True</code> in the
<code>run()</code> method for our basic simulator</li>
</ul></li>
<li>Here, we do this with a fewer number of shots so that we can avoid
overwhelming ourselves with numerous results</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">small_job</span> = simulator_basic.run( qc, shots=8, memory=<span style="color: #BFEBBF;">True</span>)
<span style="color: #DFAF8F;">small_result</span> = small_job.result()
<span style="color: #DFAF8F;">samples</span> = small_result.get_memory()

<span style="color: #DCDCCC; font-weight: bold;">print</span>(samples)
</pre>
</div>

<pre class="example">
['00', '00', '00', '00', '11', '11', '11', '00']
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf70d140" class="outline-3">
<h3 id="orgf70d140"><span class="section-number-3">3.4.</span> Handling Complex Circuits</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>The basic simulator cannot handle more complex circuits readily, such as the QFT circuit</li>
<li>To handle complex circuits, we must first transpile our circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit.library <span style="color: #F0DFAF; font-weight: bold;">import</span> QFT

<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(3, 3) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">3 qubits, 3 classical bits</span>
qc.append( QFT(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )
qc.measure( <span style="color: #DCDCCC; font-weight: bold;">range</span>(3), <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) )

qc.draw()
</pre>
</div>


<div id="org036f558" class="figure">
<p><img src="./img/BasicSimQFT.png" alt="BasicSimQFT.png" width="480px" />
</p>
<p><span class="figure-number">Figure 7: </span>This is a more complex circuit including a QFT. <code>BasicSimulator</code> cannot handle this unless we first transpile it.</p>
</div>
</div>

<div id="outline-container-org4c83ef7" class="outline-4">
<h4 id="org4c83ef7"><span class="section-number-4">3.4.1.</span> Transpilation</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>Circuits may be composed of gates of various types</li>
<li>Some gates may not exist natively on a particular quantum processing unit
(QPU), but may be implemented using the available gates on the QPU
<ul class="org-ul">
<li>The set of available gates is often called the instruction set architecture
(ISA)</li>
</ul></li>
<li>To transpile a circuit is to represent it in the ISA of a particular machine</li>
<li>In this case, we transpile the QFT into gates available within the
<code>BasicSimulator</code> class.</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>This code transpiles the circuit of Figure <a href="#org036f558">7</a></label><pre class="src src-python" id="org0e78b81"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile

<span style="color: #DFAF8F;">qc_trans</span> = transpile( qc, backend=simulator_basic)

qc_trans.draw()

</pre>
</div>

<p>
Jupyter output for Listing will resemble Figure <a href="#org8f5670a">8</a>
</p>

<div id="org8f5670a" class="figure">
<p><img src="./img/BasicSimQFTtrans.png" alt="BasicSimQFTtrans.png" width="640px" />
</p>
<p><span class="figure-number">Figure 8: </span>This is a transpiled version of the circuit from Figure <a href="#org036f558">7</a></p>
</div>
</div>
</div>
</div>

<div id="outline-container-org5ea8824" class="outline-3">
<h3 id="org5ea8824"><span class="section-number-3">3.5.</span> Conclusion</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>The <code>BasicSimulator()</code> class is useful when we simulate a job where we need to
find counts or samples of a circuit with mid-circuit measurements</li>
<li>The <code>BasicSimulator()</code> class should not be used for:
<ul class="org-ul">
<li>large circuits with many qubits or many gates</li>
<li>circuits where a coherent state is desired (state vector or density matrix)</li>
<li>noisy simulations</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec:QiskitAerSimulator" class="outline-2">
<h2 id="sec:QiskitAerSimulator"><span class="section-number-2">4.</span> The <code>qiskit_aer.AerSimulator</code> Class</h2>
<div class="outline-text-2" id="text-sec:QiskitAerSimulator">
<p>
<i>[Go back to <a href="./index.html">Table of Contents</a>]</i>
</p>
</div>

<div id="outline-container-org10607c1" class="outline-3">
<h3 id="org10607c1"><span class="section-number-3">4.1.</span> Overview</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>The Qiskit Aer AerSimulator class can be used to simulate complex circuits with mid-circuit measurements</li>
<li>We can obtain unitary results from these simulations.</li>
<li>Qiskit Aer supports both noise-free and noisy simulations</li>
<li>The Qiskit <code>AerSimulator</code> class has a <code>run()</code> method that is simple and
straightforward to use; however, its syntax is notably different from the
tools used to launch calculations on actual quantum hardware (quantum
processing units).</li>
<li>The <code>qiskit_ibm_runtime</code> package provides interfaces called <b>primitives</b> to
run jobs on QPUs. These primitives include:
<ul class="org-ul">
<li><code>SamplerV2</code> for obtaining counts for an ensemble of measurements on a circuit</li>
<li><code>EstimatorV2</code> for obtaining expectation values from the output of a circuit</li>
</ul></li>
<li>To simulate circuits in a way as closely as possible to the
<code>qiskit_ibm_runtime</code> primitives, <code>qiskit_aer</code> also provides <code>SamplerV2</code> and
<code>EstimatorV2</code> primitives
<ul class="org-ul">
<li>The <code>qiskit_aer</code> primitives are designed for similarity with
the <code>qiskit_ibm_runtime</code> primitives</li>
</ul></li>
<li>In summary:
<ul class="org-ul">
<li><code>qiskit_aer.AerSimulator</code> has a <code>run()</code> method for simulating quantum circuits
<ul class="org-ul">
<li>This is notably different from primitives used to run jobs on quantum hardware</li>
</ul></li>
<li><code>qiskit_aer.primitives</code> has <code>SamplerV2</code> and <code>EstimatorV2</code> classes, which may
be used to simulate circuits in a way very similar to the primitives used
for running jobs on QPUs using <code>qiskit_ibm_runtime</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org14e1f1d" class="outline-3">
<h3 id="org14e1f1d"><span class="section-number-3">4.2.</span> Imports</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>We begin by importing the required packages
<ul class="org-ul">
<li>This introduces the <code>qiskit_aer</code> package and the <code>AerSimulator</code> class</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit <span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">, transpile</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit.quantum_info import Statevector</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit.providers.basic_provider import BasicSimulator</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">from qiskit_aer import AerSimulator</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator_basic = BasicSimulator()</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">simulator_aer = AerSimulator()</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'test'</span>)
</pre>
</div>

<pre class="example">
test
</pre>
</div>
</div>


<div id="outline-container-org7df2934" class="outline-3">
<h3 id="org7df2934"><span class="section-number-3">4.3.</span> Build a Circuit</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><p>
We define a circuit in Listing <a href="#org372b2ab">1</a>
</p>
<div class="org-src-container">
<pre class="src src-python" id="org078746e"><span style="color: #F0DFAF; font-weight: bold;">import</span> qiskit
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">two qubits, and two classical bits</span>

qc.h(1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a H gate to qubit 1</span>
qc.measure(1, 0) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measure qubit 1, record its bit to classical bit 0</span>
qc.h(0).c_if(0,1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">apply a X gate to qubit 0 if classical bit 1 is 1</span>
qc.save_statevector()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(qiskit.__version__)
</pre>
</div>

<pre class="example">
1.3.1
</pre></li>
</ul>




<div id="org459883d" class="figure">
<p><img src="./img/CktAerSim.png" alt="CktAerSim.png" width="480px" />
</p>
<p><span class="figure-number">Figure 9: </span>This is a two-qubit circuit with a measurement in the middle of the circuit.</p>
</div>

<ul class="org-ul">
<li>Here, the <code>save_statevector()</code> method defines a point in the circuit at
which we wish to knkow the state vector</li>
</ul>
</div>
</div>
<div id="outline-container-org3295c4a" class="outline-3">
<h3 id="org3295c4a"><span class="section-number-3">4.4.</span> Run the <code>AerSimulator()</code></h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><p>
We first transpile the circuit so it is suitable for our simulator, and then we run it:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968; <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">show the state vector in Jupyter Lab</span>
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |10\rangle+\frac{\sqrt{2}}{2} |11\rangle
\end{equation}</li>
</ul>
</div>
</div>
<div id="outline-container-orgdf9b48d" class="outline-3">
<h3 id="orgdf9b48d"><span class="section-number-3">4.5.</span> Example 2: Circuit with Statevector in Middle of Circuit</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li><p>
Now, we provide an example where the state vector is saved from a point prior to the end of the circuit.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(4)
qc.h(3)
qc.cx(3,2)
qc.save_statevector()
qc.cx(3,1)
qc.cx(3,0)
qc.measure_all()

qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org33c6b65" class="figure">
<p><img src="./img/AerSimMultiStatevectCkt.png" alt="AerSimMultiStatevectCkt.png" width="640px" />
</p>
<p><span class="figure-number">Figure 10: </span>This circuit saves a <code>Statevector</code> in the middle of the calculation and just prior to measurement.</p>
</div></li>
</ul>
</div>

<div id="outline-container-orgfb272c9" class="outline-4">
<h4 id="orgfb272c9"><span class="section-number-4">4.5.1.</span> Transpile and Run the Circuit</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li><p>
Next, we transpile and run the circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc_aer</span> = transpile(qc, backend=simulator_aer)

<span style="color: #DFAF8F;">result</span> = simulator_aer.run(qc_aer).result()

<span style="color: #DFAF8F;">&#968;</span> = result.get_statevector()
&#968;
</pre>
</div>

\begin{equation}
\frac{\sqrt{2}}{2} |0000\rangle+\frac{\sqrt{2}}{2} |1100\rangle
\end{equation}</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgbe7881a" class="outline-3">
<h3 id="orgbe7881a"><span class="section-number-3">4.6.</span> Efficient Simulation</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>Portions of the <code>AerSimulator</code> code are compiled to <code>C</code>
<ul class="org-ul">
<li>This allows faster and more efficient simulations, which enables simulations
of larger and more complex circuits.</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org1cdd55b" class="outline-4">
<h4 id="org1cdd55b"><span class="section-number-4">4.6.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-6-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 24
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-org26b7cc3" class="outline-4">
<h4 id="org26b7cc3"><span class="section-number-4">4.6.2.</span> Run and Time the Circuit: <code>BasicSimulator</code> vs <code>AerSimulator</code></h4>
<div class="outline-text-4" id="text-4-6-2">
</div>
<ol class="org-ol">
<li><a id="org09fb5fa"></a>BasicSimulator<br />
<div class="outline-text-5" id="text-4-6-2-1">
<ul class="org-ul">
<li>In the following code, I simulate and time the circuit</li>
<li>In Jupyter Lab, the time to run a cell can be obtained by adding <code>%%time</code> at
the top of the cell.</li>
<li>These notes are not written in Jupyter Lab, so I use the <code>time</code> module
<ul class="org-ul">
<li>Key instructions:
<ul class="org-ul">
<li><code>import time</code> to access the module</li>
<li>Use <code>time.time()</code> to get the current time</li>
<li>The difference between two <code>time</code> objects can be used to calculate a time
interval in seconds</li>
</ul></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> time
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_basic.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_basic_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_basic_sim ))
</pre>
</div>

<pre class="example">
{'000000000000000000000000': 531, '111111111111111111111111': 493}
Time elapsed: 17.700 s
</pre>
</div>
</li>

<li><a id="org7527a2f"></a><code>AerSimulator</code><br />
<div class="outline-text-5" id="text-4-6-2-2">
<ul class="org-ul">
<li>We now run and time the same circuit using the <code>AerSimulator</code>, and we see it
is much faster for larger circuits</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024 ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'111111111111111111111111': 537, '000000000000000000000000': 487}
Time elapsed:  0.025 s
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org95ca613" class="outline-3">
<h3 id="org95ca613"><span class="section-number-3">4.7.</span> Simulation Methods</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>Qiskit Aer supports different types of simulation, accessible through the
<code>method</code> keyword argument to the <code>run()</code> command.
<ul class="org-ul">
<li>The default is <code>method</code>'statevector'=
<ul class="org-ul">
<li>The limit here is 24 qubits</li>
</ul></li>
<li>Other methods include <code>'matrix_product_state'</code></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org4fa8fed" class="outline-4">
<h4 id="org4fa8fed"><span class="section-number-4">4.7.1.</span> Build a Large Circuit</h4>
<div class="outline-text-4" id="text-4-7-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">n</span> = 50
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(n)
qc.h(n-1)

<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(n-1, 0, -1):
    qc.cx(i,i-1)

qc.measure_all()

<span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt; 16:
    display(qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>))
<span style="color: #F0DFAF; font-weight: bold;">else</span>:
    <span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Suppressed display of large circuit.'</span>)
</pre>
</div>

<pre class="example">
Suppressed display of large circuit.
</pre>
</div>
</div>

<div id="outline-container-org9670756" class="outline-4">
<h4 id="org9670756"><span class="section-number-4">4.7.2.</span> Run and Time the Simulation</h4>
<div class="outline-text-4" id="text-4-7-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment the '%%time'</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">%%time</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">timing for non-Jupyter-Lab work</span>
<span style="color: #DFAF8F;">start</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log start time - not required for Jupyter</span>
<span style="color: #DFAF8F;">result</span> = simulator_aer.run( qc, shots=1024, method=<span style="color: #CC9393;">'matrix_product_state'</span> ).result()
<span style="color: #DFAF8F;">end</span> = time.time() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">log end time - not required for Jupyter</span>
<span style="color: #DFAF8F;">time_aer_sim</span> = end - start <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">not needed in Jupyter</span>

<span style="color: #DFAF8F;">counts</span> = result.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">print() not needed if using %%time in Jupyter Lab</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Time elapsed: {0:6.3f} s'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>( time_aer_sim ))
</pre>
</div>

<pre class="example">
{'11111111111111111111111111111111111111111111111111': 492, '00000000000000000000000000000000000000000000000000': 532}
Time elapsed:  0.081 s
</pre>
</div>
</div>
</div>

<div id="outline-container-org2511993" class="outline-3">
<h3 id="org2511993"><span class="section-number-3">4.8.</span> Noisy Simulation</h3>
<div class="outline-text-3" id="text-4-8">
</div>
<div id="outline-container-orgd4c65d4" class="outline-4">
<h4 id="orgd4c65d4"><span class="section-number-4">4.8.1.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-4-8-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0])

qc.draw()
</pre>
</div>


<div id="org9a61dbd" class="figure">
<p><img src="./img/noisyCktExample.png" alt="noisyCktExample.png" width="480px" />
</p>
<p><span class="figure-number">Figure 11: </span>This is a small circuit for noisy simulation using the <code>AerSimulator</code>.</p>
</div>
</div>
</div>

<div id="outline-container-org5900ef2" class="outline-4">
<h4 id="org5900ef2"><span class="section-number-4">4.8.2.</span> Ideal Result</h4>
<div class="outline-text-4" id="text-4-8-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This will throw an error for n &gt; 25 using method='statevector'</span>
<span style="color: #DFAF8F;">qc_aer</span> = transpile( qc, backend=simulator_aer )
<span style="color: #DFAF8F;">result_ideal</span> = simulator_aer.run( qc_aer, shots=1024 ).result()
<span style="color: #DFAF8F;">counts_ideal</span> = result_ideal.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_ideal)
</pre>
</div>

<pre class="example">
{'11': 520, '00': 504}
</pre>
</div>
</div>

<div id="outline-container-orge0c8b0a" class="outline-4">
<h4 id="orge0c8b0a"><span class="section-number-4">4.8.3.</span> Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit_aer <span style="color: #F0DFAF; font-weight: bold;">import</span> noise

<span style="color: #DFAF8F;">prob</span> = 0.1
<span style="color: #DFAF8F;">error</span> = noise.depolarizing_error( prob, 2 )

<span style="color: #DFAF8F;">noise_model</span> = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error( error, [<span style="color: #CC9393;">'cx'</span>])
<span style="color: #DFAF8F;">basis_gates</span> = noise_model.basis_gates

<span style="color: #DFAF8F;">result_noisy</span> = simulator_aer.run(qc,
                                shots=1024,
                                noise_model=noise_model,
                                basis_gates=basis_gates).result()

<span style="color: #DFAF8F;">counts_noisy</span> = result_noisy.get_counts()
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb127039" class="outline-4">
<h4 id="orgb127039"><span class="section-number-4">4.8.4.</span> Compare Ideal Result and Noisy Result</h4>
<div class="outline-text-4" id="text-4-8-4">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.visualization <span style="color: #F0DFAF; font-weight: bold;">import</span> plot_histogram, plot_distribution

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">In Jupyter Lab, uncomment this to see the compared distributions</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">plot_distribution( [counts_ideal, counts_noisy], title='Noiseless vs. Noisy Simulated Counts' )</span>
</pre>
</div>


<div id="orgf4a58f2" class="figure">
<p><img src="./img/AerSimIdealvsNoisy.png" alt="AerSimIdealvsNoisy.png" width="640px" />
</p>
<p><span class="figure-number">Figure 12: </span>An ideal <code>AerSimulator</code> result is compared to a noisy result.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfd5b309" class="outline-3">
<h3 id="orgfd5b309"><span class="section-number-3">4.9.</span> Summary</h3>
<div class="outline-text-3" id="text-4-9">
<p>
The <code>AerSimulator()</code> is useful when we want to:
</p>
<ol class="org-ol">
<li>Find counts/samples of large circuits (simulators are efficient)</li>
<li>Find state vector/density matrix of circuits with measurements</li>
<li>Simulate circuits with noise</li>
</ol>

<p>
The AerSimulator() results do not match the output format of Qiskit IBM runtime
(the quantum hardware).
</p>

<p>
Qiskit Aer has its own sampler/estimator, which provide a closer match to the
inputs and outputs of the hardware, but these are being deprecated.
</p>

<p>
In the next section, we explore <a href="https://docs.quantum.ibm.com/api/qiskit/primitives">primitives</a>, which are used
in Qiskit IBM runtime.
</p>
</div>
</div>
</div>

<div id="outline-container-org64eeefa" class="outline-2">
<h2 id="org64eeefa"><span class="section-number-2">5.</span> Qiskit Primitives</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgdb72294" class="outline-3">
<h3 id="orgdb72294"><span class="section-number-3">5.1.</span> Overview</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>The interface for the various simulators (BasicSimulator, AerSimulator) were
identical to the Qiskit IBM Provider interface to the quantum hardware</li>
<li>The backend was an abstraction for something that was either simulator or an
actual quantum processor.</li>
<li>Primitives abstract the interface between users and backends</li>
<li>There are two available primitives:
<ul class="org-ul">
<li>Sampler - this samples the output state of a circuit</li>
<li>Estimator - this stimates expectation values of a state with respect to
observables</li>
</ul></li>
<li>Qiskit, Qiskit Aer, and Qiskit IBM Runtime each provide different primitives.</li>
<li>Diego recommends starting with the version 2 primitives, which are compatible
with the current hardware:</li>

<li>Qiskit
<ul class="org-ul">
<li>StatevectorSampler</li>
<li>StatevectorEstimator</li>
</ul></li>
<li><code>qiskit_aer</code>
<ul class="org-ul">
<li><code>primitives.SamplerV2</code></li>
<li><code>primitives.EstimatorV2</code></li>
</ul></li>
<li><code>qiskit_ibm_runtime</code>
<ul class="org-ul">
<li><code>SamplerV2</code></li>
<li><code>EstimatorV2</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgda4373f" class="outline-3">
<h3 id="orgda4373f"><span class="section-number-3">5.2.</span> Primitives</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Qiskit primitives are computational building blocks used in larger applications that require quantum resources to efficiently produce outputs. The inputs to a primitive consists of primitive unified blocs (PUBs).
</p>

<p>
There are two types of primitives:
</p>
<ol class="org-ol">
<li><code>EstimatorV2</code></li>
<li><code>SamplerV2</code></li>
</ol>

<p>
The workflow is as before: build a circuit, and then simulate it (or run it on
hardware).
</p>
</div>

<div id="outline-container-orga27e328" class="outline-4">
<h4 id="orga27e328"><span class="section-number-4">5.2.1.</span> Imports</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorSampler, StatevectorEstimator
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.providers.basic_provider <span style="color: #F0DFAF; font-weight: bold;">import</span> BasicSimulator

<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #CC9393;">'imports complete'</span>) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">it's sometimes desirable to check job completion</span>
</pre>
</div>

<pre class="example">
imports complete
</pre>
</div>
</div>

<div id="outline-container-orgc49b66b" class="outline-4">
<h4 id="orgc49b66b"><span class="section-number-4">5.2.2.</span> Build a Circuit</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2, 2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0],[1,0]) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">measurement register: c</span>
qc.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org588f32e" class="figure">
<p><img src="./img/qisprimckt01.png" alt="qisprimckt01.png" width="480px" />
</p>
<p><span class="figure-number">Figure 13: </span>This is a circuit for use with the <code>qiskit</code> primitives.</p>
</div>
</div>
</div>

<div id="outline-container-org463507f" class="outline-4">
<h4 id="org463507f"><span class="section-number-4">5.2.3.</span> Run Simulations</h4>
<div class="outline-text-4" id="text-5-2-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">simulator</span> = BasicSimulator()
<span style="color: #DFAF8F;">sampler</span> = StatevectorSampler()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org85f2175"></a>Basic Simulation<br />
<div class="outline-text-5" id="text-5-2-3-1">
<p>
This simulates the circuit using ~qiskit.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">No transpilation is needed for this simple circuit</span>
<span style="color: #DFAF8F;">job_simulator</span> = simulator.run( qc, shots=1024)
</pre>
</div>
</div>
</li>

<li><a id="orgaac53be"></a>Simulation using a Sampler<br />
<div class="outline-text-5" id="text-5-2-3-2">
<ul class="org-ul">
<li>The syntax for a sampler simulation is somewhat different than that of the
<code>BasicSimulator</code> class.
<ul class="org-ul">
<li>Here, inputs are in the form of primitive-unified blocs (PUBS)</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job_sampler</span> = sampler.run( [qc], shots=1024)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org21278c0" class="outline-4">
<h4 id="org21278c0"><span class="section-number-4">5.2.4.</span> Extracting Results</h4>
<div class="outline-text-4" id="text-5-2-4">
<ul class="org-ul">
<li>We extract results in the same way from both the simulator and the sampler:</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_simulator</span> = job_simulator.result()
<span style="color: #DFAF8F;">result_sampler</span> = job_sampler.result()
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgd71a62d"></a>Simulator Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-1">
<ul class="org-ul">
<li><p>
We can retrieve counts from the simulator result as before, using the
<code>get_counts()</code> method:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = result_simulator.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>( counts_simulator )
</pre>
</div>

<pre class="example">
{'11': 522, '00': 502}
</pre></li>
</ul>
</div>
</li>


<li><a id="orgccc2f6b"></a>Sampler Counts<br />
<div class="outline-text-6" id="text-5-2-4-0-2">
<ul class="org-ul">
<li><p>
Getting counts from the sampler is a bit more involved. Let's eamine the
results we obtained:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">type</span>(result_sampler))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_sampler)
</pre>
</div>

<pre class="example">
&lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
PrimitiveResult([SamplerPubResult(data=DataBin(c=BitArray(&lt;shape=(), num_shots=1024, num_bits=2&gt;)), metadata={'shots': 1024, 'circuit_metadata': {}})], metadata={'version': 2})
</pre>


<ul class="org-ul">
<li>The results from the sampler come as an object of class <code>PubResult</code>
object.
<ul class="org-ul">
<li>This class has a <code>get_counts()</code> method.</li>
<li>Since the input PUB for the sampler is a list, we must similarly index the
result to get the result(s)  for a specific PUB item.</li>
<li>If we don't provide an index, get<sub>counts</sub>() will
aggregate the results, which may not be what we want.</li>
</ul></li>
</ul></li>
<li>To get counts, we do the following:</li>
<li>index the PUB result. Here, we call for the zeroth element.</li>
<li>reference the data member data element, and reference the classical register name.</li>
<li><p>
use the <code>get_counts()</code> method.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[0].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 504, '00': 520}
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org4344055" class="outline-3">
<h3 id="org4344055"><span class="section-number-3">5.3.</span> Example: A Parametrized Circuit</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> transpile
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter
<span style="color: #F0DFAF; font-weight: bold;">from</span> math <span style="color: #F0DFAF; font-weight: bold;">import</span> pi

<span style="color: #DFAF8F;">&#952;</span> = Parameter(<span style="color: #CC9393;">'&#952;'</span>)

<span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1) <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">assign a parameter for this rotation</span>
qc2.cx(1, 0)
qc2.measure_all()
qc2.draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org45cd86a" class="figure">
<p><img src="./img/prametrizedckt.png" alt="prametrizedckt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 14: </span>This circuit has a parameter θ.</p>
</div>
</div>


<div id="outline-container-org23f3606" class="outline-4">
<h4 id="org23f3606"><span class="section-number-4">5.3.1.</span> <code>BasicSimulator</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Here, we make a list of circuits, each with a specific value of the parameter θ.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">angles</span> = [[pi/4], [pi/3], [pi/2]]

<span style="color: #DFAF8F;">circuits</span> = []
<span style="color: #F0DFAF; font-weight: bold;">for</span> angle <span style="color: #F0DFAF; font-weight: bold;">in</span> angles:
    <span style="color: #DFAF8F;">qc_temp</span> = qc2.assign_parameters({&#952;:angle[0]})
    circuits.append(qc_temp)
</pre>
</div>

<p>
We can draw the different circuits by indexing the list:
</p>
<div class="org-src-container">
<pre class="src src-python">circuits[1].draw(reverse_bits=<span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="org711f1da" class="figure">
<p><img src="./img/prametrizedckt_ex.png" alt="prametrizedckt_ex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 15: </span>We print a circuit from a list of circuits. Unlike the circuit of Fig. <a href="#org45cd86a">14</a>, this circuit has a specific value for θ.</p>
</div>
</div>


<ol class="org-ol">
<li><a id="orgd74f22f"></a>Transpiling and Running<br />
<div class="outline-text-5" id="text-5-3-1-1">
<ul class="org-ul">
<li>The entire list of circuits can be transpiled in a single call to <code>transpile()</code></li>
<li><p>
The transpiled list can be called using one call to the <code>BasicSimulator.run()</code>
method.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">transpile the circuit list</span>
<span style="color: #DFAF8F;">circuits_t</span> = transpile( circuits, backend=simulator )

<span style="color: #DFAF8F;">result_simulator</span> = simulator.run( circuits_t, shots=1024 ).result()
</pre>
</div></li>
<li><p>
We provide an index to <code>get_counts()</code> for the corresponding circuit in
<code>circuits_t</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_simulator</span> = []

<span style="color: #F0DFAF; font-weight: bold;">for</span> i, _ <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(angles):
    <span style="color: #DFAF8F;">result_temp</span> = result_simulator.get_counts(i)
    counts_simulator.append(result_temp)

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_simulator)
</pre>
</div>

<pre class="example">
[{'00': 875, '11': 149}, {'00': 780, '11': 244}, {'11': 465, '00': 559}]
</pre></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org21e9bba" class="outline-4">
<h4 id="org21e9bba"><span class="section-number-4">5.3.2.</span> <code>StatevectorSampler</code> Usage</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>For a sampler, we pass a list of PUBs. This contains
<ul class="org-ul">
<li>the generic parametrized circuit, along with</li>
<li>the list of parameters</li>
</ul></li>
<li>This makes the <code>run()</code> command very simple.</li>
<li>To get the results, we index the <code>result_sampler</code>, i.e., <code>results_sampler[0]</code>
<ul class="org-ul">
<li>This indexes the zeroth (and only) PUB, with the flexibility to support multiple PUBs</li>
</ul></li>
<li>We iterate over the angles as before to get results for each angles</li>
</ul>
<div class="warning" id="org7fa8e0c">
<p>
Caution: if we simply use <code>result.sampler[0].data.meas.get_counts()</code>, this aggregates the counts by summing them. Often, this is not what we want. 
</p>

</div>
</div>
</div>


<div id="outline-container-org3f8fcc0" class="outline-4">
<h4 id="org3f8fcc0"><span class="section-number-4">5.3.3.</span> <code>StatevectorSampler</code> Usage with Multiple PUBs</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
We now pass two PUBs, each with a different circuit:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2,2)
qc.h(1)
qc.cx(1,0)
qc.measure([1,0], [1,0])

qc.draw()
</pre>
</div>


<div id="orge3947b5" class="figure">
<p><img src="./img/circuit_multiPUBex.png" alt="circuit_multiPUBex.png" width="480px" />
</p>
<p><span class="figure-number">Figure 16: </span>A circuit for use in an example with multiple PUBs.</p>
</div>
</div>

<ol class="org-ol">
<li><a id="orgd354d4b"></a>Run the Multi-Pub Basic Sampler<br />
<div class="outline-text-5" id="text-5-3-3-1">
<ul class="org-ul">
<li>Here, we run one job with two different PUBs, each with a different circuit.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">result_sampler</span> = sampler.run([(qc2, angles), (qc, <span style="color: #BFEBBF;">None</span>)], shots=1024).result()
</pre>
</div>
</div>
</li>

<li><a id="org5bc740a"></a>Retrieve Data for the Zeroth Circuit<br />
<div class="outline-text-5" id="text-5-3-3-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = [ result_sampler[0].data.meas.get_counts(k) <span style="color: #F0DFAF; font-weight: bold;">for</span> k <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(3) ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
[{'00': 857, '11': 167}, {'00': 774, '11': 250}, {'00': 501, '11': 523}]
</pre>
</div>
</li>

<li><a id="org8c9c45d"></a>Retrieve Data for the First Circuit<br />
<div class="outline-text-5" id="text-5-3-3-3">
<ul class="org-ul">
<li>Here, we have a non-parametrized circuit, so we don't need to provide an argument to <code>get_counts()</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">counts_sampler</span> = result_sampler[1].data.c.get_counts()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(counts_sampler)
</pre>
</div>

<pre class="example">
{'11': 521, '00': 503}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgc1c7409" class="outline-3">
<h3 id="orgc1c7409"><span class="section-number-3">5.4.</span> The Estimator Primitive</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>The <code>StatevectorEstimator</code> primitive takes a PUB, but with a slightly different format from <code>BasicSampler</code>.</li>
<li>The circuits cannot have any measurement gates</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">qc2</span> = QuantumCircuit(2)
qc2.rx(&#952;, 1)
qc2.cx(1, 0)

qc2.draw( reverse_bits = <span style="color: #BFEBBF;">True</span>)
</pre>
</div>


<div id="orge0636ed" class="figure">
<p><img src="./img/sample_ckt_for_Estimator.png" alt="sample_ckt_for_Estimator.png" width="480px" />
</p>
<p><span class="figure-number">Figure 17: </span>This circuit was built for use with an <code>Estimator</code> simulation. For this reason, we do not include measurement blocks.</p>
</div>
</div>

<div id="outline-container-org8cb5cfe" class="outline-4">
<h4 id="org8cb5cfe"><span class="section-number-4">5.4.1.</span> Observables</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>Since an estimator estimates expectation values \(\left\langle \psi |
  \mathbf{O} | \right\rangle\), we need an observable, \(\mathbf{O}\).</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">This is a list of observables. I'm not sure why it's a list of lists.</span>
<span style="color: #DFAF8F;">obsv</span> = [ [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"IY"</span>], [0.5, 0.5] ) ],
         [ SparsePauliOp( [<span style="color: #CC9393;">"XX"</span>], [1] ) ] ]

<span style="color: #DCDCCC; font-weight: bold;">print</span>(obsv)
</pre>
</div>

<pre class="example">
[[SparsePauliOp(['XX', 'IY'],
              coeffs=[0.5+0.j, 0.5+0.j])], [SparsePauliOp(['XX'],
              coeffs=[1.+0.j])]]
</pre>
</div>
</div>

<div id="outline-container-org68551be" class="outline-4">
<h4 id="org68551be"><span class="section-number-4">5.4.2.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-4-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
<span style="color: #DFAF8F;">result_estimator</span> = estimator.run( [(qc2, obsv, angles, 0.1)] ).result()
</pre>
</div>
</div>
</div>

<div id="outline-container-org047e043" class="outline-4">
<h4 id="org047e043"><span class="section-number-4">5.4.3.</span> Extract Expectation Values</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
<li>(optional) we can see some metadata using the <code>.metadata</code> function</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Extract the expectation values (evs) from the result for PUB 0</span>
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].data.evs)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(result_estimator[0].metadata)
</pre>
</div>

<pre class="example">
[[ 0.05985877  0.14030793  0.18762585]
 [ 0.10722808 -0.04870472  0.15934201]]
{'target_precision': 0.1, 'circuit_metadata': {}}
</pre>


<ul class="org-ul">
<li>This is a list of two observables, with one value for each of the input
parameters.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfa82c12" class="outline-3">
<h3 id="orgfa82c12"><span class="section-number-3">5.5.</span> Qiskit Estimator Example</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li><p>
This provides another example from a Qiskit documentation <a href="https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives">tutorial</a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit <span style="color: #F0DFAF; font-weight: bold;">import</span> QuantumCircuit
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.circuit <span style="color: #F0DFAF; font-weight: bold;">import</span> Parameter

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">circuit for which you want to obtain the expected value</span>
<span style="color: #DFAF8F;">qc</span> = QuantumCircuit(2)
qc.ry(Parameter(<span style="color: #CC9393;">'theta'</span>), 0)
qc.h(0)
qc.cx(0,1)
qc.draw(<span style="color: #CC9393;">"mpl"</span>, style=<span style="color: #CC9393;">"iqp"</span>)
</pre>
</div>


<div id="org15400bd" class="figure">
<p><img src="./img/EstimatorIBMExCkt.png" alt="EstimatorIBMExCkt.png" width="480px" />
</p>
<p><span class="figure-number">Figure 18: </span>This is a simple circuit built for an IBM Quantum tutorial on using the <code>StatevectorEstimator</code>.</p>
</div></li>
</ul>
</div>

<div id="outline-container-org472d1f9" class="outline-4">
<h4 id="org472d1f9"><span class="section-number-4">5.5.1.</span> Build an Operator</h4>
<div class="outline-text-4" id="text-5-5-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">observable(s) whose expected values you want to compute</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.quantum_info <span style="color: #F0DFAF; font-weight: bold;">import</span> SparsePauliOp
<span style="color: #DFAF8F;">observable</span> = SparsePauliOp([<span style="color: #CC9393;">"II"</span>, <span style="color: #CC9393;">"XX"</span>, <span style="color: #CC9393;">"YY"</span>, <span style="color: #CC9393;">"ZZ"</span>], coeffs=[1, 1, -1, 1])

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">value(s) for the circuit parameter(s)</span>
<span style="color: #DFAF8F;">parameter_values</span> = [[0], [np.pi/6], [np.pi/2]]
<span style="color: #DCDCCC; font-weight: bold;">print</span>(parameter_values)
</pre>
</div>

<pre class="example">
[[0], [0.5235987755982988], [1.5707963267948966]]
</pre>
</div>
</div>


<div id="outline-container-org69f6caf" class="outline-4">
<h4 id="org69f6caf"><span class="section-number-4">5.5.2.</span> Instantiate a <code>StatevectorEstimator</code></h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.primitives <span style="color: #F0DFAF; font-weight: bold;">import</span> StatevectorEstimator
<span style="color: #DFAF8F;">estimator</span> = StatevectorEstimator()
</pre>
</div>
</div>
</div>


<div id="outline-container-org32a0914" class="outline-4">
<h4 id="org32a0914"><span class="section-number-4">5.5.3.</span> Transpile the Circuit</h4>
<div class="outline-text-4" id="text-5-5-3">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Generate a pass manager without providing a backend</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> qiskit.transpiler.preset_passmanagers <span style="color: #F0DFAF; font-weight: bold;">import</span> generate_preset_pass_manager

<span style="color: #DFAF8F;">pm</span> = generate_preset_pass_manager(optimization_level=1)
<span style="color: #DFAF8F;">isa_circuit</span> = pm.run(qc)
<span style="color: #DFAF8F;">isa_observable</span> = observable.apply_layout(isa_circuit.layout)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7e9e34d" class="outline-4">
<h4 id="org7e9e34d"><span class="section-number-4">5.5.4.</span> Run the Estimator</h4>
<div class="outline-text-4" id="text-5-5-4">
<ul class="org-ul">
<li>We form a PUB as an argument to the <code>StatevectorEstimator</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">job</span> = estimator.run([(isa_circuit, isa_observable, parameter_values)])
<span style="color: #DFAF8F;">result</span> = job.result()
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Result class: </span>{<span style="color: #DCDCCC; font-weight: bold;">type</span>(result)}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
&gt; Result class: &lt;class 'qiskit.primitives.containers.primitive_result.PrimitiveResult'&gt;
</pre>
</div>
</div>

<div id="outline-container-org1052f5e" class="outline-4">
<h4 id="org1052f5e"><span class="section-number-4">5.5.5.</span> Extract Results</h4>
<div class="outline-text-4" id="text-5-5-5">
<ul class="org-ul">
<li>To extract the expectation values from the estimator result, we do the
following:
<ul class="org-ul">
<li>index the result</li>
<li>use the <code>.data.evs</code> property</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">print</span>(result)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">len</span>(result))
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Expectation value: </span>{result[0].data.evs}<span style="color: #CC9393;">"</span>)
<span style="color: #DCDCCC; font-weight: bold;">print</span>(f<span style="color: #CC9393;">" &gt; Metadata: </span>{result[0].metadata}<span style="color: #CC9393;">"</span>)
</pre>
</div>

<pre class="example">
PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), stds=np.ndarray(&lt;shape=(3,), dtype=float64&gt;), shape=(3,)), metadata={'target_precision': 0.0, 'circuit_metadata': {}})], metadata={'version': 2})
1
 &gt; Expectation value: [4.         3.73205081 2.        ]
 &gt; Metadata: {'target_precision': 0.0, 'circuit_metadata': {}}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Dr. E.P. Blair</p>
<p class="date">Created: 2025-03-11 Tue 20:34</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
